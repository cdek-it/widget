!function(){"use strict";try{if("undefined"!=typeof document){var t=document.createElement("style");t.appendChild(document.createTextNode('.cdek-dropdown-item[data-v-2879dff0]{align-items:center;color:#000;cursor:pointer;display:flex;flex-flow:row;padding:12px 16px;transition:background-color .3s ease,outline-color .3s ease}@media (hover:hover){.cdek-dropdown-item[data-v-2879dff0]:hover:not(.cdek-dropdown-item_disabled){background:rgba(23,160,0,.05)}}.cdek-dropdown-item_active[data-v-2879dff0]:not(.cdek-dropdown-item_disabled),.cdek-dropdown-item_selected[data-v-2879dff0]{background:rgba(23,160,0,.05)}.cdek-dropdown-item_colored[data-v-2879dff0]{color:var(--list-item-color)}.cdek-dropdown-item_colored .cdek-dropdown-item__left-icon[data-v-2879dff0]{stroke:var(--list-item-color)}.cdek-dropdown-item_disabled[data-v-2879dff0]{color:#0006;cursor:default}.cdek-dropdown-item_disabled.cdek-dropdown-item_selected[data-v-2879dff0]{background:rgba(51,85,104,.05)}.cdek-dropdown-item_disabled .cdek-dropdown-item__left-icon[data-v-2879dff0]{stroke:#0000004d}.cdek-dropdown-item__content[data-v-2879dff0]{font-family:Roboto,sans-serif;font-size:14px;font-weight:400;line-height:20px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.cdek-dropdown-item__checkmark[data-v-2879dff0]{stroke:#1ab248;flex-shrink:0;height:20px;margin-left:auto}.cdek-dropdown-item__left-icon[data-v-2879dff0]{stroke:#1ab248;flex-shrink:0;margin-right:12px}.cdek-dropdown-box[data-v-75e86828]{background:#fff;border-radius:8px;box-shadow:0 4px 12px #0000000a;margin-top:4px;outline:none;padding:12px 0;position:absolute;width:100%;z-index:1000}.cdek-input_small[data-v-ec8ba075]{padding-top:20px}.cdek-input__control[data-v-ec8ba075]{align-items:center;background:rgba(51,85,104,.05);border-radius:8px;box-shadow:inset 0 1px 2px #0021340d;box-sizing:border-box;cursor:text;display:flex;height:56px;outline:2px solid transparent;padding-block:6px;padding-inline:14px;position:relative;transition:background-color .3s ease,outline-color .3s ease}@media (hover:hover){.cdek-input__control_user-event[data-v-ec8ba075]:hover{background:rgba(26,178,72,.1)}}.cdek-input__control_user-event[data-v-ec8ba075]:focus-within{background:#fff;outline-color:#1ab248}@media (hover:hover){.cdek-input__control_user-event.cdek-input__control_error[data-v-ec8ba075]:hover{background:rgba(228,0,41,.1)}}.cdek-input__control_user-event.cdek-input__control_error[data-v-ec8ba075]:focus-within{background:#fff!important;outline-color:#e40029}.cdek-input__control_error[data-v-ec8ba075]{background:rgba(228,0,41,.05)}.cdek-input__control_disabled[data-v-ec8ba075]{background:rgba(51,85,104,.15)}.cdek-input__control_readonly[data-v-ec8ba075]{background:transparent;box-shadow:unset}.cdek-input__control_right-icon[data-v-ec8ba075]{padding-right:8px}.cdek-input__control_small[data-v-ec8ba075]{height:36px;padding-block:0}.cdek-input__input[data-v-ec8ba075]{align-self:flex-end;background:unset;border:unset;caret-color:#1ab248;color:#000;flex-grow:1;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;outline:unset}.cdek-input__input_error[data-v-ec8ba075]{caret-color:#e40029}.cdek-input__input[disabled][data-v-ec8ba075]{color:#000000a8}.cdek-input__input_readonly[data-v-ec8ba075],.cdek-input__input_readonly[disabled][data-v-ec8ba075]{color:#000}.cdek-input__input_no-label[data-v-ec8ba075]{align-self:center}.cdek-input__input[data-v-ec8ba075]:not(.cdek-input__input_no-label)::-moz-placeholder{color:transparent;-moz-transition:color .2s ease;transition:color .2s ease}.cdek-input__input[data-v-ec8ba075]:not(.cdek-input__input_no-label)::placeholder{color:transparent;transition:color .2s ease}.cdek-input__input[data-v-ec8ba075]:not(.cdek-input__input_no-label):focus::-moz-placeholder{color:#00000059}.cdek-input__input[data-v-ec8ba075]:not(.cdek-input__input_no-label):focus::placeholder{color:#00000059}.cdek-input__input_small[data-v-ec8ba075]{align-self:center;padding-block:6px;width:100%}.cdek-input__label[data-v-ec8ba075]{color:#0009;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;position:absolute;top:50%;transform:translateY(-50%);transition:all .3s ease}.cdek-input__control:focus-within:not(.cdek-input__control_disabled) .cdek-input__label[data-v-ec8ba075],.cdek-input__label_filled[data-v-ec8ba075]{font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;top:8px;transform:translateY(0)}.cdek-input__control:not(:focus-within) .cdek-input__label_error.cdek-input__label_filled[data-v-ec8ba075]{color:#e40029}.cdek-input__label_small[data-v-ec8ba075]{font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px}.cdek-input__control:focus-within:not(.cdek-input__control_disabled) .cdek-input__label_small[data-v-ec8ba075],.cdek-input__label_small.cdek-input__label_filled[data-v-ec8ba075]{font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;top:-22px;transform:translate(-17px)}.cdek-input__control:focus-within:not(.cdek-input__control_disabled) .cdek-input__label_small.cdek-input__label_readonly[data-v-ec8ba075],.cdek-input__label_small.cdek-input__label_filled.cdek-input__label_readonly[data-v-ec8ba075]{top:-11px;transform:translate(0)}.cdek-input__control:focus-within:not(.cdek-input__control_disabled) .cdek-input__label_small.cdek-input__label_error[data-v-ec8ba075],.cdek-input__label_small.cdek-input__label_filled.cdek-input__label_error[data-v-ec8ba075]{color:#e40029}.cdek-input__tip[data-v-ec8ba075]{color:#000000a8;font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;margin-top:4px;min-height:16px;padding-left:16px}.cdek-input__tip .tertiary[data-v-ec8ba075-s]{color:#627790}.cdek-input__tip .attention[data-v-ec8ba075-s]{color:#f47500}.cdek-input__tip .error[data-v-ec8ba075-s],.cdek-input__tip .error[data-v-ec8ba075]{color:#e40029}.cdek-input__tip .success[data-v-ec8ba075-s]{color:#17a000}.cdek-input__tip svg[data-v-ec8ba075-s],.cdek-input__tip svg[data-v-ec8ba075]{margin-right:4px;vertical-align:text-bottom}.cdek-input__clear[data-v-ec8ba075]{background:transparent;border:none;cursor:pointer;height:36px;opacity:0;outline:none;padding:6px;transition:all .2s ease;width:36px}@media (hover:hover){.cdek-input__control:hover .cdek-input__clear[data-v-ec8ba075]{opacity:1}}.cdek-input__control:focus-within .cdek-input__clear[data-v-ec8ba075]{opacity:1}.cdek-input__right-icon button[data-v-ec8ba075-s]{background:transparent;border:none;cursor:pointer;height:36px;outline:none;padding:6px;width:36px}.cdek-input__right-icon svg[data-v-ec8ba075-s] path{stroke:#1ab248}.cdek-input__right-icon_red svg[data-v-ec8ba075-s] path{stroke:#e40029}.cdek-input__right-icon_grey svg[data-v-ec8ba075-s] path{stroke:#00000059}.cdek-input__left-icon[data-v-ec8ba075]{line-height:0}.cdek-input__left-icon svg[data-v-ec8ba075-s]{margin-right:8px}.cdek-autocomplete[data-v-300ca6da]{position:relative}.cdek-autocomplete__not-found[data-v-300ca6da]{font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;padding:12px 16px}.cdek-autocomplete .cdek-dropdown-box[data-v-300ca6da]{margin-top:-14px}.cdek-autocomplete .v-enter-active[data-v-300ca6da],.cdek-autocomplete .v-leave-active[data-v-300ca6da]{transition:opacity .3s ease}.cdek-autocomplete .v-enter-from[data-v-300ca6da],.cdek-autocomplete .v-leave-to[data-v-300ca6da]{opacity:0}.cdek-badge[data-v-5bf39c98]{border-radius:4px;display:inline-block;font-family:Roboto,sans-serif;font-size:12px;font-weight:500;letter-spacing:.05em;line-height:14px;padding:4px 8px;text-transform:uppercase}.cdek-badge.dark[data-v-5bf39c98]{color:#fff}.cdek-badge.dark.positive[data-v-5bf39c98]{background:rgba(23,160,0,.7)}.cdek-badge.dark.process[data-v-5bf39c98]{background:#f47500}.cdek-badge.dark.negative[data-v-5bf39c98]{background:#e40029}.cdek-badge.dark.info[data-v-5bf39c98]{background:#847e9d}.cdek-badge.dark.deactive[data-v-5bf39c98]{background:rgba(0,0,0,.35)}.cdek-badge.dark.neutral[data-v-5bf39c98]{background:#627790}.cdek-badge.light.positive[data-v-5bf39c98]{background:rgba(23,160,0,.05);color:#17a000}.cdek-badge.light.process[data-v-5bf39c98]{background:rgba(244,117,0,.05);color:#f47500}.cdek-badge.light.negative[data-v-5bf39c98]{background:rgba(228,0,41,.05);color:#e40029}.cdek-badge.light.info[data-v-5bf39c98]{background:rgba(32,0,228,.05);color:#4b3c87}.cdek-badge.light.deactive[data-v-5bf39c98]{background:rgba(51,85,104,.05);color:#00000080}.cdek-badge.light.neutral[data-v-5bf39c98]{background:rgba(0,187,228,.05);color:#627790}.spinner[data-v-af9e8924]{--spinner-color:#1ab248;color:var(--spinner-color)}.spinner.white[data-v-af9e8924]{--spinner-color:#fff}.cdek-button[data-v-38cc074e]{align-items:center;border:unset;border-radius:10px;box-sizing:border-box;cursor:pointer;display:inline-flex;font-family:Roboto,sans-serif;font-size:14px;font-weight:500;gap:8px;height:48px;justify-content:center;letter-spacing:.03em;line-height:24px;padding:12px 24px;text-transform:uppercase;transition:all .2s ease-in-out;width:100%}.cdek-button[data-v-38cc074e]:hover:not([disabled]){background:#30cc5f;border-color:#30cc5f;color:#fff}.cdek-button[data-v-38cc074e]:hover:not([disabled]) .spinner{--spinner-color:#fff}.cdek-button[data-v-38cc074e]:active:not([disabled]){background:#127d32;border-color:#127d32;color:#fff}.cdek-button[data-v-38cc074e]:active:not([disabled]) .spinner{--spinner-color:#fff}.cdek-button.inline[data-v-38cc074e]{width:auto}.cdek-button.small[data-v-38cc074e]{height:36px}.cdek-button.primary[data-v-38cc074e]{background:#1ab248;color:#fff}.cdek-button.secondary[data-v-38cc074e]{background:rgba(26,178,72,.1);color:#1ab248}.cdek-button.outline[data-v-38cc074e]{background:transparent;border:1px solid #1ab248;color:#1ab248}.cdek-button.ghost[data-v-38cc074e]{background:transparent;color:#1ab248}.cdek-button.toaster[data-v-38cc074e]{background:hsla(0,0%,100%,.2);color:#fff}.cdek-button.toaster[data-v-38cc074e]:hover:not([disabled]){background:hsla(0,0%,100%,.4)}.cdek-button.toaster[data-v-38cc074e]:active:not([disabled]){background:hsla(0,0%,100%,.6)}.cdek-button.icon[data-v-38cc074e]{height:48px;padding:0;width:48px}.cdek-button.icon.small[data-v-38cc074e]{height:36px;width:36px}.cdek-button[disabled][data-v-38cc074e]{background:rgba(0,0,0,.35);border:none;color:#fff;pointer-events:none}.cdek-chip[data-v-1aacd3d3]{align-items:center;background:rgba(51,85,104,.05);border:none;border-radius:100px;display:inline-flex;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;outline-color:#0000;padding:12px;transition:all .3s ease}.cdek-chip[data-v-1aacd3d3]:not([disabled]){cursor:pointer}.cdek-chip[data-v-1aacd3d3]:not(.cdek-chip_disabled):focus-visible{outline:2px solid rgba(23,160,0,.4)}@media (hover:hover){.cdek-chip[data-v-1aacd3d3]:not(.cdek-chip_disabled,.cdek-chip_selected):hover{background:rgba(26,178,72,.1)}.cdek-chip:not(.cdek-chip_disabled,.cdek-chip_selected):hover span[data-v-1aacd3d3]{color:#127d32}.cdek-chip:not(.cdek-chip_disabled,.cdek-chip_selected):hover span[data-v-1aacd3d3] path{stroke:#127d32}}.cdek-chip__icon__wrapper[data-v-1aacd3d3]{align-items:center;display:flex;height:24px;width:24px}.cdek-chip__icon__wrapper[data-v-1aacd3d3] svg{height:100%;width:100%}.cdek-chip__icon__wrapper[data-v-1aacd3d3] svg path{stroke:#688b78;transition:all .3s ease}.cdek-chip__text[data-v-1aacd3d3]{padding:0 4px;transition:all .3s ease}.cdek-chip__amount[data-v-1aacd3d3]{color:#627790b3;font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;padding:0 8px;transition:all .3s ease}.cdek-chip_selected[data-v-1aacd3d3]{background:#1ab248}.cdek-chip_selected .cdek-chip__icon__wrapper[data-v-1aacd3d3] path{stroke:#fff}.cdek-chip_selected .cdek-chip__text[data-v-1aacd3d3]{color:#fff}.cdek-chip_selected .cdek-chip__amount[data-v-1aacd3d3]{color:#ffffffb3}.cdek-chip_disabled[data-v-1aacd3d3]{background:rgba(51,85,104,.15);color:#00000059}.cdek-chip_disabled[data-v-1aacd3d3] path{stroke:#00000059}.cdek-chip_small[data-v-1aacd3d3]{font-family:Roboto,sans-serif;font-size:14px;font-weight:400;line-height:20px;padding:8px 12px}.cdek-chip_small .cdek-chip__amount[data-v-1aacd3d3]{padding:0 4px}.cdek-chip_small .cdek-chip__icon__wrapper[data-v-1aacd3d3]{height:20px;width:20px}.cdek-chip_small .cdek-chip__icon__wrapper[data-v-1aacd3d3] path{transform:scale(.88)}.headline-1[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:40px;font-weight:300;line-height:50px}@media (max-width:576px){.headline-1[data-v-6ef0b4c3]{font-size:24px;line-height:32px}}.headline-2[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:32px;font-weight:500;line-height:40px}.headline-3[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:28px;font-weight:500;line-height:36px}.headline-4[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:24px;font-weight:500;line-height:32px}.headline-5[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:20px;font-weight:500;line-height:28px}.headline-6[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:16px;font-weight:500;line-height:20px}.headline-7[data-v-6ef0b4c3]{font-family:Roboto,sans-serif;font-size:14px;font-weight:500;letter-spacing:.02em;line-height:20px}.cdek-link[data-v-bacb5c53]{color:#1ab248;cursor:pointer;display:inline-block;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;text-decoration:underline}@media (max-width:576px){.cdek-link[data-v-bacb5c53]{font-family:Roboto,sans-serif;font-size:14px;font-weight:400;line-height:20px}}.cdek-link a[data-v-bacb5c53-s]{color:inherit}.cdek-link button[data-v-bacb5c53-s]{background:transparent;border:unset;color:inherit;cursor:inherit;font-family:inherit;font-size:inherit;font-weight:inherit;line-height:inherit;padding:unset;text-align:left;text-decoration:inherit}.cdek-modal__wrapper[data-v-df6e52d2]{align-items:center;background:rgba(0,0,0,.5);box-sizing:border-box;display:flex;height:100vh;justify-content:center;left:0;overflow-y:auto;padding:40px 40px 56px;position:fixed;top:0;width:100%;z-index:1000}@media (max-width:768px){.cdek-modal__wrapper[data-v-df6e52d2]{padding:20px}}.cdek-modal__box[data-v-df6e52d2]{background:#fff;border-radius:12px;box-shadow:0 20px 40px -5px #0003;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;margin:auto;max-width:100%;position:relative;width:var(--modal-width)}.cdek-modal__box__close-trigger[data-v-df6e52d2]{cursor:pointer;position:absolute;right:32px;top:32px}.v-enter-active[data-v-df6e52d2],.v-leave-active[data-v-df6e52d2]{transition:opacity .3s ease}.v-enter-from[data-v-df6e52d2],.v-leave-to[data-v-df6e52d2]{opacity:0}.cdek-confirm[data-v-8d0ed2be]{padding:20px 24px}.cdek-confirm__header[data-v-8d0ed2be]{align-items:center;border-bottom:1px solid rgba(0,0,0,.1);display:flex;flex-flow:row;margin-bottom:32px;padding-bottom:20px}@media (max-width:768px){.cdek-confirm__header[data-v-8d0ed2be]{align-items:flex-start;flex-flow:column}}.cdek-confirm__header__title[data-v-8d0ed2be]{align-items:center;display:flex;font-family:Roboto,sans-serif;font-size:28px;font-weight:500;line-height:36px}.cdek-confirm__header .cdek-badge[data-v-8d0ed2be]{margin-left:20px}.cdek-confirm__header__hint[data-v-8d0ed2be]{color:#627790;font-family:Roboto,sans-serif;font-size:14px;font-weight:400;letter-spacing:.02em;line-height:20px;margin-left:auto;margin-right:68px}@media (max-width:768px){.cdek-confirm__header__hint[data-v-8d0ed2be]{margin-left:0;margin-right:68px}}.cdek-confirm__footer[data-v-8d0ed2be]{border-top:1px solid rgba(0,0,0,.1);display:flex;flex-flow:row;margin-top:32px;padding-top:20px}@media (max-width:768px){.cdek-confirm__footer[data-v-8d0ed2be]{flex-flow:column;gap:16px}}.cdek-confirm__footer .cdek-button[data-v-8d0ed2be]{margin-right:16px}.cdek-select[data-v-6525f3bd]{position:relative}.cdek-select_small[data-v-6525f3bd]{padding-top:20px}.cdek-select__control[data-v-6525f3bd]{align-items:center;background:rgba(51,85,104,.05);border:none;border-radius:8px;box-shadow:inset 0 1px 2px #0021340d;box-sizing:border-box;cursor:pointer;display:flex;height:56px;outline:2px solid transparent;padding-block:6px;padding-inline:14px;position:relative;transition:background-color .3s ease,outline-color .3s ease;width:100%}@media (hover:hover){.cdek-select__control_user-event[data-v-6525f3bd]:hover{background:rgba(26,178,72,.1)}.cdek-select__control_user-event.cdek-select__control_error[data-v-6525f3bd]:not(.cdek-select__control_user-event.cdek-select__control_open):hover{background:rgba(228,0,41,.1)}}.cdek-select__control_user-event.cdek-select__control_open[data-v-6525f3bd]{background:#1ab248}.cdek-select__control_error[data-v-6525f3bd]{background:rgba(228,0,41,.05)}.cdek-select__control_disabled[data-v-6525f3bd]{background:rgba(51,85,104,.15);cursor:default}.cdek-select__control_readonly[data-v-6525f3bd]{background:transparent;box-shadow:unset;cursor:default}.cdek-select__control_small[data-v-6525f3bd]{height:36px;padding-right:0;padding-block:0}.cdek-select__value[data-v-6525f3bd]{align-self:flex-end;background:unset;border:unset;caret-color:#1ab248;color:#000;flex-grow:1;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;outline:unset;overflow:hidden;text-overflow:ellipsis;transition:color .3s ease;white-space:nowrap}.cdek-select__value_error[data-v-6525f3bd]{caret-color:#e40029}.cdek-select__value[disabled][data-v-6525f3bd]{color:#000000a8}.cdek-select__value_readonly[data-v-6525f3bd],.cdek-select__value_readonly[disabled][data-v-6525f3bd]{color:#000}.cdek-select__value_open[data-v-6525f3bd]{color:#fff}.cdek-select__value_no-label[data-v-6525f3bd]{align-self:center}.cdek-select__value_small[data-v-6525f3bd]{align-self:center;padding-block:6px}.cdek-select__label[data-v-6525f3bd]{color:#0009;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;position:absolute;top:50%;transform:translateY(-50%);transition:all .3s ease}.cdek-select__label_filled[data-v-6525f3bd]{font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;top:8px;transform:translateY(0)}.cdek-select__control:not(:focus-within) .cdek-select__label_error.cdek-select__label_filled[data-v-6525f3bd]:not(.cdek-select__label.cdek-select__label_open){color:#e40029}.cdek-select__label_open[data-v-6525f3bd]:not(.cdek-select__label_small){color:#fff}.cdek-select__label_small[data-v-6525f3bd]{font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;top:-22px;transform:translate(-17px)}.cdek-select__label_small.cdek-select__label_readonly[data-v-6525f3bd]{top:-11px;transform:translate(0)}.cdek-select__label_small.cdek-select__label_error[data-v-6525f3bd]{color:#e40029}.cdek-select__tip[data-v-6525f3bd]{color:#000000a8;font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px;margin-top:4px;min-height:16px;padding-left:16px}.cdek-select__tip .tertiary[data-v-6525f3bd-s]{color:#627790}.cdek-select__tip .attention[data-v-6525f3bd-s]{color:#f47500}.cdek-select__tip .error[data-v-6525f3bd-s],.cdek-select__tip .error[data-v-6525f3bd]{color:#e40029}.cdek-select__tip .success[data-v-6525f3bd-s]{color:#17a000}.cdek-select__tip svg[data-v-6525f3bd-s],.cdek-select__tip svg[data-v-6525f3bd]{margin-right:4px;vertical-align:text-bottom}.cdek-select__arrow[data-v-6525f3bd]{stroke:#1ab248;margin-right:6px;transform:rotate(180deg);transition:transform .2s ease}.cdek-select__arrow_open[data-v-6525f3bd]{stroke:#fff;transform:rotate(0)}.cdek-select__arrow_red[data-v-6525f3bd]:not(.cdek-select__arrow_open){stroke:#e40029}.cdek-select__arrow_grey[data-v-6525f3bd]{stroke:#00000059}.cdek-switch[data-v-c26061ac]{align-items:center;display:inline-flex}.cdek-switch[data-v-c26061ac] .cdek-switch__bg{background:rgba(98,119,144,.4);border:none;border-radius:36.5px;cursor:pointer;height:30px;outline:none;position:relative;transition:background-color .1s ease;width:51px}.cdek-switch[data-v-c26061ac] .cdek-switch__bg[disabled]{background:rgba(0,0,0,.2);pointer-events:none}.cdek-switch[data-v-c26061ac] .cdek-switch__bg_enabled{background:#1ab248}@media (hover:hover){.cdek-switch[data-v-c26061ac] .cdek-switch__bg_enabled:hover{background:#30cc5f}}.cdek-switch[data-v-c26061ac] .cdek-switch__bg_enabled[disabled]{background:rgba(0,0,0,.35)}.cdek-switch[data-v-c26061ac] .cdek-switch__bg_small{height:24px;width:40px}.cdek-switch__circle[data-v-c26061ac]{--size:26px;background:#fff;border-radius:100px;box-shadow:0 3px 8px #0000001a,0 1px 1px #00000003,0 3px 1px #00000008;display:inline-block;height:var(--size);left:2px;position:absolute;top:2px;transition:left .1s ease;width:var(--size)}.cdek-switch__circle_enabled[data-v-c26061ac]{left:calc(100% - var(--size) - 2px)}.cdek-switch__circle_disabled[data-v-c26061ac]{background:hsla(0,0%,100%,.8);box-shadow:none}.cdek-switch__circle_small[data-v-c26061ac]{--size:20px}.cdek-switch[data-v-c26061ac] .cdek-switch__label{cursor:pointer;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;padding-left:16px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.cdek-switch[data-v-c26061ac] .cdek-switch__label_small{font-family:Roboto,sans-serif;font-size:14px;font-weight:400;line-height:20px}.cdek-switch__tip[data-v-c26061ac]{color:#000000a8;display:block;font-family:Roboto,sans-serif;font-size:12px;font-weight:400;line-height:16px}p[data-v-39a3552f]{margin:0}.toast[data-v-39a3552f]{-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px);border-radius:12px;box-sizing:border-box;display:flex;flex-direction:column;gap:12px;max-width:328px;padding:10px 10px 10px 12px;width:100%}.toast.info[data-v-39a3552f]{background:rgba(0,0,0,.66);box-shadow:0 8px 12px -5px #6277904d}.toast.success[data-v-39a3552f]{background:rgba(23,160,0,.7);box-shadow:0 8px 12px -5px #17a0004d}.toast.error[data-v-39a3552f]{background:rgba(228,0,41,.7);box-shadow:0 8px 12px -5px #e400294d}.toast__main[data-v-39a3552f]{display:flex;padding-right:34px;width:100%}.toast__icon[data-v-39a3552f]{height:24px;margin-right:4px;width:24px}.toast__content[data-v-39a3552f]{font-family:Roboto,sans-serif;font-size:14px;font-weight:400;line-height:20px;margin-left:4px;margin-top:2px;width:240px}.toast__title[data-v-39a3552f]{color:#fff}.toast__text[data-v-39a3552f]{color:#fffc;margin-top:4px}.toast__close[data-v-39a3552f]{background:unset;border:unset;cursor:pointer;height:24px;opacity:.8;padding:0;position:absolute;right:10px;transition:all .2s ease-in-out;width:24px}.toast__close[data-v-39a3552f]:hover{opacity:1}.cdek-widget[data-v-eb6c5ff5]{background:#fff;border-radius:12px;box-shadow:0 4px 12px #0000000a;box-sizing:border-box;font-family:Roboto,sans-serif;font-size:16px;font-weight:400;line-height:24px;padding:32px;position:relative}@media (max-width:576px){.cdek-widget[data-v-eb6c5ff5]{font-family:Roboto,sans-serif;font-size:14px;font-weight:400;line-height:20px;padding:16px}}.cdek-widget_without-paddings[data-v-eb6c5ff5]{padding:0}@media (max-width:576px){.cdek-widget_without-paddings[data-v-eb6c5ff5]{padding:0}}.cdek-widget_loading[data-v-eb6c5ff5]{pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.cdek-widget_loading[data-v-eb6c5ff5]:before{background:hsla(0,0%,100%,.8);border-radius:12px;bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:1}.cdek-widget_disabled[data-v-eb6c5ff5]{opacity:.6;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.cdek-widget__title[data-v-eb6c5ff5]{margin-bottom:24px}@media (max-width:576px){.cdek-widget__title[data-v-eb6c5ff5]{font-size:18px;line-height:26px}}.cdek-widget__spinner[data-v-eb6c5ff5]{left:50%;position:absolute;top:50%;transform:translate(-50%) translateY(-50%);z-index:1}.Vue-Toastification__container{box-sizing:border-box;color:#fff;display:flex;flex-direction:column;min-height:100%;padding:4px;pointer-events:none;position:fixed;width:600px;z-index:9999}@media only screen and (min-width:600px){.Vue-Toastification__container.top-center,.Vue-Toastification__container.top-left,.Vue-Toastification__container.top-right{top:1em}.Vue-Toastification__container.bottom-center,.Vue-Toastification__container.bottom-left,.Vue-Toastification__container.bottom-right{bottom:1em;flex-direction:column-reverse}.Vue-Toastification__container.bottom-left,.Vue-Toastification__container.top-left{left:1em}.Vue-Toastification__container.bottom-left .Vue-Toastification__toast,.Vue-Toastification__container.top-left .Vue-Toastification__toast{margin-right:auto}@supports not (-moz-appearance:none){.Vue-Toastification__container.bottom-left .Vue-Toastification__toast--rtl,.Vue-Toastification__container.top-left .Vue-Toastification__toast--rtl{margin-left:auto;margin-right:unset}}.Vue-Toastification__container.bottom-right,.Vue-Toastification__container.top-right{right:1em}.Vue-Toastification__container.bottom-right .Vue-Toastification__toast,.Vue-Toastification__container.top-right .Vue-Toastification__toast{margin-left:auto}@supports not (-moz-appearance:none){.Vue-Toastification__container.bottom-right .Vue-Toastification__toast--rtl,.Vue-Toastification__container.top-right .Vue-Toastification__toast--rtl{margin-left:unset;margin-right:auto}}.Vue-Toastification__container.bottom-center,.Vue-Toastification__container.top-center{left:50%;margin-left:-300px}.Vue-Toastification__container.bottom-center .Vue-Toastification__toast,.Vue-Toastification__container.top-center .Vue-Toastification__toast{margin-left:auto;margin-right:auto}}@media only screen and (max-width:600px){.Vue-Toastification__container{left:0;margin:0;padding:0;width:100vw}.Vue-Toastification__container .Vue-Toastification__toast{width:100%}.Vue-Toastification__container.top-center,.Vue-Toastification__container.top-left,.Vue-Toastification__container.top-right{top:0}.Vue-Toastification__container.bottom-center,.Vue-Toastification__container.bottom-left,.Vue-Toastification__container.bottom-right{bottom:0;flex-direction:column-reverse}}.Vue-Toastification__toast{border-radius:8px;box-shadow:0 1px 10px #0000001a,0 2px 15px #0000000d;box-sizing:border-box;direction:ltr;display:inline-flex;font-family:Lato,Helvetica,Roboto,Arial,sans-serif;justify-content:space-between;margin-bottom:1rem;max-height:800px;max-width:600px;min-height:64px;min-width:326px;overflow:hidden;padding:22px 24px;pointer-events:auto;position:relative;transform:translateZ(0)}.Vue-Toastification__toast--rtl{direction:rtl}.Vue-Toastification__toast--default{background-color:#1976d2;color:#fff}.Vue-Toastification__toast--info{background-color:#2196f3;color:#fff}.Vue-Toastification__toast--success{background-color:#4caf50;color:#fff}.Vue-Toastification__toast--error{background-color:#ff5252;color:#fff}.Vue-Toastification__toast--warning{background-color:#ffc107;color:#fff}@media only screen and (max-width:600px){.Vue-Toastification__toast{border-radius:0;margin-bottom:.5rem}}.Vue-Toastification__toast-body{flex:1;font-size:16px;line-height:24px;white-space:pre-wrap;word-break:break-word}.Vue-Toastification__toast-component-body{flex:1}.Vue-Toastification__toast.disable-transition{animation:none!important}.Vue-Toastification__close-button{align-items:center;background:transparent;border:none;color:#fff;cursor:pointer;font-size:24px;font-weight:700;line-height:24px;opacity:.3;outline:none;padding:0 0 0 10px;transition:.3s ease;transition:visibility 0s,opacity .2s linear}.Vue-Toastification__close-button:focus,.Vue-Toastification__close-button:hover{opacity:1}.Vue-Toastification__toast:not(:hover) .Vue-Toastification__close-button.show-on-hover{opacity:0}.Vue-Toastification__toast--rtl .Vue-Toastification__close-button{padding-left:unset;padding-right:10px}@keyframes scale-x-frames{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.Vue-Toastification__progress-bar{animation:scale-x-frames linear 1 forwards;background-color:#ffffffb3;bottom:0;height:5px;left:0;position:absolute;transform-origin:left;width:100%;z-index:10000}.Vue-Toastification__toast--rtl .Vue-Toastification__progress-bar{left:unset;right:0;transform-origin:right}.Vue-Toastification__icon{align-items:center;background:transparent;border:none;height:100%;margin:auto 18px auto 0;outline:none;padding:0;transition:.3s ease;width:20px}.Vue-Toastification__toast--rtl .Vue-Toastification__icon{margin:auto 0 auto 18px}@keyframes bounceInRight{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(3000px,0,0)}60%{opacity:1;transform:translate3d(-25px,0,0)}75%{transform:translate3d(10px,0,0)}90%{transform:translate3d(-5px,0,0)}to{transform:none}}@keyframes bounceOutRight{40%{opacity:1;transform:translate3d(-20px,0,0)}to{opacity:0;transform:translate3d(1000px,0,0)}}@keyframes bounceInLeft{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(-3000px,0,0)}60%{opacity:1;transform:translate3d(25px,0,0)}75%{transform:translate3d(-10px,0,0)}90%{transform:translate3d(5px,0,0)}to{transform:none}}@keyframes bounceOutLeft{20%{opacity:1;transform:translate3d(20px,0,0)}to{opacity:0;transform:translate3d(-2000px,0,0)}}@keyframes bounceInUp{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,3000px,0)}60%{opacity:1;transform:translate3d(0,-20px,0)}75%{transform:translate3d(0,10px,0)}90%{transform:translate3d(0,-5px,0)}to{transform:translateZ(0)}}@keyframes bounceOutUp{20%{transform:translate3d(0,-10px,0)}40%,45%{opacity:1;transform:translate3d(0,20px,0)}to{opacity:0;transform:translate3d(0,-2000px,0)}}@keyframes bounceInDown{0%,60%,75%,90%,to{animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{opacity:0;transform:translate3d(0,-3000px,0)}60%{opacity:1;transform:translate3d(0,25px,0)}75%{transform:translate3d(0,-10px,0)}90%{transform:translate3d(0,5px,0)}to{transform:none}}@keyframes bounceOutDown{20%{transform:translate3d(0,10px,0)}40%,45%{opacity:1;transform:translate3d(0,-20px,0)}to{opacity:0;transform:translate3d(0,2000px,0)}}.Vue-Toastification__bounce-enter-active.bottom-left,.Vue-Toastification__bounce-enter-active.top-left{animation-name:bounceInLeft}.Vue-Toastification__bounce-enter-active.bottom-right,.Vue-Toastification__bounce-enter-active.top-right{animation-name:bounceInRight}.Vue-Toastification__bounce-enter-active.top-center{animation-name:bounceInDown}.Vue-Toastification__bounce-enter-active.bottom-center{animation-name:bounceInUp}.Vue-Toastification__bounce-leave-active:not(.disable-transition).bottom-left,.Vue-Toastification__bounce-leave-active:not(.disable-transition).top-left{animation-name:bounceOutLeft}.Vue-Toastification__bounce-leave-active:not(.disable-transition).bottom-right,.Vue-Toastification__bounce-leave-active:not(.disable-transition).top-right{animation-name:bounceOutRight}.Vue-Toastification__bounce-leave-active:not(.disable-transition).top-center{animation-name:bounceOutUp}.Vue-Toastification__bounce-leave-active:not(.disable-transition).bottom-center{animation-name:bounceOutDown}.Vue-Toastification__bounce-enter-active,.Vue-Toastification__bounce-leave-active{animation-duration:.75s;animation-fill-mode:both}.Vue-Toastification__bounce-move{transition-duration:.4s;transition-property:all;transition-timing-function:ease-in-out}@keyframes fadeOutTop{0%{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(-50px)}}@keyframes fadeOutLeft{0%{opacity:1;transform:translate(0)}to{opacity:0;transform:translate(-50px)}}@keyframes fadeOutBottom{0%{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(50px)}}@keyframes fadeOutRight{0%{opacity:1;transform:translate(0)}to{opacity:0;transform:translate(50px)}}@keyframes fadeInLeft{0%{opacity:0;transform:translate(-50px)}to{opacity:1;transform:translate(0)}}@keyframes fadeInRight{0%{opacity:0;transform:translate(50px)}to{opacity:1;transform:translate(0)}}@keyframes fadeInTop{0%{opacity:0;transform:translateY(-50px)}to{opacity:1;transform:translateY(0)}}@keyframes fadeInBottom{0%{opacity:0;transform:translateY(50px)}to{opacity:1;transform:translateY(0)}}.Vue-Toastification__fade-enter-active.bottom-left,.Vue-Toastification__fade-enter-active.top-left{animation-name:fadeInLeft}.Vue-Toastification__fade-enter-active.bottom-right,.Vue-Toastification__fade-enter-active.top-right{animation-name:fadeInRight}.Vue-Toastification__fade-enter-active.top-center{animation-name:fadeInTop}.Vue-Toastification__fade-enter-active.bottom-center{animation-name:fadeInBottom}.Vue-Toastification__fade-leave-active:not(.disable-transition).bottom-left,.Vue-Toastification__fade-leave-active:not(.disable-transition).top-left{animation-name:fadeOutLeft}.Vue-Toastification__fade-leave-active:not(.disable-transition).bottom-right,.Vue-Toastification__fade-leave-active:not(.disable-transition).top-right{animation-name:fadeOutRight}.Vue-Toastification__fade-leave-active:not(.disable-transition).top-center{animation-name:fadeOutTop}.Vue-Toastification__fade-leave-active:not(.disable-transition).bottom-center{animation-name:fadeOutBottom}.Vue-Toastification__fade-enter-active,.Vue-Toastification__fade-leave-active{animation-duration:.75s;animation-fill-mode:both}.Vue-Toastification__fade-move{transition-duration:.4s;transition-property:all;transition-timing-function:ease-in-out}@keyframes slideInBlurredLeft{0%{filter:blur(40px);opacity:0;transform:translate(-1000px) scaleX(2.5) scaleY(.2);transform-origin:100% 50%}to{filter:blur(0);opacity:1;transform:translate(0) scaleY(1) scaleX(1);transform-origin:50% 50%}}@keyframes slideInBlurredTop{0%{filter:blur(240px);opacity:0;transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform-origin:50% 0}to{filter:blur(0);opacity:1;transform:translateY(0) scaleY(1) scaleX(1);transform-origin:50% 50%}}@keyframes slideInBlurredRight{0%{filter:blur(40px);opacity:0;transform:translate(1000px) scaleX(2.5) scaleY(.2);transform-origin:0 50%}to{filter:blur(0);opacity:1;transform:translate(0) scaleY(1) scaleX(1);transform-origin:50% 50%}}@keyframes slideInBlurredBottom{0%{filter:blur(240px);opacity:0;transform:translateY(1000px) scaleY(2.5) scaleX(.2);transform-origin:50% 100%}to{filter:blur(0);opacity:1;transform:translateY(0) scaleY(1) scaleX(1);transform-origin:50% 50%}}@keyframes slideOutBlurredTop{0%{filter:blur(0);opacity:1;transform:translateY(0) scaleY(1) scaleX(1);transform-origin:50% 0}to{filter:blur(240px);opacity:0;transform:translateY(-1000px) scaleY(2) scaleX(.2);transform-origin:50% 0}}@keyframes slideOutBlurredBottom{0%{filter:blur(0);opacity:1;transform:translateY(0) scaleY(1) scaleX(1);transform-origin:50% 50%}to{filter:blur(240px);opacity:0;transform:translateY(1000px) scaleY(2) scaleX(.2);transform-origin:50% 100%}}@keyframes slideOutBlurredLeft{0%{filter:blur(0);opacity:1;transform:translate(0) scaleY(1) scaleX(1);transform-origin:50% 50%}to{filter:blur(40px);opacity:0;transform:translate(-1000px) scaleX(2) scaleY(.2);transform-origin:100% 50%}}@keyframes slideOutBlurredRight{0%{filter:blur(0);opacity:1;transform:translate(0) scaleY(1) scaleX(1);transform-origin:50% 50%}to{filter:blur(40px);opacity:0;transform:translate(1000px) scaleX(2) scaleY(.2);transform-origin:0 50%}}.Vue-Toastification__slideBlurred-enter-active.bottom-left,.Vue-Toastification__slideBlurred-enter-active.top-left{animation-name:slideInBlurredLeft}.Vue-Toastification__slideBlurred-enter-active.bottom-right,.Vue-Toastification__slideBlurred-enter-active.top-right{animation-name:slideInBlurredRight}.Vue-Toastification__slideBlurred-enter-active.top-center{animation-name:slideInBlurredTop}.Vue-Toastification__slideBlurred-enter-active.bottom-center{animation-name:slideInBlurredBottom}.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).bottom-left,.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).top-left{animation-name:slideOutBlurredLeft}.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).bottom-right,.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).top-right{animation-name:slideOutBlurredRight}.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).top-center{animation-name:slideOutBlurredTop}.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).bottom-center{animation-name:slideOutBlurredBottom}.Vue-Toastification__slideBlurred-enter-active,.Vue-Toastification__slideBlurred-leave-active{animation-duration:.75s;animation-fill-mode:both}.Vue-Toastification__slideBlurred-move{transition-duration:.4s;transition-property:all;transition-timing-function:ease-in-out}.Vue-Toastification__toast{background-color:transparent!important;border-radius:0;box-shadow:none;color:inherit;display:inline-block;font-family:inherit;max-height:auto;max-width:auto;min-height:auto;min-width:auto;padding:0}.Vue-Toastification__container.bottom-center{padding-left:16px;padding-right:16px}.ps{-ms-overflow-style:none;overflow:hidden!important;overflow-anchor:none;touch-action:auto;-ms-touch-action:auto}.ps__rail-x{bottom:0;height:15px}.ps__rail-x,.ps__rail-y{display:none;opacity:0;position:absolute;transition:background-color .2s linear,opacity .2s linear;-webkit-transition:background-color .2s linear,opacity .2s linear}.ps__rail-y{right:0;width:15px}.ps--active-x>.ps__rail-x,.ps--active-y>.ps__rail-y{background-color:transparent;display:block}.ps--focus>.ps__rail-x,.ps--focus>.ps__rail-y,.ps--scrolling-x>.ps__rail-x,.ps--scrolling-y>.ps__rail-y,.ps:hover>.ps__rail-x,.ps:hover>.ps__rail-y{opacity:.6}.ps .ps__rail-x.ps--clicking,.ps .ps__rail-x:focus,.ps .ps__rail-x:hover,.ps .ps__rail-y.ps--clicking,.ps .ps__rail-y:focus,.ps .ps__rail-y:hover{background-color:#eee;opacity:.9}.ps__thumb-x{bottom:2px;height:6px;transition:background-color .2s linear,height .2s ease-in-out;-webkit-transition:background-color .2s linear,height .2s ease-in-out}.ps__thumb-x,.ps__thumb-y{background-color:#aaa;border-radius:6px;position:absolute}.ps__thumb-y{right:2px;transition:background-color .2s linear,width .2s ease-in-out;-webkit-transition:background-color .2s linear,width .2s ease-in-out;width:6px}.ps__rail-x.ps--clicking .ps__thumb-x,.ps__rail-x:focus>.ps__thumb-x,.ps__rail-x:hover>.ps__thumb-x{background-color:#999;height:11px}.ps__rail-y.ps--clicking .ps__thumb-y,.ps__rail-y:focus>.ps__thumb-y,.ps__rail-y:hover>.ps__thumb-y{background-color:#999;width:11px}@supports (-ms-overflow-style:none){.ps{overflow:auto!important}}@media (-ms-high-contrast:none),screen and (-ms-high-contrast:active){.ps{overflow:auto!important}}.cdek-segmented[data-v-8747f95e]{border-radius:4px;display:grid;grid-auto-columns:1fr;grid-auto-flow:column}.cdek-segmented_radio[data-v-8747f95e]{display:none}.cdek-segmented_button[data-v-8747f95e]{border-radius:4px;color:#0009;cursor:pointer;font-size:.75rem;line-height:1rem;margin-right:8px;padding:4px 8px;position:relative}.cdek-segmented_button_checked[data-v-8747f95e]{background:#fff;box-shadow:0 3px 1px #00000008,0 1px 1px #00000003,0 3px 8px #0000001a;color:#127d32}.cdek-segmented_button_label[data-v-8747f95e]{align-items:center;display:flex;gap:2px;justify-content:center;text-align:center}.cdek-segmented_button_label label[data-v-8747f95e]{margin:0!important}.cdek-segmented_button[data-v-8747f95e]:last-of-type{margin-right:0}.cdek-segmented_button[data-v-8747f95e]:not(:last-of-type):after{background:rgba(51,85,104,.15);content:"";height:100%;position:absolute;right:-5px;top:0;width:1px}.cdek-segmented_button[data-v-8747f95e]:not(.cdek-segmented_button_checked):hover{background:rgba(26,178,72,.1)}.cdek-checkbox-item[data-v-7bc5a995]{align-items:center;display:flex;gap:5px}.cdek-checkbox-item label[data-v-7bc5a995]{margin:0}.cdek-checkbox-item input[data-v-7bc5a995]{display:none}.cdek-checkbox-item span[data-v-7bc5a995]{background:rgba(26,178,72,.05);border:1px solid #1ab248;border-radius:4px;display:inline-block;height:15px;width:15px}.cdek-checkbox-item span svg[data-v-7bc5a995]{color:#fff;display:none;margin:1px}.cdek-checkbox-item.disabled[data-v-7bc5a995]{color:#00000080}.cdek-checkbox-item.disabled span[data-v-7bc5a995]{background:rgba(51,85,104,.05);border-color:#00000059;cursor:default}.cdek-checkbox-item[data-v-7bc5a995]:not(.disabled):hover{color:#127d32}.cdek-checkbox-item:not(.disabled):hover span[data-v-7bc5a995]{background:rgba(26,178,72,.2)}.cdek-checkbox-item_checked span[data-v-7bc5a995]{background:#1ab248}.cdek-checkbox-item_checked span svg[data-v-7bc5a995]{display:block}.cdek-checkbox-item_checked.disabled span[data-v-7bc5a995]{background:rgba(0,0,0,.35);border:1px solid transparent}.cdek-checkbox-item_checked:not(.disabled):hover span[data-v-7bc5a995]{background:rgba(26,178,72,.7);border:1px solid transparent}.cdek-radio input[data-v-bf2fa578]{display:none}.cdek-radio_label[data-v-bf2fa578]{align-items:center;display:flex;gap:5px}.cdek-radio_label label[data-v-bf2fa578]{margin:0}.cdek-radio_label span[data-v-bf2fa578]{background:rgba(26,178,72,.05);border:1px solid #1ab248;border-radius:999px;display:inline-block;height:15px;width:15px}.cdek-radio_label[data-v-bf2fa578]:not(.disabled):hover{color:#127d32}.cdek-radio_label:not(.disabled):hover span[data-v-bf2fa578]{background:rgba(26,178,72,.2)}.cdek-radio_label_checked span[data-v-bf2fa578]{background:#fff;border-width:4px}.cdek-radio_label_checked:not(.disabled):hover span[data-v-bf2fa578]{background:#fff;border-color:#1ab248b3}.cdek-radio_label.disabled[data-v-bf2fa578]{color:#00000080}.cdek-radio_label.disabled span[data-v-bf2fa578]{background:rgba(51,85,104,.05);border-color:#00000059;cursor:default}/*! tailwindcss v3.3.3 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-feature-settings:normal;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.twc-fixed{position:fixed!important}.twc-absolute{position:absolute!important}.twc-relative{position:relative!important}.-twc-bottom-2{bottom:-.5rem!important}.-twc-right-12{right:-3rem!important}.twc-bottom-0{bottom:0!important}.twc-bottom-2{bottom:.5rem!important}.twc-left-0{left:0!important}.twc-left-10{left:2.5rem!important}.twc-left-2{left:.5rem!important}.twc-right-0{right:0!important}.twc-right-2{right:.5rem!important}.twc-top-0{top:0!important}.twc-top-12{top:3rem!important}.twc-top-2{top:.5rem!important}.twc-top-\\[2px\\]{top:2px!important}.twc-z-10{z-index:10!important}.twc-z-20{z-index:20!important}.twc-z-50{z-index:50!important}.twc-z-\\[99999\\]{z-index:99999!important}.twc-z-\\[9999\\]{z-index:9999!important}.twc-mx-6{margin-left:1.5rem!important;margin-right:1.5rem!important}.twc-mb-1{margin-bottom:.25rem!important}.twc-mb-2{margin-bottom:.5rem!important}.twc-mb-3{margin-bottom:.75rem!important}.twc-ml-7{margin-left:1.75rem!important}.twc-mt-1{margin-top:.25rem!important}.twc-mt-2{margin-top:.5rem!important}.twc-flex{display:flex!important}.twc-grid{display:grid!important}.twc-hidden{display:none!important}.twc-h-96{height:24rem!important}.twc-h-\\[600px\\]{height:600px!important}.twc-h-full{height:100%!important}.twc-max-h-60{max-height:15rem!important}.twc-max-h-72{max-height:18rem!important}.twc-min-h-min{min-height:-moz-min-content!important;min-height:min-content!important}.twc-w-24{width:6rem!important}.twc-w-36{width:9rem!important}.twc-w-44{width:11rem!important}.twc-w-52{width:13rem!important}.twc-w-64{width:16rem!important}.twc-w-80{width:20rem!important}.twc-w-\\[800px\\]{width:800px!important}.twc-w-full{width:100%!important}@keyframes twc-spin{to{transform:rotate(1turn)}}.twc-animate-spin{animation:twc-spin 1s linear infinite!important}.twc-cursor-pointer{cursor:pointer!important}.twc-items-center{align-items:center!important}.twc-justify-center{justify-content:center!important}.twc-justify-items-center{justify-items:center!important}.twc-gap-1{gap:.25rem!important}.twc-gap-2{gap:.5rem!important}.twc-overflow-hidden{overflow:hidden!important}.twc-whitespace-normal{white-space:normal!important}.twc-break-words{overflow-wrap:break-word!important}.twc-rounded-full{border-radius:9999px!important}.twc-rounded-lg{border-radius:.5rem!important}.twc-rounded-md{border-radius:.375rem!important}.twc-border-0{border-width:0!important}.twc-border-2{border-width:2px!important}.twc-border-b-2{border-bottom-width:2px!important}.twc-border-t-2{border-top-width:2px!important}.twc-border-green-600{--tw-border-opacity:1!important;border-color:rgb(22 163 74/var(--tw-border-opacity))!important}.twc-border-stone-200{--tw-border-opacity:1!important;border-color:rgb(231 229 228/var(--tw-border-opacity))!important}.twc-bg-black\\/50{background-color:#00000080!important}.twc-bg-gray-100{--tw-bg-opacity:1!important;background-color:rgb(243 244 246/var(--tw-bg-opacity))!important}.twc-bg-white{--tw-bg-opacity:1!important;background-color:rgb(255 255 255/var(--tw-bg-opacity))!important}.twc-stroke-stone-700{stroke:#44403c!important}.twc-p-2{padding:.5rem!important}.twc-p-5{padding:1.25rem!important}.twc-px-2{padding-left:.5rem!important;padding-right:.5rem!important}.twc-px-3{padding-left:.75rem!important;padding-right:.75rem!important}.twc-py-1{padding-bottom:.25rem!important;padding-top:.25rem!important}.twc-py-2{padding-bottom:.5rem!important;padding-top:.5rem!important}.twc-py-3{padding-bottom:.75rem!important;padding-top:.75rem!important}.twc-pb-1{padding-bottom:.25rem!important}.twc-text-center{text-align:center!important}.twc-text-lg{font-size:1.125rem!important;line-height:1.75rem!important}.twc-text-sm{font-size:.875rem!important;line-height:1.25rem!important}.twc-text-xl{font-size:1.25rem!important;line-height:1.75rem!important}.twc-text-xs{font-size:.75rem!important;line-height:1rem!important}.twc-font-bold{font-weight:700!important}.twc-leading-6{line-height:1.5rem!important}.twc-text-red-600{--tw-text-opacity:1!important;color:rgb(220 38 38/var(--tw-text-opacity))!important}.twc-text-stone-500{--tw-text-opacity:1!important;color:rgb(120 113 108/var(--tw-text-opacity))!important}.twc-text-stone-700{--tw-text-opacity:1!important;color:rgb(68 64 60/var(--tw-text-opacity))!important}.twc-underline{text-decoration-line:underline!important}.twc-shadow-md{--tw-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -2px rgba(0,0,0,.1)!important;--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color),0 2px 4px -2px var(--tw-shadow-color)!important}.twc-shadow-md,.twc-shadow-none{box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)!important}.twc-shadow-none{--tw-shadow:0 0 #0000!important;--tw-shadow-colored:0 0 #0000!important}.twc-outline-none{outline:2px solid transparent!important;outline-offset:2px!important}.twc-drop-shadow-md{--tw-drop-shadow:drop-shadow(0 4px 3px rgba(0,0,0,.07)) drop-shadow(0 2px 2px rgba(0,0,0,.06))!important;filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)!important}.first\\:twc-mt-0:first-child{margin-top:0!important}.first\\:twc-border-t-0:first-child{border-top-width:0!important}')),document.head.appendChild(t)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}}();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove$1 = (arr, el2) => {
  const i = arr.indexOf(el2);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$4 = Object.prototype.hasOwnProperty;
const hasOwn$1 = (val, key) => hasOwnProperty$4.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString$1(val) === "[object Map]";
const isSet = (val) => toTypeString$1(val) === "[object Set]";
const isFunction$2 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$4(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString$2 = Object.prototype.toString;
const toTypeString$1 = (value) => objectToString$2.call(value);
const toRawType = (value) => {
  return toTypeString$1(value).slice(8, -1);
};
const isPlainObject$3 = (val) => toTypeString$1(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize$1 = cacheStringFunction(
  (str) => str.charAt(0).toUpperCase() + str.slice(1)
);
const toHandlerKey = cacheStringFunction(
  (str) => str ? `on${capitalize$1(str)}` : ``
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber$1 = (val) => {
  const n2 = isString$2(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis$1;
const getGlobalThis$1 = () => {
  return _globalThis$1 || (_globalThis$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value)) {
    return value;
  } else if (isObject$4(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString$1 = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$2(val) || isObject$4(val) && (val.toString === objectToString$2 || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$4(val) && !isArray$2(val) && !isPlainObject$3(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l2;
      for (i = 0, l2 = this.effects.length; i < l2; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l2 = this.scopes.length; i < l2; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler2 = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler2;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$2(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object2, key) {
  var _a;
  return (_a = targetMap.get(object2)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$3(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn$1(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$3;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn$1(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn$1(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$1(target) {
  track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys: ownKeys$1
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1(
  {},
  mutableHandlers,
  {
    get: shallowGet,
    set: shallowSet
  }
);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn$1(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object2) {
  const ret = isArray$2(object2) ? new Array(object2.length) : {};
  for (const key in object2) {
    ret[key] = propertyToRef(object2, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$2(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$4(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(
    source,
    key,
    defaultValue
  );
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn$1(msg, ...args) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$2(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id2) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb2) {
  if (!isArray$2(cb2)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb2,
      cb2.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb2);
    }
  } else {
    pendingPostFlushCbs.push(...cb2);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb2 = queue[i];
    if (cb2 && cb2.pre) {
      queue.splice(i, 1);
      i--;
      cb2();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn$1(options, key[0].toLowerCase() + key.slice(1)) || hasOwn$1(options, hyphenate(key)) || hasOwn$1(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          props,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode$1(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$2(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber$1(vnode.props.timeout) : void 0;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    document.createElement("div"),
    null,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
    /* hydrating */
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction$2(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$2(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el2 = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el2;
    updateHOCHostEl(parentComponent, el2);
  }
}
function isVNodeSuspensible(vnode) {
  var _a;
  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb2, options) {
  return doWatch(source, cb2, options);
}
function doWatch(source, cb2, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$2(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb2) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb2 && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb2) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb2, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb2) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some(
        (v2, i) => hasChanged(v2, oldValue[i])
      ) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb2, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb2;
  let scheduler2;
  if (flush === "sync") {
    scheduler2 = job;
  } else if (flush === "post") {
    scheduler2 = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler2 = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler2);
  if (cb2) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect.run.bind(effect),
      instance && instance.suspense
    );
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove$1(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb2;
  if (isFunction$2(value)) {
    cb2 = value;
  } else {
    cb2 = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb2.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$4(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen);
    });
  } else if (isPlainObject$3(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2._leaveCb) {
        el2._leaveCb(
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el2]);
        } else {
          callHook2(afterHook, [el2]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el2._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el2, done]);
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2._enterCb) {
        el2._enterCb(
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el2]);
      let called = false;
      const done = el2._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el2]);
        } else {
          callHook2(onAfterLeave, [el2]);
        }
        el2._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el2, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options, extraOptions) {
  return isFunction$2(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend$1({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove$1(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  if (isArray$2(source) || isString$2(source)) {
    ret = new Array(source.length);
    for (let i = 0, l2 = source.length; i < l2; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l2 = keys.length; i < l2; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props.name = name;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(
    Fragment,
    {
      key: props.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode$1(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn$1(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn$1(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn$1(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn$1(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn$1(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn$1(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn$1(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn$1(normalizedProps, key) || hasOwn$1(ctx, key) || hasOwn$1(publicPropertiesMap, key) || hasOwn$1(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn$1(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function normalizePropsOrEmits(props) {
  return isArray$2(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$4(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v2) => c.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache2,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$4(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(
      isFunction$2(to) ? to.call(this, this) : to,
      isFunction$2(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$2(to) && isArray$2(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend$1(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = extend$1({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$2(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$2(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(
            rootComponent,
            rootProps
          );
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn$1(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn$1(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn$1(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn$1(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn$1(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn$1(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent2) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn$1(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent2 && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$1({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn$1(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach(
      (r2, i) => setRef(
        r2,
        oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn$1(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn$1(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$2(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn$1(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn$1(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis$1();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el2 = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el2, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el2,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el2,
            key,
            null,
            props[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props) {
        hostPatchProp(el2, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el2, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el2,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el2,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el2,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el2,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el2,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el2,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el2,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el2,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm, m: m2, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el2,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update2),
      instance.scope
      // track it in component's effect scope
    );
    const update2 = instance.update = () => effect.run();
    update2.id = instance.uid;
    toggleRecurse(instance, true);
    update2();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update2, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update2) {
      update2.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate,
    createApp: createAppAPI(render2, hydrate)
  };
}
function toggleRecurse({ effect, update: update2 }, allowed) {
  effect.allowRecurse = update2.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u2, v2, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c = u2 + v2 >> 1;
        if (arr[result[c]] < arrI) {
          u2 = c + 1;
        } else {
          v2 = c;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i] = result[u2 - 1];
        }
        result[u2] = i;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            true,
            !!child.dynamicChildren
          );
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el: el2, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el2, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode$1(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode$1(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$4(style2)) {
      if (isProxy(style2) && !isArray$2(style2)) {
        style2 = extend$1({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$4(type) ? 4 : isFunction$2(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis$1()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis$1()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(
          extend$1(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$4(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode$1(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode$1(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
const version = "3.3.4";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id2) {
    el2.setAttribute(id2, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style2 = el2.style;
  const isCssString = isString$2(next);
  if (next && !isCssString) {
    if (prev && !isString$2(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name, val) {
  if (isArray$2(val)) {
    val.forEach((v2) => setStyle(style2, name, v2));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style2.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style2, name);
      if (importantRE.test(val)) {
        style2.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes$1 = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style2) {
    return prefixCache[rawName] = name;
  }
  name = capitalize$1(name);
  for (let i = 0; i < prefixes$1.length; i++) {
    const prefixed = prefixes$1[i] + name;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  const tag = el2.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el2._value = value;
    const oldValue = tag === "OPTION" ? el2.getAttribute("value") : el2.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e) {
  }
  needRemove && el2.removeAttribute(key);
}
function addEventListener$1(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener$1(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName$1(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener$1(el2, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener$1(el2, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName$1(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$3 = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$3.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(
      el2,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$2(value)) {
    return false;
  }
  return key in el2;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend$1(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el2, isAppear, done) => {
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    el2._isLeaving = false;
    removeTransitionClass(el2, leaveFromClass);
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook(hook, [el2, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el2) {
      callHook(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      el2._isLeaving = true;
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      forceReflow();
      addTransitionClass(el2, leaveActiveClass);
      nextFrame(() => {
        if (!el2._isLeaving) {
          return;
        }
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false);
      callHook(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true);
      callHook(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$4(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  return res;
}
function addTransitionClass(el2, cls2) {
  cls2.split(/\s+/).forEach((c) => c && el2.classList.add(c));
  (el2._vtc || (el2._vtc = /* @__PURE__ */ new Set())).add(cls2);
}
function removeTransitionClass(el2, cls2) {
  cls2.split(/\s+/).forEach((c) => c && el2.classList.remove(c));
  const { _vtc } = el2;
  if (_vtc) {
    _vtc.delete(cls2);
    if (!_vtc.size) {
      el2._vtc = void 0;
    }
  }
}
function nextFrame(cb2) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb2);
  });
}
let endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id2 = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id2 === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el2 && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el2 = c.el;
        const style2 = el2.style;
        addTransitionClass(el2, moveClass);
        style2.transform = style2.webkitTransform = style2.transitionDuration = "";
        const cb2 = el2._moveCb = (e) => {
          if (e && e.target !== el2) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el2.removeEventListener("transitionend", cb2);
            el2._moveCb = null;
            removeTransitionClass(el2, moveClass);
          }
        };
        el2.addEventListener("transitionend", cb2);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el2 = c.el;
  if (el2._moveCb) {
    el2._moveCb();
  }
  if (el2._enterCb) {
    el2._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el2, root2, moveClass) {
  const clone2 = el2.cloneNode();
  if (el2._vtc) {
    el2._vtc.forEach((cls2) => {
      cls2.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var isVue2 = false;
/*!
* pinia v2.1.6
* (c) 2023 Eduardo San Martin Morote
* @license MIT
*/
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const piniaSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function isPlainObject$2(o) {
  return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      {
        pinia2._a = app2;
        app2.provide(piniaSymbol, pinia2);
        app2.config.globalProperties.$pinia = pinia2;
        toBeInstalled.forEach((plugin) => _p.push(plugin));
        toBeInstalled = [];
      }
    },
    use(plugin) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin);
      } else {
        _p.push(plugin);
      }
      return this;
    },
    _p,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia2;
}
const noop$1 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentScope()) {
    onScopeDispose(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
const fallbackRunWithContext = (fn) => fn();
function mergeReactiveObjects(target, patchToApply) {
  if (target instanceof Map && patchToApply instanceof Map) {
    patchToApply.forEach((value, key) => target.set(key, value));
  }
  if (target instanceof Set && patchToApply instanceof Set) {
    patchToApply.forEach(target.add, target);
  }
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$2(targetValue) && isPlainObject$2(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = (
  /* istanbul ignore next */
  Symbol()
);
function shouldHydrate(obj) {
  return !isPlainObject$2(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$1 } = Object;
function isComputed(o) {
  return !!(isRef(o) && o.effect);
}
function createOptionsStore(id2, options, pinia2, hot) {
  const { state, actions, getters } = options;
  const initialState = pinia2.state.value[id2];
  let store;
  function setup() {
    if (!initialState && true) {
      {
        pinia2.state.value[id2] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia2.state.value[id2]);
    return assign$1(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
      computedGetters[name] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store2 = pinia2._s.get(id2);
        return getters[name].call(store2, store2);
      }));
      return computedGetters;
    }, {}));
  }
  store = createSetupStore(id2, setup, options, pinia2, hot, true);
  return store;
}
function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$1({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
    // flush: 'post',
  };
  let isListening;
  let isSyncListening;
  let subscriptions = [];
  let actionSubscriptions = [];
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia2.state.value[$id] = {};
    }
  }
  ref({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  const $reset = isOptionsStore ? function $reset2() {
    const { state } = options;
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$1($state, newState);
    });
  } : (
    /* istanbul ignore next */
    noop$1
  );
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  function wrapAction(name, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name,
        store,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia2,
    // _s: scope,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$1({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store = reactive(partialStore);
  pinia2._s.set($id, store);
  const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
  const setupStore = pinia2._e.run(() => {
    scope = effectScope();
    return runWithContext(() => scope.run(setup));
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia2.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign$1(store, setupStore);
    assign$1(toRaw(store), setupStore);
  }
  Object.defineProperty(store, "$state", {
    get: () => pinia2.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$1($state, state);
      });
    }
  });
  pinia2._p.forEach((extender) => {
    {
      assign$1(store, scope.run(() => extender({
        store,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore(pinia2, hot) {
    const hasContext = hasInjectionContext();
    pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
    if (pinia2)
      setActivePinia(pinia2);
    pinia2 = activePinia;
    if (!pinia2._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup, options, pinia2);
      } else {
        createOptionsStore(id2, options, pinia2);
      }
    }
    const store = pinia2._s.get(id2);
    return store;
  }
  useStore.$id = id2;
  return useStore;
}
function storeToRefs(store) {
  {
    store = toRaw(store);
    const refs = {};
    for (const key in store) {
      const value = store[key];
      if (isRef(value) || isReactive(value)) {
        refs[key] = // ---
        toRef(store, key);
      }
    }
    return refs;
  }
}
var DeliveryMode = /* @__PURE__ */ ((DeliveryMode2) => {
  DeliveryMode2["DOOR"] = "door";
  DeliveryMode2["OFFICE"] = "office";
  return DeliveryMode2;
})(DeliveryMode || {});
var Popup = /* @__PURE__ */ ((Popup2) => {
  Popup2["FILTERS"] = "filters";
  Popup2["SUPPORT"] = "support";
  Popup2["MENU"] = "menu";
  Popup2["INFO"] = "info";
  return Popup2;
})(Popup || {});
const core = defineStore("core", () => {
  const uiLoadLocksCounter = ref(1);
  const lockUi = () => {
    uiLoadLocksCounter.value++;
  };
  const unlockUi = () => {
    uiLoadLocksCounter.value--;
  };
  const openedPopups = reactive({
    [Popup.SUPPORT]: false,
    [Popup.MENU]: false,
    [Popup.FILTERS]: false,
    [Popup.INFO]: false
  });
  const mode = ref(DeliveryMode.OFFICE);
  const selected = ref(false);
  const params = reactive({});
  const selectedTariff = ref(null);
  const globalPopup = ref(false);
  const closePopups = () => {
    if (debug.value)
      console.debug("[CDEK] Closing all popups");
    openedPopups[Popup.MENU] = false;
    openedPopups[Popup.FILTERS] = false;
    openedPopups[Popup.SUPPORT] = false;
  };
  const togglePopup = (name) => {
    const newValue = !openedPopups[name];
    closePopups();
    if (debug.value)
      console.debug("[CDEK] Toggle popup", name);
    openedPopups[name] = newValue;
  };
  const debug = computed(() => !!params.debug);
  const tariffs = reactive({
    pickup: [],
    office: [],
    door: []
  });
  const closeWidget = () => {
    globalPopup.value = false;
  };
  return {
    closeWidget,
    selected,
    params,
    selectedTariff,
    tariffs,
    uiLoadLocksCounter,
    lockUi,
    unlockUi,
    debug,
    openedPopups,
    togglePopup,
    closePopups,
    mode,
    globalPopup
  };
});
const config = {
  map: {
    defaultKey: {}.VITE_DEFAULT_KEY || "yandex-api-key",
    apiVersion: "v3",
    geocoderVersion: "1.x",
    timeout: 2e3,
    defaultCenter: [37.622504, 55.753215],
    defaultZoom: 10,
    defaultDuration: 1e3
  },
  promo: {
    url: "https://cdek.ru",
    tel: {
      data: "88002501405",
      title: "8 800 250-14-05"
    },
    mail: "sales@cdek.ru"
  }
};
var YandexMapErrorCode = /* @__PURE__ */ ((YandexMapErrorCode2) => {
  YandexMapErrorCode2[YandexMapErrorCode2["SCRIPT_INIT"] = 0] = "SCRIPT_INIT";
  YandexMapErrorCode2[YandexMapErrorCode2["TIMEOUT"] = 1] = "TIMEOUT";
  YandexMapErrorCode2[YandexMapErrorCode2["SCRIPT_ERROR"] = 2] = "SCRIPT_ERROR";
  YandexMapErrorCode2[YandexMapErrorCode2["SERVICE_ERROR"] = 3] = "SERVICE_ERROR";
  return YandexMapErrorCode2;
})(YandexMapErrorCode || {});
var YandexMapState = /* @__PURE__ */ ((YandexMapState2) => {
  YandexMapState2[YandexMapState2["INIT"] = 0] = "INIT";
  YandexMapState2[YandexMapState2["PLUGGED"] = 1] = "PLUGGED";
  YandexMapState2[YandexMapState2["WAITING"] = 2] = "WAITING";
  YandexMapState2[YandexMapState2["READY"] = 3] = "READY";
  YandexMapState2[YandexMapState2["REACT_LOADED"] = 4] = "REACT_LOADED";
  YandexMapState2[YandexMapState2["POINTS_LOADED"] = 5] = "POINTS_LOADED";
  return YandexMapState2;
})(YandexMapState || {});
var YandexMapZoomVariants = /* @__PURE__ */ ((YandexMapZoomVariants2) => {
  YandexMapZoomVariants2[YandexMapZoomVariants2["GENERAL"] = 10] = "GENERAL";
  YandexMapZoomVariants2[YandexMapZoomVariants2["STREET"] = 15] = "STREET";
  YandexMapZoomVariants2[YandexMapZoomVariants2["HOME"] = 17] = "HOME";
  return YandexMapZoomVariants2;
})(YandexMapZoomVariants || {});
const search = defineStore("search", () => {
  const value = ref("");
  const loading = ref(false);
  const filters = reactive({
    type: null,
    have_cashless: null,
    have_cash: null,
    allowed_cod: null,
    is_dressing_room: null
  });
  const hideFilters = reactive({
    type: false,
    have_cashless: false,
    have_cash: false,
    is_dressing_room: false
  });
  const searchResults = ref([]);
  return { value, loading, filters, searchResults, hideFilters };
});
function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var now = function() {
  return root$1.Date.now();
};
const now$1 = now;
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index = string2.length;
  while (index-- && reWhitespace.test(string2.charAt(index))) {
  }
  return index;
}
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
}
var Symbol$1 = root$1.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$2.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString$1(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$3(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$3(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject$3(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
const map = defineStore("map", () => {
  const coreStorage = core();
  const searchStorage = search();
  const mapLoadError = ref(null);
  const mapState = ref(YandexMapState.INIT);
  const exactPoint = ref(null);
  const exactOffice = ref(null);
  const pointInfo = ref(null);
  const location = reactive({
    center: config.map.defaultCenter,
    zoom: config.map.defaultZoom,
    duration: config.map.defaultDuration
  });
  const offices = ref([]);
  const bounds = reactive({
    left: config.map.defaultCenter,
    right: config.map.defaultCenter
  });
  const filteredOffices = computed(
    () => offices.value.filter(
      (office) => office.location[0] <= bounds.right[0] && office.location[1] >= bounds.right[1] && office.location[0] >= bounds.left[0] && office.location[1] <= bounds.left[1]
    )
  );
  const searchedOffices = computed(() => {
    if (searchStorage.value.length === 0)
      return [];
    const result = [];
    for (const office of filteredOffices.value) {
      if (office.code.indexOf(searchStorage.value) !== -1 || office.name.indexOf(searchStorage.value) !== -1) {
        result.push(office);
      }
    }
    return result;
  });
  const waitForMap = () => new Promise((resolve2, reject) => {
    coreStorage.lockUi();
    if (coreStorage.debug) {
      window.console.debug("[CDEK] Waiting for ymaps3 will be available");
    }
    const int = setInterval(() => {
      if (!Object.prototype.hasOwnProperty.call(window, "ymaps3"))
        return;
      if (coreStorage.debug) {
        window.console.debug("[CDEK] ymaps3 awailable");
      }
      clearInterval(int);
      mapState.value = YandexMapState.WAITING;
      resolve2(ymaps3.ready);
    }, 100);
    setTimeout(() => {
      if (mapState.value >= YandexMapState.READY || mapLoadError.value !== null) {
        return;
      }
      if (coreStorage.debug) {
        window.console.debug("[CDEK] ymaps3 waiting timout reached");
      }
      mapLoadError.value = YandexMapErrorCode.TIMEOUT;
      clearInterval(int);
      reject();
    }, config.map.timeout);
  }).then(
    () => {
      mapState.value = YandexMapState.READY;
      return ymaps3.import("@yandex/ymaps3-reactify");
    },
    () => {
      mapLoadError.value = YandexMapErrorCode.SCRIPT_ERROR;
      coreStorage.unlockUi();
    }
  ).then(
    (ymaps3Reactify) => {
      mapState.value = YandexMapState.REACT_LOADED;
      coreStorage.unlockUi();
      return ymaps3Reactify;
    },
    () => {
      coreStorage.unlockUi();
      mapLoadError.value = YandexMapErrorCode.SCRIPT_ERROR;
    }
  );
  const plugMapScript = (src) => new Promise((resolve2, reject) => {
    if (coreStorage.debug)
      window.console.debug("[CDEK] Plugging map script");
    if (Object.prototype.hasOwnProperty.call(window, "ymaps3")) {
      if (coreStorage.debug) {
        window.console.debug("[CDEK] Map script already plugged");
      }
      mapState.value = YandexMapState.PLUGGED;
      resolve2(true);
      return;
    }
    const script = window.document.createElement("script");
    script.addEventListener("load", () => {
      if (coreStorage.debug) {
        window.console.debug("[CDEK] Map script loaded");
      }
      mapState.value = YandexMapState.PLUGGED;
      resolve2(true);
    });
    script.addEventListener("error", () => {
      if (coreStorage.debug) {
        window.console.debug("[CDEK] Map script load error");
      }
      mapLoadError.value = YandexMapErrorCode.SCRIPT_INIT;
      reject();
    });
    script.src = src;
    script.type = "text/javascript";
    window.document.head.appendChild(script);
    if (coreStorage.debug) {
      window.console.debug("[CDEK] Map script has been plugged");
    }
  });
  const debouncedUpdate = debounce((updateObject) => {
    const newBounds = updateObject.location.bounds;
    bounds.left = newBounds[0];
    bounds.right = newBounds[1];
    location.center = updateObject.location.center;
    location.zoom = updateObject.location.zoom;
    searchStorage.loading = false;
  }, 2e3);
  const update2 = (updateObject) => {
    searchStorage.loading = true;
    debouncedUpdate(updateObject);
  };
  const customClick = (_updateObject, event) => {
    if (coreStorage.debug) {
      console.debug("[CDEK] Map clicked", event.coordinates);
    }
    if (coreStorage.params.hideDeliveryOptions[DeliveryMode.DOOR]) {
      if (coreStorage.debug) {
        console.debug("[CDEK] Door delivery disabled, doing nothing");
      }
      return;
    }
    searchStorage.loading = true;
    exactPoint.value = event.coordinates;
    if (coreStorage.debug) {
      console.debug("[CDEK] Switching delivery mode to door");
    }
    coreStorage.$patch({ mode: DeliveryMode.DOOR, selectedTariff: null, selected: false });
    if (!coreStorage.openedPopups[Popup.INFO])
      coreStorage.togglePopup(Popup.INFO);
    location.center = event.coordinates;
    location.zoom = YandexMapZoomVariants.HOME;
    pointInfo.value = null;
  };
  return {
    pointInfo,
    customClick,
    exactPoint,
    exactOffice,
    searchedOffices,
    mapLoadError,
    plugMapScript,
    mapState,
    waitForMap,
    location,
    offices,
    update: update2,
    bounds,
    filteredOffices
  };
});
const style$1 = "";
var R_ = Object.defineProperty;
var L_ = (r2, a, o) => a in r2 ? R_(r2, a, { enumerable: true, configurable: true, writable: true, value: o }) : r2[a] = o;
var Xe$1 = (r2, a, o) => (L_(r2, typeof a != "symbol" ? a + "" : a, o), o);
var jn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ii$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
ii$1.exports;
(function(r2, a) {
  (function() {
    var o, d = "4.17.21", c = 200, g = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", _ = "Expected a function", A2 = "Invalid `variable` option passed into `_.template`", S2 = "__lodash_hash_undefined__", y2 = 500, k2 = "__lodash_placeholder__", V2 = 1, te2 = 2, se2 = 4, B2 = 1, ne2 = 2, E2 = 1, Z2 = 2, U2 = 4, N2 = 8, X2 = 16, x2 = 32, q2 = 64, ge2 = 128, Ne2 = 256, Ft = 512, ci2 = 30, Dl = "...", Ml = 800, Fl = 16, Xo = 1, Nl = 2, Ul = 3, Jt = 1 / 0, Nt = 9007199254740991, Vl = 17976931348623157e292, lr = 0 / 0, mt = 4294967295, Wl = mt - 1, Hl = mt >>> 1, Gl = [
      ["ary", ge2],
      ["bind", E2],
      ["bindKey", Z2],
      ["curry", N2],
      ["curryRight", X2],
      ["flip", Ft],
      ["partial", x2],
      ["partialRight", q2],
      ["rearg", Ne2]
    ], hn = "[object Arguments]", cr = "[object Array]", zl = "[object AsyncFunction]", Rn = "[object Boolean]", Ln = "[object Date]", Zl = "[object DOMException]", fr = "[object Error]", dr = "[object Function]", Jo = "[object GeneratorFunction]", lt = "[object Map]", $n = "[object Number]", ql2 = "[object Null]", Tt = "[object Object]", Qo = "[object Promise]", Kl = "[object Proxy]", Bn = "[object RegExp]", ct = "[object Set]", Pn = "[object String]", hr = "[object Symbol]", Yl = "[object Undefined]", Dn = "[object WeakMap]", Xl = "[object WeakSet]", Mn = "[object ArrayBuffer]", pn = "[object DataView]", fi2 = "[object Float32Array]", di2 = "[object Float64Array]", hi2 = "[object Int8Array]", pi2 = "[object Int16Array]", vi2 = "[object Int32Array]", gi2 = "[object Uint8Array]", _i = "[object Uint8ClampedArray]", mi2 = "[object Uint16Array]", wi2 = "[object Uint32Array]", Jl = /\b__p \+= '';/g, Ql = /\b(__p \+=) '' \+/g, jl2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, jo = /&(?:amp|lt|gt|quot|#39);/g, es = /[&<>"']/g, ec2 = RegExp(jo.source), tc2 = RegExp(es.source), nc2 = /<%-([\s\S]+?)%>/g, rc2 = /<%([\s\S]+?)%>/g, ts = /<%=([\s\S]+?)%>/g, ic2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, oc2 = /^\w*$/, sc2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, yi2 = /[\\^$.*+?()[\]{}|]/g, ac2 = RegExp(yi2.source), bi2 = /^\s+/, uc2 = /\s/, lc2 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, cc2 = /\{\n\/\* \[wrapped with (.+)\] \*/, fc2 = /,? & /, dc2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, hc2 = /[()=,{}\[\]\/\s]/, pc2 = /\\(\\)?/g, vc2 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, ns = /\w*$/, gc2 = /^[-+]0x[0-9a-f]+$/i, _c = /^0b[01]+$/i, mc2 = /^\[object .+?Constructor\]$/, wc2 = /^0o[0-7]+$/i, yc2 = /^(?:0|[1-9]\d*)$/, bc2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, pr = /($^)/, Cc2 = /['\n\r\u2028\u2029\\]/g, vr = "\\ud800-\\udfff", Sc2 = "\\u0300-\\u036f", Ac2 = "\\ufe20-\\ufe2f", Tc2 = "\\u20d0-\\u20ff", rs = Sc2 + Ac2 + Tc2, is = "\\u2700-\\u27bf", os = "a-z\\xdf-\\xf6\\xf8-\\xff", kc2 = "\\xac\\xb1\\xd7\\xf7", Ic2 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", xc2 = "\\u2000-\\u206f", Oc2 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ss = "A-Z\\xc0-\\xd6\\xd8-\\xde", as = "\\ufe0e\\ufe0f", us = kc2 + Ic2 + xc2 + Oc2, Ci2 = "[']", Ec2 = "[" + vr + "]", ls = "[" + us + "]", gr = "[" + rs + "]", cs = "\\d+", Rc2 = "[" + is + "]", fs = "[" + os + "]", ds = "[^" + vr + us + cs + is + os + ss + "]", Si2 = "\\ud83c[\\udffb-\\udfff]", Lc2 = "(?:" + gr + "|" + Si2 + ")", hs = "[^" + vr + "]", Ai2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Ti2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", vn = "[" + ss + "]", ps = "\\u200d", vs = "(?:" + fs + "|" + ds + ")", $c2 = "(?:" + vn + "|" + ds + ")", gs = "(?:" + Ci2 + "(?:d|ll|m|re|s|t|ve))?", _s = "(?:" + Ci2 + "(?:D|LL|M|RE|S|T|VE))?", ms = Lc2 + "?", ws = "[" + as + "]?", Bc2 = "(?:" + ps + "(?:" + [hs, Ai2, Ti2].join("|") + ")" + ws + ms + ")*", Pc2 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Dc2 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ys = ws + ms + Bc2, Mc2 = "(?:" + [Rc2, Ai2, Ti2].join("|") + ")" + ys, Fc2 = "(?:" + [hs + gr + "?", gr, Ai2, Ti2, Ec2].join("|") + ")", Nc2 = RegExp(Ci2, "g"), Uc2 = RegExp(gr, "g"), ki2 = RegExp(Si2 + "(?=" + Si2 + ")|" + Fc2 + ys, "g"), Vc2 = RegExp([
      vn + "?" + fs + "+" + gs + "(?=" + [ls, vn, "$"].join("|") + ")",
      $c2 + "+" + _s + "(?=" + [ls, vn + vs, "$"].join("|") + ")",
      vn + "?" + vs + "+" + gs,
      vn + "+" + _s,
      Dc2,
      Pc2,
      cs,
      Mc2
    ].join("|"), "g"), Wc2 = RegExp("[" + ps + vr + rs + as + "]"), Hc2 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Gc2 = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], zc2 = -1, pe2 = {};
    pe2[fi2] = pe2[di2] = pe2[hi2] = pe2[pi2] = pe2[vi2] = pe2[gi2] = pe2[_i] = pe2[mi2] = pe2[wi2] = true, pe2[hn] = pe2[cr] = pe2[Mn] = pe2[Rn] = pe2[pn] = pe2[Ln] = pe2[fr] = pe2[dr] = pe2[lt] = pe2[$n] = pe2[Tt] = pe2[Bn] = pe2[ct] = pe2[Pn] = pe2[Dn] = false;
    var he2 = {};
    he2[hn] = he2[cr] = he2[Mn] = he2[pn] = he2[Rn] = he2[Ln] = he2[fi2] = he2[di2] = he2[hi2] = he2[pi2] = he2[vi2] = he2[lt] = he2[$n] = he2[Tt] = he2[Bn] = he2[ct] = he2[Pn] = he2[hr] = he2[gi2] = he2[_i] = he2[mi2] = he2[wi2] = true, he2[fr] = he2[dr] = he2[Dn] = false;
    var Zc2 = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, qc2 = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Kc2 = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Yc2 = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Xc2 = parseFloat, Jc2 = parseInt, bs = typeof jn == "object" && jn && jn.Object === Object && jn, Qc2 = typeof self == "object" && self && self.Object === Object && self, xe = bs || Qc2 || Function("return this")(), Ii2 = a && !a.nodeType && a, Qt = Ii2 && true && r2 && !r2.nodeType && r2, Cs = Qt && Qt.exports === Ii2, xi2 = Cs && bs.process, Qe2 = function() {
      try {
        var p2 = Qt && Qt.require && Qt.require("util").types;
        return p2 || xi2 && xi2.binding && xi2.binding("util");
      } catch {
      }
    }(), Ss = Qe2 && Qe2.isArrayBuffer, As = Qe2 && Qe2.isDate, Ts = Qe2 && Qe2.isMap, ks = Qe2 && Qe2.isRegExp, Is = Qe2 && Qe2.isSet, xs = Qe2 && Qe2.isTypedArray;
    function Ge2(p2, w2, m2) {
      switch (m2.length) {
        case 0:
          return p2.call(w2);
        case 1:
          return p2.call(w2, m2[0]);
        case 2:
          return p2.call(w2, m2[0], m2[1]);
        case 3:
          return p2.call(w2, m2[0], m2[1], m2[2]);
      }
      return p2.apply(w2, m2);
    }
    function jc2(p2, w2, m2, R2) {
      for (var W2 = -1, oe2 = p2 == null ? 0 : p2.length; ++W2 < oe2; ) {
        var Te2 = p2[W2];
        w2(R2, Te2, m2(Te2), p2);
      }
      return R2;
    }
    function je2(p2, w2) {
      for (var m2 = -1, R2 = p2 == null ? 0 : p2.length; ++m2 < R2 && w2(p2[m2], m2, p2) !== false; )
        ;
      return p2;
    }
    function ef2(p2, w2) {
      for (var m2 = p2 == null ? 0 : p2.length; m2-- && w2(p2[m2], m2, p2) !== false; )
        ;
      return p2;
    }
    function Os(p2, w2) {
      for (var m2 = -1, R2 = p2 == null ? 0 : p2.length; ++m2 < R2; )
        if (!w2(p2[m2], m2, p2))
          return false;
      return true;
    }
    function Ut(p2, w2) {
      for (var m2 = -1, R2 = p2 == null ? 0 : p2.length, W2 = 0, oe2 = []; ++m2 < R2; ) {
        var Te2 = p2[m2];
        w2(Te2, m2, p2) && (oe2[W2++] = Te2);
      }
      return oe2;
    }
    function _r(p2, w2) {
      var m2 = p2 == null ? 0 : p2.length;
      return !!m2 && gn(p2, w2, 0) > -1;
    }
    function Oi2(p2, w2, m2) {
      for (var R2 = -1, W2 = p2 == null ? 0 : p2.length; ++R2 < W2; )
        if (m2(w2, p2[R2]))
          return true;
      return false;
    }
    function ve2(p2, w2) {
      for (var m2 = -1, R2 = p2 == null ? 0 : p2.length, W2 = Array(R2); ++m2 < R2; )
        W2[m2] = w2(p2[m2], m2, p2);
      return W2;
    }
    function Vt(p2, w2) {
      for (var m2 = -1, R2 = w2.length, W2 = p2.length; ++m2 < R2; )
        p2[W2 + m2] = w2[m2];
      return p2;
    }
    function Ei2(p2, w2, m2, R2) {
      var W2 = -1, oe2 = p2 == null ? 0 : p2.length;
      for (R2 && oe2 && (m2 = p2[++W2]); ++W2 < oe2; )
        m2 = w2(m2, p2[W2], W2, p2);
      return m2;
    }
    function tf2(p2, w2, m2, R2) {
      var W2 = p2 == null ? 0 : p2.length;
      for (R2 && W2 && (m2 = p2[--W2]); W2--; )
        m2 = w2(m2, p2[W2], W2, p2);
      return m2;
    }
    function Ri2(p2, w2) {
      for (var m2 = -1, R2 = p2 == null ? 0 : p2.length; ++m2 < R2; )
        if (w2(p2[m2], m2, p2))
          return true;
      return false;
    }
    var nf2 = Li2("length");
    function rf2(p2) {
      return p2.split("");
    }
    function of2(p2) {
      return p2.match(dc2) || [];
    }
    function Es(p2, w2, m2) {
      var R2;
      return m2(p2, function(W2, oe2, Te2) {
        if (w2(W2, oe2, Te2))
          return R2 = oe2, false;
      }), R2;
    }
    function mr(p2, w2, m2, R2) {
      for (var W2 = p2.length, oe2 = m2 + (R2 ? 1 : -1); R2 ? oe2-- : ++oe2 < W2; )
        if (w2(p2[oe2], oe2, p2))
          return oe2;
      return -1;
    }
    function gn(p2, w2, m2) {
      return w2 === w2 ? _f(p2, w2, m2) : mr(p2, Rs, m2);
    }
    function sf2(p2, w2, m2, R2) {
      for (var W2 = m2 - 1, oe2 = p2.length; ++W2 < oe2; )
        if (R2(p2[W2], w2))
          return W2;
      return -1;
    }
    function Rs(p2) {
      return p2 !== p2;
    }
    function Ls(p2, w2) {
      var m2 = p2 == null ? 0 : p2.length;
      return m2 ? Bi2(p2, w2) / m2 : lr;
    }
    function Li2(p2) {
      return function(w2) {
        return w2 == null ? o : w2[p2];
      };
    }
    function $i2(p2) {
      return function(w2) {
        return p2 == null ? o : p2[w2];
      };
    }
    function $s(p2, w2, m2, R2, W2) {
      return W2(p2, function(oe2, Te2, fe2) {
        m2 = R2 ? (R2 = false, oe2) : w2(m2, oe2, Te2, fe2);
      }), m2;
    }
    function af2(p2, w2) {
      var m2 = p2.length;
      for (p2.sort(w2); m2--; )
        p2[m2] = p2[m2].value;
      return p2;
    }
    function Bi2(p2, w2) {
      for (var m2, R2 = -1, W2 = p2.length; ++R2 < W2; ) {
        var oe2 = w2(p2[R2]);
        oe2 !== o && (m2 = m2 === o ? oe2 : m2 + oe2);
      }
      return m2;
    }
    function Pi2(p2, w2) {
      for (var m2 = -1, R2 = Array(p2); ++m2 < p2; )
        R2[m2] = w2(m2);
      return R2;
    }
    function uf2(p2, w2) {
      return ve2(w2, function(m2) {
        return [m2, p2[m2]];
      });
    }
    function Bs(p2) {
      return p2 && p2.slice(0, Fs(p2) + 1).replace(bi2, "");
    }
    function ze(p2) {
      return function(w2) {
        return p2(w2);
      };
    }
    function Di2(p2, w2) {
      return ve2(w2, function(m2) {
        return p2[m2];
      });
    }
    function Fn(p2, w2) {
      return p2.has(w2);
    }
    function Ps(p2, w2) {
      for (var m2 = -1, R2 = p2.length; ++m2 < R2 && gn(w2, p2[m2], 0) > -1; )
        ;
      return m2;
    }
    function Ds(p2, w2) {
      for (var m2 = p2.length; m2-- && gn(w2, p2[m2], 0) > -1; )
        ;
      return m2;
    }
    function lf2(p2, w2) {
      for (var m2 = p2.length, R2 = 0; m2--; )
        p2[m2] === w2 && ++R2;
      return R2;
    }
    var cf2 = $i2(Zc2), ff2 = $i2(qc2);
    function df2(p2) {
      return "\\" + Yc2[p2];
    }
    function hf(p2, w2) {
      return p2 == null ? o : p2[w2];
    }
    function _n(p2) {
      return Wc2.test(p2);
    }
    function pf2(p2) {
      return Hc2.test(p2);
    }
    function vf2(p2) {
      for (var w2, m2 = []; !(w2 = p2.next()).done; )
        m2.push(w2.value);
      return m2;
    }
    function Mi2(p2) {
      var w2 = -1, m2 = Array(p2.size);
      return p2.forEach(function(R2, W2) {
        m2[++w2] = [W2, R2];
      }), m2;
    }
    function Ms(p2, w2) {
      return function(m2) {
        return p2(w2(m2));
      };
    }
    function Wt(p2, w2) {
      for (var m2 = -1, R2 = p2.length, W2 = 0, oe2 = []; ++m2 < R2; ) {
        var Te2 = p2[m2];
        (Te2 === w2 || Te2 === k2) && (p2[m2] = k2, oe2[W2++] = m2);
      }
      return oe2;
    }
    function wr(p2) {
      var w2 = -1, m2 = Array(p2.size);
      return p2.forEach(function(R2) {
        m2[++w2] = R2;
      }), m2;
    }
    function gf(p2) {
      var w2 = -1, m2 = Array(p2.size);
      return p2.forEach(function(R2) {
        m2[++w2] = [R2, R2];
      }), m2;
    }
    function _f(p2, w2, m2) {
      for (var R2 = m2 - 1, W2 = p2.length; ++R2 < W2; )
        if (p2[R2] === w2)
          return R2;
      return -1;
    }
    function mf2(p2, w2, m2) {
      for (var R2 = m2 + 1; R2--; )
        if (p2[R2] === w2)
          return R2;
      return R2;
    }
    function mn(p2) {
      return _n(p2) ? yf2(p2) : nf2(p2);
    }
    function ft(p2) {
      return _n(p2) ? bf2(p2) : rf2(p2);
    }
    function Fs(p2) {
      for (var w2 = p2.length; w2-- && uc2.test(p2.charAt(w2)); )
        ;
      return w2;
    }
    var wf2 = $i2(Kc2);
    function yf2(p2) {
      for (var w2 = ki2.lastIndex = 0; ki2.test(p2); )
        ++w2;
      return w2;
    }
    function bf2(p2) {
      return p2.match(ki2) || [];
    }
    function Cf2(p2) {
      return p2.match(Vc2) || [];
    }
    var Sf2 = function p2(w2) {
      w2 = w2 == null ? xe : wn.defaults(xe.Object(), w2, wn.pick(xe, Gc2));
      var m2 = w2.Array, R2 = w2.Date, W2 = w2.Error, oe2 = w2.Function, Te2 = w2.Math, fe2 = w2.Object, Fi2 = w2.RegExp, Af2 = w2.String, et = w2.TypeError, yr = m2.prototype, Tf2 = oe2.prototype, yn = fe2.prototype, br = w2["__core-js_shared__"], Cr = Tf2.toString, ue2 = yn.hasOwnProperty, kf = 0, Ns = function() {
        var e = /[^.]+$/.exec(br && br.keys && br.keys.IE_PROTO || "");
        return e ? "Symbol(src)_1." + e : "";
      }(), Sr = yn.toString, If2 = Cr.call(fe2), xf2 = xe._, Of2 = Fi2(
        "^" + Cr.call(ue2).replace(yi2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Ar = Cs ? w2.Buffer : o, Ht = w2.Symbol, Tr = w2.Uint8Array, Us = Ar ? Ar.allocUnsafe : o, kr = Ms(fe2.getPrototypeOf, fe2), Vs = fe2.create, Ws = yn.propertyIsEnumerable, Ir = yr.splice, Hs = Ht ? Ht.isConcatSpreadable : o, Nn = Ht ? Ht.iterator : o, jt = Ht ? Ht.toStringTag : o, xr = function() {
        try {
          var e = on(fe2, "defineProperty");
          return e({}, "", {}), e;
        } catch {
        }
      }(), Ef2 = w2.clearTimeout !== xe.clearTimeout && w2.clearTimeout, Rf2 = R2 && R2.now !== xe.Date.now && R2.now, Lf2 = w2.setTimeout !== xe.setTimeout && w2.setTimeout, Or = Te2.ceil, Er = Te2.floor, Ni2 = fe2.getOwnPropertySymbols, $f2 = Ar ? Ar.isBuffer : o, Gs = w2.isFinite, Bf2 = yr.join, Pf2 = Ms(fe2.keys, fe2), ke2 = Te2.max, Re2 = Te2.min, Df2 = R2.now, Mf2 = w2.parseInt, zs = Te2.random, Ff2 = yr.reverse, Ui2 = on(w2, "DataView"), Un = on(w2, "Map"), Vi2 = on(w2, "Promise"), bn = on(w2, "Set"), Vn = on(w2, "WeakMap"), Wn = on(fe2, "create"), Rr = Vn && new Vn(), Cn = {}, Nf2 = sn(Ui2), Uf2 = sn(Un), Vf2 = sn(Vi2), Wf2 = sn(bn), Hf2 = sn(Vn), Lr = Ht ? Ht.prototype : o, Hn = Lr ? Lr.valueOf : o, Zs = Lr ? Lr.toString : o;
      function u2(e) {
        if (ye(e) && !H2(e) && !(e instanceof Q2)) {
          if (e instanceof tt)
            return e;
          if (ue2.call(e, "__wrapped__"))
            return qa2(e);
        }
        return new tt(e);
      }
      var Sn = function() {
        function e() {
        }
        return function(t2) {
          if (!_e(t2))
            return {};
          if (Vs)
            return Vs(t2);
          e.prototype = t2;
          var n2 = new e();
          return e.prototype = o, n2;
        };
      }();
      function $r() {
      }
      function tt(e, t2) {
        this.__wrapped__ = e, this.__actions__ = [], this.__chain__ = !!t2, this.__index__ = 0, this.__values__ = o;
      }
      u2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: nc2,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: rc2,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ts,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: u2
        }
      }, u2.prototype = $r.prototype, u2.prototype.constructor = u2, tt.prototype = Sn($r.prototype), tt.prototype.constructor = tt;
      function Q2(e) {
        this.__wrapped__ = e, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = mt, this.__views__ = [];
      }
      function Gf2() {
        var e = new Q2(this.__wrapped__);
        return e.__actions__ = Ue2(this.__actions__), e.__dir__ = this.__dir__, e.__filtered__ = this.__filtered__, e.__iteratees__ = Ue2(this.__iteratees__), e.__takeCount__ = this.__takeCount__, e.__views__ = Ue2(this.__views__), e;
      }
      function zf2() {
        if (this.__filtered__) {
          var e = new Q2(this);
          e.__dir__ = -1, e.__filtered__ = true;
        } else
          e = this.clone(), e.__dir__ *= -1;
        return e;
      }
      function Zf2() {
        var e = this.__wrapped__.value(), t2 = this.__dir__, n2 = H2(e), i = t2 < 0, s = n2 ? e.length : 0, l2 = ih2(0, s, this.__views__), f2 = l2.start, h2 = l2.end, v2 = h2 - f2, b = i ? h2 : f2 - 1, C2 = this.__iteratees__, T2 = C2.length, O2 = 0, $ = Re2(v2, this.__takeCount__);
        if (!n2 || !i && s == v2 && $ == v2)
          return ga(e, this.__actions__);
        var D2 = [];
        e:
          for (; v2-- && O2 < $; ) {
            b += t2;
            for (var z2 = -1, M2 = e[b]; ++z2 < T2; ) {
              var J2 = C2[z2], j = J2.iteratee, Ke2 = J2.type, Me2 = j(M2);
              if (Ke2 == Nl)
                M2 = Me2;
              else if (!Me2) {
                if (Ke2 == Xo)
                  continue e;
                break e;
              }
            }
            D2[O2++] = M2;
          }
        return D2;
      }
      Q2.prototype = Sn($r.prototype), Q2.prototype.constructor = Q2;
      function en(e) {
        var t2 = -1, n2 = e == null ? 0 : e.length;
        for (this.clear(); ++t2 < n2; ) {
          var i = e[t2];
          this.set(i[0], i[1]);
        }
      }
      function qf2() {
        this.__data__ = Wn ? Wn(null) : {}, this.size = 0;
      }
      function Kf2(e) {
        var t2 = this.has(e) && delete this.__data__[e];
        return this.size -= t2 ? 1 : 0, t2;
      }
      function Yf2(e) {
        var t2 = this.__data__;
        if (Wn) {
          var n2 = t2[e];
          return n2 === S2 ? o : n2;
        }
        return ue2.call(t2, e) ? t2[e] : o;
      }
      function Xf2(e) {
        var t2 = this.__data__;
        return Wn ? t2[e] !== o : ue2.call(t2, e);
      }
      function Jf2(e, t2) {
        var n2 = this.__data__;
        return this.size += this.has(e) ? 0 : 1, n2[e] = Wn && t2 === o ? S2 : t2, this;
      }
      en.prototype.clear = qf2, en.prototype.delete = Kf2, en.prototype.get = Yf2, en.prototype.has = Xf2, en.prototype.set = Jf2;
      function kt(e) {
        var t2 = -1, n2 = e == null ? 0 : e.length;
        for (this.clear(); ++t2 < n2; ) {
          var i = e[t2];
          this.set(i[0], i[1]);
        }
      }
      function Qf2() {
        this.__data__ = [], this.size = 0;
      }
      function jf(e) {
        var t2 = this.__data__, n2 = Br(t2, e);
        if (n2 < 0)
          return false;
        var i = t2.length - 1;
        return n2 == i ? t2.pop() : Ir.call(t2, n2, 1), --this.size, true;
      }
      function ed2(e) {
        var t2 = this.__data__, n2 = Br(t2, e);
        return n2 < 0 ? o : t2[n2][1];
      }
      function td2(e) {
        return Br(this.__data__, e) > -1;
      }
      function nd2(e, t2) {
        var n2 = this.__data__, i = Br(n2, e);
        return i < 0 ? (++this.size, n2.push([e, t2])) : n2[i][1] = t2, this;
      }
      kt.prototype.clear = Qf2, kt.prototype.delete = jf, kt.prototype.get = ed2, kt.prototype.has = td2, kt.prototype.set = nd2;
      function It(e) {
        var t2 = -1, n2 = e == null ? 0 : e.length;
        for (this.clear(); ++t2 < n2; ) {
          var i = e[t2];
          this.set(i[0], i[1]);
        }
      }
      function rd2() {
        this.size = 0, this.__data__ = {
          hash: new en(),
          map: new (Un || kt)(),
          string: new en()
        };
      }
      function id2(e) {
        var t2 = Zr(this, e).delete(e);
        return this.size -= t2 ? 1 : 0, t2;
      }
      function od2(e) {
        return Zr(this, e).get(e);
      }
      function sd2(e) {
        return Zr(this, e).has(e);
      }
      function ad2(e, t2) {
        var n2 = Zr(this, e), i = n2.size;
        return n2.set(e, t2), this.size += n2.size == i ? 0 : 1, this;
      }
      It.prototype.clear = rd2, It.prototype.delete = id2, It.prototype.get = od2, It.prototype.has = sd2, It.prototype.set = ad2;
      function tn(e) {
        var t2 = -1, n2 = e == null ? 0 : e.length;
        for (this.__data__ = new It(); ++t2 < n2; )
          this.add(e[t2]);
      }
      function ud2(e) {
        return this.__data__.set(e, S2), this;
      }
      function ld2(e) {
        return this.__data__.has(e);
      }
      tn.prototype.add = tn.prototype.push = ud2, tn.prototype.has = ld2;
      function dt(e) {
        var t2 = this.__data__ = new kt(e);
        this.size = t2.size;
      }
      function cd2() {
        this.__data__ = new kt(), this.size = 0;
      }
      function fd2(e) {
        var t2 = this.__data__, n2 = t2.delete(e);
        return this.size = t2.size, n2;
      }
      function dd2(e) {
        return this.__data__.get(e);
      }
      function hd2(e) {
        return this.__data__.has(e);
      }
      function pd2(e, t2) {
        var n2 = this.__data__;
        if (n2 instanceof kt) {
          var i = n2.__data__;
          if (!Un || i.length < c - 1)
            return i.push([e, t2]), this.size = ++n2.size, this;
          n2 = this.__data__ = new It(i);
        }
        return n2.set(e, t2), this.size = n2.size, this;
      }
      dt.prototype.clear = cd2, dt.prototype.delete = fd2, dt.prototype.get = dd2, dt.prototype.has = hd2, dt.prototype.set = pd2;
      function qs(e, t2) {
        var n2 = H2(e), i = !n2 && an(e), s = !n2 && !i && Kt(e), l2 = !n2 && !i && !s && In(e), f2 = n2 || i || s || l2, h2 = f2 ? Pi2(e.length, Af2) : [], v2 = h2.length;
        for (var b in e)
          (t2 || ue2.call(e, b)) && !(f2 && // Safari 9 has enumerable `arguments.length` in strict mode.
          (b == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          s && (b == "offset" || b == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          l2 && (b == "buffer" || b == "byteLength" || b == "byteOffset") || // Skip index properties.
          Rt(b, v2))) && h2.push(b);
        return h2;
      }
      function Ks(e) {
        var t2 = e.length;
        return t2 ? e[Qi2(0, t2 - 1)] : o;
      }
      function vd2(e, t2) {
        return qr(Ue2(e), nn(t2, 0, e.length));
      }
      function gd2(e) {
        return qr(Ue2(e));
      }
      function Wi2(e, t2, n2) {
        (n2 !== o && !ht(e[t2], n2) || n2 === o && !(t2 in e)) && xt(e, t2, n2);
      }
      function Gn(e, t2, n2) {
        var i = e[t2];
        (!(ue2.call(e, t2) && ht(i, n2)) || n2 === o && !(t2 in e)) && xt(e, t2, n2);
      }
      function Br(e, t2) {
        for (var n2 = e.length; n2--; )
          if (ht(e[n2][0], t2))
            return n2;
        return -1;
      }
      function _d(e, t2, n2, i) {
        return Gt(e, function(s, l2, f2) {
          t2(i, s, n2(s), f2);
        }), i;
      }
      function Ys(e, t2) {
        return e && yt(t2, Ie2(t2), e);
      }
      function md2(e, t2) {
        return e && yt(t2, We2(t2), e);
      }
      function xt(e, t2, n2) {
        t2 == "__proto__" && xr ? xr(e, t2, {
          configurable: true,
          enumerable: true,
          value: n2,
          writable: true
        }) : e[t2] = n2;
      }
      function Hi2(e, t2) {
        for (var n2 = -1, i = t2.length, s = m2(i), l2 = e == null; ++n2 < i; )
          s[n2] = l2 ? o : Ao(e, t2[n2]);
        return s;
      }
      function nn(e, t2, n2) {
        return e === e && (n2 !== o && (e = e <= n2 ? e : n2), t2 !== o && (e = e >= t2 ? e : t2)), e;
      }
      function nt(e, t2, n2, i, s, l2) {
        var f2, h2 = t2 & V2, v2 = t2 & te2, b = t2 & se2;
        if (n2 && (f2 = s ? n2(e, i, s, l2) : n2(e)), f2 !== o)
          return f2;
        if (!_e(e))
          return e;
        var C2 = H2(e);
        if (C2) {
          if (f2 = sh2(e), !h2)
            return Ue2(e, f2);
        } else {
          var T2 = Le2(e), O2 = T2 == dr || T2 == Jo;
          if (Kt(e))
            return wa2(e, h2);
          if (T2 == Tt || T2 == hn || O2 && !s) {
            if (f2 = v2 || O2 ? {} : Fa2(e), !h2)
              return v2 ? Yd2(e, md2(f2, e)) : Kd2(e, Ys(f2, e));
          } else {
            if (!he2[T2])
              return s ? e : {};
            f2 = ah2(e, T2, h2);
          }
        }
        l2 || (l2 = new dt());
        var $ = l2.get(e);
        if ($)
          return $;
        l2.set(e, f2), hu(e) ? e.forEach(function(M2) {
          f2.add(nt(M2, t2, n2, M2, e, l2));
        }) : fu(e) && e.forEach(function(M2, J2) {
          f2.set(J2, nt(M2, t2, n2, J2, e, l2));
        });
        var D2 = b ? v2 ? lo : uo : v2 ? We2 : Ie2, z2 = C2 ? o : D2(e);
        return je2(z2 || e, function(M2, J2) {
          z2 && (J2 = M2, M2 = e[J2]), Gn(f2, J2, nt(M2, t2, n2, J2, e, l2));
        }), f2;
      }
      function wd2(e) {
        var t2 = Ie2(e);
        return function(n2) {
          return Xs(n2, e, t2);
        };
      }
      function Xs(e, t2, n2) {
        var i = n2.length;
        if (e == null)
          return !i;
        for (e = fe2(e); i--; ) {
          var s = n2[i], l2 = t2[s], f2 = e[s];
          if (f2 === o && !(s in e) || !l2(f2))
            return false;
        }
        return true;
      }
      function Js(e, t2, n2) {
        if (typeof e != "function")
          throw new et(_);
        return Jn(function() {
          e.apply(o, n2);
        }, t2);
      }
      function zn(e, t2, n2, i) {
        var s = -1, l2 = _r, f2 = true, h2 = e.length, v2 = [], b = t2.length;
        if (!h2)
          return v2;
        n2 && (t2 = ve2(t2, ze(n2))), i ? (l2 = Oi2, f2 = false) : t2.length >= c && (l2 = Fn, f2 = false, t2 = new tn(t2));
        e:
          for (; ++s < h2; ) {
            var C2 = e[s], T2 = n2 == null ? C2 : n2(C2);
            if (C2 = i || C2 !== 0 ? C2 : 0, f2 && T2 === T2) {
              for (var O2 = b; O2--; )
                if (t2[O2] === T2)
                  continue e;
              v2.push(C2);
            } else
              l2(t2, T2, i) || v2.push(C2);
          }
        return v2;
      }
      var Gt = Aa2(wt), Qs = Aa2(zi2, true);
      function yd2(e, t2) {
        var n2 = true;
        return Gt(e, function(i, s, l2) {
          return n2 = !!t2(i, s, l2), n2;
        }), n2;
      }
      function Pr(e, t2, n2) {
        for (var i = -1, s = e.length; ++i < s; ) {
          var l2 = e[i], f2 = t2(l2);
          if (f2 != null && (h2 === o ? f2 === f2 && !qe2(f2) : n2(f2, h2)))
            var h2 = f2, v2 = l2;
        }
        return v2;
      }
      function bd2(e, t2, n2, i) {
        var s = e.length;
        for (n2 = G2(n2), n2 < 0 && (n2 = -n2 > s ? 0 : s + n2), i = i === o || i > s ? s : G2(i), i < 0 && (i += s), i = n2 > i ? 0 : vu(i); n2 < i; )
          e[n2++] = t2;
        return e;
      }
      function js(e, t2) {
        var n2 = [];
        return Gt(e, function(i, s, l2) {
          t2(i, s, l2) && n2.push(i);
        }), n2;
      }
      function Oe2(e, t2, n2, i, s) {
        var l2 = -1, f2 = e.length;
        for (n2 || (n2 = lh2), s || (s = []); ++l2 < f2; ) {
          var h2 = e[l2];
          t2 > 0 && n2(h2) ? t2 > 1 ? Oe2(h2, t2 - 1, n2, i, s) : Vt(s, h2) : i || (s[s.length] = h2);
        }
        return s;
      }
      var Gi2 = Ta2(), ea2 = Ta2(true);
      function wt(e, t2) {
        return e && Gi2(e, t2, Ie2);
      }
      function zi2(e, t2) {
        return e && ea2(e, t2, Ie2);
      }
      function Dr(e, t2) {
        return Ut(t2, function(n2) {
          return Lt(e[n2]);
        });
      }
      function rn(e, t2) {
        t2 = Zt(t2, e);
        for (var n2 = 0, i = t2.length; e != null && n2 < i; )
          e = e[bt(t2[n2++])];
        return n2 && n2 == i ? e : o;
      }
      function ta2(e, t2, n2) {
        var i = t2(e);
        return H2(e) ? i : Vt(i, n2(e));
      }
      function Pe2(e) {
        return e == null ? e === o ? Yl : ql2 : jt && jt in fe2(e) ? rh2(e) : gh2(e);
      }
      function Zi2(e, t2) {
        return e > t2;
      }
      function Cd2(e, t2) {
        return e != null && ue2.call(e, t2);
      }
      function Sd2(e, t2) {
        return e != null && t2 in fe2(e);
      }
      function Ad2(e, t2, n2) {
        return e >= Re2(t2, n2) && e < ke2(t2, n2);
      }
      function qi2(e, t2, n2) {
        for (var i = n2 ? Oi2 : _r, s = e[0].length, l2 = e.length, f2 = l2, h2 = m2(l2), v2 = 1 / 0, b = []; f2--; ) {
          var C2 = e[f2];
          f2 && t2 && (C2 = ve2(C2, ze(t2))), v2 = Re2(C2.length, v2), h2[f2] = !n2 && (t2 || s >= 120 && C2.length >= 120) ? new tn(f2 && C2) : o;
        }
        C2 = e[0];
        var T2 = -1, O2 = h2[0];
        e:
          for (; ++T2 < s && b.length < v2; ) {
            var $ = C2[T2], D2 = t2 ? t2($) : $;
            if ($ = n2 || $ !== 0 ? $ : 0, !(O2 ? Fn(O2, D2) : i(b, D2, n2))) {
              for (f2 = l2; --f2; ) {
                var z2 = h2[f2];
                if (!(z2 ? Fn(z2, D2) : i(e[f2], D2, n2)))
                  continue e;
              }
              O2 && O2.push(D2), b.push($);
            }
          }
        return b;
      }
      function Td2(e, t2, n2, i) {
        return wt(e, function(s, l2, f2) {
          t2(i, n2(s), l2, f2);
        }), i;
      }
      function Zn(e, t2, n2) {
        t2 = Zt(t2, e), e = Wa2(e, t2);
        var i = e == null ? e : e[bt(it(t2))];
        return i == null ? o : Ge2(i, e, n2);
      }
      function na(e) {
        return ye(e) && Pe2(e) == hn;
      }
      function kd2(e) {
        return ye(e) && Pe2(e) == Mn;
      }
      function Id2(e) {
        return ye(e) && Pe2(e) == Ln;
      }
      function qn(e, t2, n2, i, s) {
        return e === t2 ? true : e == null || t2 == null || !ye(e) && !ye(t2) ? e !== e && t2 !== t2 : xd2(e, t2, n2, i, qn, s);
      }
      function xd2(e, t2, n2, i, s, l2) {
        var f2 = H2(e), h2 = H2(t2), v2 = f2 ? cr : Le2(e), b = h2 ? cr : Le2(t2);
        v2 = v2 == hn ? Tt : v2, b = b == hn ? Tt : b;
        var C2 = v2 == Tt, T2 = b == Tt, O2 = v2 == b;
        if (O2 && Kt(e)) {
          if (!Kt(t2))
            return false;
          f2 = true, C2 = false;
        }
        if (O2 && !C2)
          return l2 || (l2 = new dt()), f2 || In(e) ? Pa2(e, t2, n2, i, s, l2) : th2(e, t2, v2, n2, i, s, l2);
        if (!(n2 & B2)) {
          var $ = C2 && ue2.call(e, "__wrapped__"), D2 = T2 && ue2.call(t2, "__wrapped__");
          if ($ || D2) {
            var z2 = $ ? e.value() : e, M2 = D2 ? t2.value() : t2;
            return l2 || (l2 = new dt()), s(z2, M2, n2, i, l2);
          }
        }
        return O2 ? (l2 || (l2 = new dt()), nh2(e, t2, n2, i, s, l2)) : false;
      }
      function Od2(e) {
        return ye(e) && Le2(e) == lt;
      }
      function Ki2(e, t2, n2, i) {
        var s = n2.length, l2 = s, f2 = !i;
        if (e == null)
          return !l2;
        for (e = fe2(e); s--; ) {
          var h2 = n2[s];
          if (f2 && h2[2] ? h2[1] !== e[h2[0]] : !(h2[0] in e))
            return false;
        }
        for (; ++s < l2; ) {
          h2 = n2[s];
          var v2 = h2[0], b = e[v2], C2 = h2[1];
          if (f2 && h2[2]) {
            if (b === o && !(v2 in e))
              return false;
          } else {
            var T2 = new dt();
            if (i)
              var O2 = i(b, C2, v2, e, t2, T2);
            if (!(O2 === o ? qn(C2, b, B2 | ne2, i, T2) : O2))
              return false;
          }
        }
        return true;
      }
      function ra2(e) {
        if (!_e(e) || fh2(e))
          return false;
        var t2 = Lt(e) ? Of2 : mc2;
        return t2.test(sn(e));
      }
      function Ed2(e) {
        return ye(e) && Pe2(e) == Bn;
      }
      function Rd2(e) {
        return ye(e) && Le2(e) == ct;
      }
      function Ld2(e) {
        return ye(e) && jr(e.length) && !!pe2[Pe2(e)];
      }
      function ia2(e) {
        return typeof e == "function" ? e : e == null ? He2 : typeof e == "object" ? H2(e) ? aa2(e[0], e[1]) : sa2(e) : ku(e);
      }
      function Yi2(e) {
        if (!Xn(e))
          return Pf2(e);
        var t2 = [];
        for (var n2 in fe2(e))
          ue2.call(e, n2) && n2 != "constructor" && t2.push(n2);
        return t2;
      }
      function $d2(e) {
        if (!_e(e))
          return vh2(e);
        var t2 = Xn(e), n2 = [];
        for (var i in e)
          i == "constructor" && (t2 || !ue2.call(e, i)) || n2.push(i);
        return n2;
      }
      function Xi2(e, t2) {
        return e < t2;
      }
      function oa2(e, t2) {
        var n2 = -1, i = Ve2(e) ? m2(e.length) : [];
        return Gt(e, function(s, l2, f2) {
          i[++n2] = t2(s, l2, f2);
        }), i;
      }
      function sa2(e) {
        var t2 = fo(e);
        return t2.length == 1 && t2[0][2] ? Ua2(t2[0][0], t2[0][1]) : function(n2) {
          return n2 === e || Ki2(n2, e, t2);
        };
      }
      function aa2(e, t2) {
        return po(e) && Na2(t2) ? Ua2(bt(e), t2) : function(n2) {
          var i = Ao(n2, e);
          return i === o && i === t2 ? To(n2, e) : qn(t2, i, B2 | ne2);
        };
      }
      function Mr(e, t2, n2, i, s) {
        e !== t2 && Gi2(t2, function(l2, f2) {
          if (s || (s = new dt()), _e(l2))
            Bd2(e, t2, f2, n2, Mr, i, s);
          else {
            var h2 = i ? i(go(e, f2), l2, f2 + "", e, t2, s) : o;
            h2 === o && (h2 = l2), Wi2(e, f2, h2);
          }
        }, We2);
      }
      function Bd2(e, t2, n2, i, s, l2, f2) {
        var h2 = go(e, n2), v2 = go(t2, n2), b = f2.get(v2);
        if (b) {
          Wi2(e, n2, b);
          return;
        }
        var C2 = l2 ? l2(h2, v2, n2 + "", e, t2, f2) : o, T2 = C2 === o;
        if (T2) {
          var O2 = H2(v2), $ = !O2 && Kt(v2), D2 = !O2 && !$ && In(v2);
          C2 = v2, O2 || $ || D2 ? H2(h2) ? C2 = h2 : Ce2(h2) ? C2 = Ue2(h2) : $ ? (T2 = false, C2 = wa2(v2, true)) : D2 ? (T2 = false, C2 = ya2(v2, true)) : C2 = [] : Qn(v2) || an(v2) ? (C2 = h2, an(h2) ? C2 = gu(h2) : (!_e(h2) || Lt(h2)) && (C2 = Fa2(v2))) : T2 = false;
        }
        T2 && (f2.set(v2, C2), s(C2, v2, i, l2, f2), f2.delete(v2)), Wi2(e, n2, C2);
      }
      function ua2(e, t2) {
        var n2 = e.length;
        if (n2)
          return t2 += t2 < 0 ? n2 : 0, Rt(t2, n2) ? e[t2] : o;
      }
      function la2(e, t2, n2) {
        t2.length ? t2 = ve2(t2, function(l2) {
          return H2(l2) ? function(f2) {
            return rn(f2, l2.length === 1 ? l2[0] : l2);
          } : l2;
        }) : t2 = [He2];
        var i = -1;
        t2 = ve2(t2, ze(P2()));
        var s = oa2(e, function(l2, f2, h2) {
          var v2 = ve2(t2, function(b) {
            return b(l2);
          });
          return { criteria: v2, index: ++i, value: l2 };
        });
        return af2(s, function(l2, f2) {
          return qd2(l2, f2, n2);
        });
      }
      function Pd2(e, t2) {
        return ca2(e, t2, function(n2, i) {
          return To(e, i);
        });
      }
      function ca2(e, t2, n2) {
        for (var i = -1, s = t2.length, l2 = {}; ++i < s; ) {
          var f2 = t2[i], h2 = rn(e, f2);
          n2(h2, f2) && Kn(l2, Zt(f2, e), h2);
        }
        return l2;
      }
      function Dd2(e) {
        return function(t2) {
          return rn(t2, e);
        };
      }
      function Ji2(e, t2, n2, i) {
        var s = i ? sf2 : gn, l2 = -1, f2 = t2.length, h2 = e;
        for (e === t2 && (t2 = Ue2(t2)), n2 && (h2 = ve2(e, ze(n2))); ++l2 < f2; )
          for (var v2 = 0, b = t2[l2], C2 = n2 ? n2(b) : b; (v2 = s(h2, C2, v2, i)) > -1; )
            h2 !== e && Ir.call(h2, v2, 1), Ir.call(e, v2, 1);
        return e;
      }
      function fa2(e, t2) {
        for (var n2 = e ? t2.length : 0, i = n2 - 1; n2--; ) {
          var s = t2[n2];
          if (n2 == i || s !== l2) {
            var l2 = s;
            Rt(s) ? Ir.call(e, s, 1) : to(e, s);
          }
        }
        return e;
      }
      function Qi2(e, t2) {
        return e + Er(zs() * (t2 - e + 1));
      }
      function Md2(e, t2, n2, i) {
        for (var s = -1, l2 = ke2(Or((t2 - e) / (n2 || 1)), 0), f2 = m2(l2); l2--; )
          f2[i ? l2 : ++s] = e, e += n2;
        return f2;
      }
      function ji2(e, t2) {
        var n2 = "";
        if (!e || t2 < 1 || t2 > Nt)
          return n2;
        do
          t2 % 2 && (n2 += e), t2 = Er(t2 / 2), t2 && (e += e);
        while (t2);
        return n2;
      }
      function K2(e, t2) {
        return _o(Va2(e, t2, He2), e + "");
      }
      function Fd2(e) {
        return Ks(xn(e));
      }
      function Nd2(e, t2) {
        var n2 = xn(e);
        return qr(n2, nn(t2, 0, n2.length));
      }
      function Kn(e, t2, n2, i) {
        if (!_e(e))
          return e;
        t2 = Zt(t2, e);
        for (var s = -1, l2 = t2.length, f2 = l2 - 1, h2 = e; h2 != null && ++s < l2; ) {
          var v2 = bt(t2[s]), b = n2;
          if (v2 === "__proto__" || v2 === "constructor" || v2 === "prototype")
            return e;
          if (s != f2) {
            var C2 = h2[v2];
            b = i ? i(C2, v2, h2) : o, b === o && (b = _e(C2) ? C2 : Rt(t2[s + 1]) ? [] : {});
          }
          Gn(h2, v2, b), h2 = h2[v2];
        }
        return e;
      }
      var da2 = Rr ? function(e, t2) {
        return Rr.set(e, t2), e;
      } : He2, Ud2 = xr ? function(e, t2) {
        return xr(e, "toString", {
          configurable: true,
          enumerable: false,
          value: Io(t2),
          writable: true
        });
      } : He2;
      function Vd2(e) {
        return qr(xn(e));
      }
      function rt(e, t2, n2) {
        var i = -1, s = e.length;
        t2 < 0 && (t2 = -t2 > s ? 0 : s + t2), n2 = n2 > s ? s : n2, n2 < 0 && (n2 += s), s = t2 > n2 ? 0 : n2 - t2 >>> 0, t2 >>>= 0;
        for (var l2 = m2(s); ++i < s; )
          l2[i] = e[i + t2];
        return l2;
      }
      function Wd2(e, t2) {
        var n2;
        return Gt(e, function(i, s, l2) {
          return n2 = t2(i, s, l2), !n2;
        }), !!n2;
      }
      function Fr(e, t2, n2) {
        var i = 0, s = e == null ? i : e.length;
        if (typeof t2 == "number" && t2 === t2 && s <= Hl) {
          for (; i < s; ) {
            var l2 = i + s >>> 1, f2 = e[l2];
            f2 !== null && !qe2(f2) && (n2 ? f2 <= t2 : f2 < t2) ? i = l2 + 1 : s = l2;
          }
          return s;
        }
        return eo(e, t2, He2, n2);
      }
      function eo(e, t2, n2, i) {
        var s = 0, l2 = e == null ? 0 : e.length;
        if (l2 === 0)
          return 0;
        t2 = n2(t2);
        for (var f2 = t2 !== t2, h2 = t2 === null, v2 = qe2(t2), b = t2 === o; s < l2; ) {
          var C2 = Er((s + l2) / 2), T2 = n2(e[C2]), O2 = T2 !== o, $ = T2 === null, D2 = T2 === T2, z2 = qe2(T2);
          if (f2)
            var M2 = i || D2;
          else
            b ? M2 = D2 && (i || O2) : h2 ? M2 = D2 && O2 && (i || !$) : v2 ? M2 = D2 && O2 && !$ && (i || !z2) : $ || z2 ? M2 = false : M2 = i ? T2 <= t2 : T2 < t2;
          M2 ? s = C2 + 1 : l2 = C2;
        }
        return Re2(l2, Wl);
      }
      function ha2(e, t2) {
        for (var n2 = -1, i = e.length, s = 0, l2 = []; ++n2 < i; ) {
          var f2 = e[n2], h2 = t2 ? t2(f2) : f2;
          if (!n2 || !ht(h2, v2)) {
            var v2 = h2;
            l2[s++] = f2 === 0 ? 0 : f2;
          }
        }
        return l2;
      }
      function pa2(e) {
        return typeof e == "number" ? e : qe2(e) ? lr : +e;
      }
      function Ze2(e) {
        if (typeof e == "string")
          return e;
        if (H2(e))
          return ve2(e, Ze2) + "";
        if (qe2(e))
          return Zs ? Zs.call(e) : "";
        var t2 = e + "";
        return t2 == "0" && 1 / e == -Jt ? "-0" : t2;
      }
      function zt(e, t2, n2) {
        var i = -1, s = _r, l2 = e.length, f2 = true, h2 = [], v2 = h2;
        if (n2)
          f2 = false, s = Oi2;
        else if (l2 >= c) {
          var b = t2 ? null : jd2(e);
          if (b)
            return wr(b);
          f2 = false, s = Fn, v2 = new tn();
        } else
          v2 = t2 ? [] : h2;
        e:
          for (; ++i < l2; ) {
            var C2 = e[i], T2 = t2 ? t2(C2) : C2;
            if (C2 = n2 || C2 !== 0 ? C2 : 0, f2 && T2 === T2) {
              for (var O2 = v2.length; O2--; )
                if (v2[O2] === T2)
                  continue e;
              t2 && v2.push(T2), h2.push(C2);
            } else
              s(v2, T2, n2) || (v2 !== h2 && v2.push(T2), h2.push(C2));
          }
        return h2;
      }
      function to(e, t2) {
        return t2 = Zt(t2, e), e = Wa2(e, t2), e == null || delete e[bt(it(t2))];
      }
      function va2(e, t2, n2, i) {
        return Kn(e, t2, n2(rn(e, t2)), i);
      }
      function Nr(e, t2, n2, i) {
        for (var s = e.length, l2 = i ? s : -1; (i ? l2-- : ++l2 < s) && t2(e[l2], l2, e); )
          ;
        return n2 ? rt(e, i ? 0 : l2, i ? l2 + 1 : s) : rt(e, i ? l2 + 1 : 0, i ? s : l2);
      }
      function ga(e, t2) {
        var n2 = e;
        return n2 instanceof Q2 && (n2 = n2.value()), Ei2(t2, function(i, s) {
          return s.func.apply(s.thisArg, Vt([i], s.args));
        }, n2);
      }
      function no(e, t2, n2) {
        var i = e.length;
        if (i < 2)
          return i ? zt(e[0]) : [];
        for (var s = -1, l2 = m2(i); ++s < i; )
          for (var f2 = e[s], h2 = -1; ++h2 < i; )
            h2 != s && (l2[s] = zn(l2[s] || f2, e[h2], t2, n2));
        return zt(Oe2(l2, 1), t2, n2);
      }
      function _a(e, t2, n2) {
        for (var i = -1, s = e.length, l2 = t2.length, f2 = {}; ++i < s; ) {
          var h2 = i < l2 ? t2[i] : o;
          n2(f2, e[i], h2);
        }
        return f2;
      }
      function ro(e) {
        return Ce2(e) ? e : [];
      }
      function io(e) {
        return typeof e == "function" ? e : He2;
      }
      function Zt(e, t2) {
        return H2(e) ? e : po(e, t2) ? [e] : Za2(ae2(e));
      }
      var Hd2 = K2;
      function qt(e, t2, n2) {
        var i = e.length;
        return n2 = n2 === o ? i : n2, !t2 && n2 >= i ? e : rt(e, t2, n2);
      }
      var ma2 = Ef2 || function(e) {
        return xe.clearTimeout(e);
      };
      function wa2(e, t2) {
        if (t2)
          return e.slice();
        var n2 = e.length, i = Us ? Us(n2) : new e.constructor(n2);
        return e.copy(i), i;
      }
      function oo(e) {
        var t2 = new e.constructor(e.byteLength);
        return new Tr(t2).set(new Tr(e)), t2;
      }
      function Gd2(e, t2) {
        var n2 = t2 ? oo(e.buffer) : e.buffer;
        return new e.constructor(n2, e.byteOffset, e.byteLength);
      }
      function zd2(e) {
        var t2 = new e.constructor(e.source, ns.exec(e));
        return t2.lastIndex = e.lastIndex, t2;
      }
      function Zd2(e) {
        return Hn ? fe2(Hn.call(e)) : {};
      }
      function ya2(e, t2) {
        var n2 = t2 ? oo(e.buffer) : e.buffer;
        return new e.constructor(n2, e.byteOffset, e.length);
      }
      function ba(e, t2) {
        if (e !== t2) {
          var n2 = e !== o, i = e === null, s = e === e, l2 = qe2(e), f2 = t2 !== o, h2 = t2 === null, v2 = t2 === t2, b = qe2(t2);
          if (!h2 && !b && !l2 && e > t2 || l2 && f2 && v2 && !h2 && !b || i && f2 && v2 || !n2 && v2 || !s)
            return 1;
          if (!i && !l2 && !b && e < t2 || b && n2 && s && !i && !l2 || h2 && n2 && s || !f2 && s || !v2)
            return -1;
        }
        return 0;
      }
      function qd2(e, t2, n2) {
        for (var i = -1, s = e.criteria, l2 = t2.criteria, f2 = s.length, h2 = n2.length; ++i < f2; ) {
          var v2 = ba(s[i], l2[i]);
          if (v2) {
            if (i >= h2)
              return v2;
            var b = n2[i];
            return v2 * (b == "desc" ? -1 : 1);
          }
        }
        return e.index - t2.index;
      }
      function Ca2(e, t2, n2, i) {
        for (var s = -1, l2 = e.length, f2 = n2.length, h2 = -1, v2 = t2.length, b = ke2(l2 - f2, 0), C2 = m2(v2 + b), T2 = !i; ++h2 < v2; )
          C2[h2] = t2[h2];
        for (; ++s < f2; )
          (T2 || s < l2) && (C2[n2[s]] = e[s]);
        for (; b--; )
          C2[h2++] = e[s++];
        return C2;
      }
      function Sa2(e, t2, n2, i) {
        for (var s = -1, l2 = e.length, f2 = -1, h2 = n2.length, v2 = -1, b = t2.length, C2 = ke2(l2 - h2, 0), T2 = m2(C2 + b), O2 = !i; ++s < C2; )
          T2[s] = e[s];
        for (var $ = s; ++v2 < b; )
          T2[$ + v2] = t2[v2];
        for (; ++f2 < h2; )
          (O2 || s < l2) && (T2[$ + n2[f2]] = e[s++]);
        return T2;
      }
      function Ue2(e, t2) {
        var n2 = -1, i = e.length;
        for (t2 || (t2 = m2(i)); ++n2 < i; )
          t2[n2] = e[n2];
        return t2;
      }
      function yt(e, t2, n2, i) {
        var s = !n2;
        n2 || (n2 = {});
        for (var l2 = -1, f2 = t2.length; ++l2 < f2; ) {
          var h2 = t2[l2], v2 = i ? i(n2[h2], e[h2], h2, n2, e) : o;
          v2 === o && (v2 = e[h2]), s ? xt(n2, h2, v2) : Gn(n2, h2, v2);
        }
        return n2;
      }
      function Kd2(e, t2) {
        return yt(e, ho(e), t2);
      }
      function Yd2(e, t2) {
        return yt(e, Da2(e), t2);
      }
      function Ur(e, t2) {
        return function(n2, i) {
          var s = H2(n2) ? jc2 : _d, l2 = t2 ? t2() : {};
          return s(n2, e, P2(i, 2), l2);
        };
      }
      function An(e) {
        return K2(function(t2, n2) {
          var i = -1, s = n2.length, l2 = s > 1 ? n2[s - 1] : o, f2 = s > 2 ? n2[2] : o;
          for (l2 = e.length > 3 && typeof l2 == "function" ? (s--, l2) : o, f2 && De2(n2[0], n2[1], f2) && (l2 = s < 3 ? o : l2, s = 1), t2 = fe2(t2); ++i < s; ) {
            var h2 = n2[i];
            h2 && e(t2, h2, i, l2);
          }
          return t2;
        });
      }
      function Aa2(e, t2) {
        return function(n2, i) {
          if (n2 == null)
            return n2;
          if (!Ve2(n2))
            return e(n2, i);
          for (var s = n2.length, l2 = t2 ? s : -1, f2 = fe2(n2); (t2 ? l2-- : ++l2 < s) && i(f2[l2], l2, f2) !== false; )
            ;
          return n2;
        };
      }
      function Ta2(e) {
        return function(t2, n2, i) {
          for (var s = -1, l2 = fe2(t2), f2 = i(t2), h2 = f2.length; h2--; ) {
            var v2 = f2[e ? h2 : ++s];
            if (n2(l2[v2], v2, l2) === false)
              break;
          }
          return t2;
        };
      }
      function Xd2(e, t2, n2) {
        var i = t2 & E2, s = Yn(e);
        function l2() {
          var f2 = this && this !== xe && this instanceof l2 ? s : e;
          return f2.apply(i ? n2 : this, arguments);
        }
        return l2;
      }
      function ka2(e) {
        return function(t2) {
          t2 = ae2(t2);
          var n2 = _n(t2) ? ft(t2) : o, i = n2 ? n2[0] : t2.charAt(0), s = n2 ? qt(n2, 1).join("") : t2.slice(1);
          return i[e]() + s;
        };
      }
      function Tn(e) {
        return function(t2) {
          return Ei2(Au(Su(t2).replace(Nc2, "")), e, "");
        };
      }
      function Yn(e) {
        return function() {
          var t2 = arguments;
          switch (t2.length) {
            case 0:
              return new e();
            case 1:
              return new e(t2[0]);
            case 2:
              return new e(t2[0], t2[1]);
            case 3:
              return new e(t2[0], t2[1], t2[2]);
            case 4:
              return new e(t2[0], t2[1], t2[2], t2[3]);
            case 5:
              return new e(t2[0], t2[1], t2[2], t2[3], t2[4]);
            case 6:
              return new e(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
            case 7:
              return new e(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]);
          }
          var n2 = Sn(e.prototype), i = e.apply(n2, t2);
          return _e(i) ? i : n2;
        };
      }
      function Jd2(e, t2, n2) {
        var i = Yn(e);
        function s() {
          for (var l2 = arguments.length, f2 = m2(l2), h2 = l2, v2 = kn(s); h2--; )
            f2[h2] = arguments[h2];
          var b = l2 < 3 && f2[0] !== v2 && f2[l2 - 1] !== v2 ? [] : Wt(f2, v2);
          if (l2 -= b.length, l2 < n2)
            return Ra2(
              e,
              t2,
              Vr,
              s.placeholder,
              o,
              f2,
              b,
              o,
              o,
              n2 - l2
            );
          var C2 = this && this !== xe && this instanceof s ? i : e;
          return Ge2(C2, this, f2);
        }
        return s;
      }
      function Ia2(e) {
        return function(t2, n2, i) {
          var s = fe2(t2);
          if (!Ve2(t2)) {
            var l2 = P2(n2, 3);
            t2 = Ie2(t2), n2 = function(h2) {
              return l2(s[h2], h2, s);
            };
          }
          var f2 = e(t2, n2, i);
          return f2 > -1 ? s[l2 ? t2[f2] : f2] : o;
        };
      }
      function xa(e) {
        return Et(function(t2) {
          var n2 = t2.length, i = n2, s = tt.prototype.thru;
          for (e && t2.reverse(); i--; ) {
            var l2 = t2[i];
            if (typeof l2 != "function")
              throw new et(_);
            if (s && !f2 && zr(l2) == "wrapper")
              var f2 = new tt([], true);
          }
          for (i = f2 ? i : n2; ++i < n2; ) {
            l2 = t2[i];
            var h2 = zr(l2), v2 = h2 == "wrapper" ? co(l2) : o;
            v2 && vo(v2[0]) && v2[1] == (ge2 | N2 | x2 | Ne2) && !v2[4].length && v2[9] == 1 ? f2 = f2[zr(v2[0])].apply(f2, v2[3]) : f2 = l2.length == 1 && vo(l2) ? f2[h2]() : f2.thru(l2);
          }
          return function() {
            var b = arguments, C2 = b[0];
            if (f2 && b.length == 1 && H2(C2))
              return f2.plant(C2).value();
            for (var T2 = 0, O2 = n2 ? t2[T2].apply(this, b) : C2; ++T2 < n2; )
              O2 = t2[T2].call(this, O2);
            return O2;
          };
        });
      }
      function Vr(e, t2, n2, i, s, l2, f2, h2, v2, b) {
        var C2 = t2 & ge2, T2 = t2 & E2, O2 = t2 & Z2, $ = t2 & (N2 | X2), D2 = t2 & Ft, z2 = O2 ? o : Yn(e);
        function M2() {
          for (var J2 = arguments.length, j = m2(J2), Ke2 = J2; Ke2--; )
            j[Ke2] = arguments[Ke2];
          if ($)
            var Me2 = kn(M2), Ye2 = lf2(j, Me2);
          if (i && (j = Ca2(j, i, s, $)), l2 && (j = Sa2(j, l2, f2, $)), J2 -= Ye2, $ && J2 < b) {
            var Se2 = Wt(j, Me2);
            return Ra2(
              e,
              t2,
              Vr,
              M2.placeholder,
              n2,
              j,
              Se2,
              h2,
              v2,
              b - J2
            );
          }
          var pt = T2 ? n2 : this, Bt = O2 ? pt[e] : e;
          return J2 = j.length, h2 ? j = _h(j, h2) : D2 && J2 > 1 && j.reverse(), C2 && v2 < J2 && (j.length = v2), this && this !== xe && this instanceof M2 && (Bt = z2 || Yn(Bt)), Bt.apply(pt, j);
        }
        return M2;
      }
      function Oa2(e, t2) {
        return function(n2, i) {
          return Td2(n2, e, t2(i), {});
        };
      }
      function Wr(e, t2) {
        return function(n2, i) {
          var s;
          if (n2 === o && i === o)
            return t2;
          if (n2 !== o && (s = n2), i !== o) {
            if (s === o)
              return i;
            typeof n2 == "string" || typeof i == "string" ? (n2 = Ze2(n2), i = Ze2(i)) : (n2 = pa2(n2), i = pa2(i)), s = e(n2, i);
          }
          return s;
        };
      }
      function so(e) {
        return Et(function(t2) {
          return t2 = ve2(t2, ze(P2())), K2(function(n2) {
            var i = this;
            return e(t2, function(s) {
              return Ge2(s, i, n2);
            });
          });
        });
      }
      function Hr(e, t2) {
        t2 = t2 === o ? " " : Ze2(t2);
        var n2 = t2.length;
        if (n2 < 2)
          return n2 ? ji2(t2, e) : t2;
        var i = ji2(t2, Or(e / mn(t2)));
        return _n(t2) ? qt(ft(i), 0, e).join("") : i.slice(0, e);
      }
      function Qd2(e, t2, n2, i) {
        var s = t2 & E2, l2 = Yn(e);
        function f2() {
          for (var h2 = -1, v2 = arguments.length, b = -1, C2 = i.length, T2 = m2(C2 + v2), O2 = this && this !== xe && this instanceof f2 ? l2 : e; ++b < C2; )
            T2[b] = i[b];
          for (; v2--; )
            T2[b++] = arguments[++h2];
          return Ge2(O2, s ? n2 : this, T2);
        }
        return f2;
      }
      function Ea2(e) {
        return function(t2, n2, i) {
          return i && typeof i != "number" && De2(t2, n2, i) && (n2 = i = o), t2 = $t(t2), n2 === o ? (n2 = t2, t2 = 0) : n2 = $t(n2), i = i === o ? t2 < n2 ? 1 : -1 : $t(i), Md2(t2, n2, i, e);
        };
      }
      function Gr(e) {
        return function(t2, n2) {
          return typeof t2 == "string" && typeof n2 == "string" || (t2 = ot(t2), n2 = ot(n2)), e(t2, n2);
        };
      }
      function Ra2(e, t2, n2, i, s, l2, f2, h2, v2, b) {
        var C2 = t2 & N2, T2 = C2 ? f2 : o, O2 = C2 ? o : f2, $ = C2 ? l2 : o, D2 = C2 ? o : l2;
        t2 |= C2 ? x2 : q2, t2 &= ~(C2 ? q2 : x2), t2 & U2 || (t2 &= ~(E2 | Z2));
        var z2 = [
          e,
          t2,
          s,
          $,
          T2,
          D2,
          O2,
          h2,
          v2,
          b
        ], M2 = n2.apply(o, z2);
        return vo(e) && Ha2(M2, z2), M2.placeholder = i, Ga2(M2, e, t2);
      }
      function ao(e) {
        var t2 = Te2[e];
        return function(n2, i) {
          if (n2 = ot(n2), i = i == null ? 0 : Re2(G2(i), 292), i && Gs(n2)) {
            var s = (ae2(n2) + "e").split("e"), l2 = t2(s[0] + "e" + (+s[1] + i));
            return s = (ae2(l2) + "e").split("e"), +(s[0] + "e" + (+s[1] - i));
          }
          return t2(n2);
        };
      }
      var jd2 = bn && 1 / wr(new bn([, -0]))[1] == Jt ? function(e) {
        return new bn(e);
      } : Eo;
      function La2(e) {
        return function(t2) {
          var n2 = Le2(t2);
          return n2 == lt ? Mi2(t2) : n2 == ct ? gf(t2) : uf2(t2, e(t2));
        };
      }
      function Ot(e, t2, n2, i, s, l2, f2, h2) {
        var v2 = t2 & Z2;
        if (!v2 && typeof e != "function")
          throw new et(_);
        var b = i ? i.length : 0;
        if (b || (t2 &= ~(x2 | q2), i = s = o), f2 = f2 === o ? f2 : ke2(G2(f2), 0), h2 = h2 === o ? h2 : G2(h2), b -= s ? s.length : 0, t2 & q2) {
          var C2 = i, T2 = s;
          i = s = o;
        }
        var O2 = v2 ? o : co(e), $ = [
          e,
          t2,
          n2,
          i,
          s,
          C2,
          T2,
          l2,
          f2,
          h2
        ];
        if (O2 && ph2($, O2), e = $[0], t2 = $[1], n2 = $[2], i = $[3], s = $[4], h2 = $[9] = $[9] === o ? v2 ? 0 : e.length : ke2($[9] - b, 0), !h2 && t2 & (N2 | X2) && (t2 &= ~(N2 | X2)), !t2 || t2 == E2)
          var D2 = Xd2(e, t2, n2);
        else
          t2 == N2 || t2 == X2 ? D2 = Jd2(e, t2, h2) : (t2 == x2 || t2 == (E2 | x2)) && !s.length ? D2 = Qd2(e, t2, n2, i) : D2 = Vr.apply(o, $);
        var z2 = O2 ? da2 : Ha2;
        return Ga2(z2(D2, $), e, t2);
      }
      function $a(e, t2, n2, i) {
        return e === o || ht(e, yn[n2]) && !ue2.call(i, n2) ? t2 : e;
      }
      function Ba2(e, t2, n2, i, s, l2) {
        return _e(e) && _e(t2) && (l2.set(t2, e), Mr(e, t2, o, Ba2, l2), l2.delete(t2)), e;
      }
      function eh2(e) {
        return Qn(e) ? o : e;
      }
      function Pa2(e, t2, n2, i, s, l2) {
        var f2 = n2 & B2, h2 = e.length, v2 = t2.length;
        if (h2 != v2 && !(f2 && v2 > h2))
          return false;
        var b = l2.get(e), C2 = l2.get(t2);
        if (b && C2)
          return b == t2 && C2 == e;
        var T2 = -1, O2 = true, $ = n2 & ne2 ? new tn() : o;
        for (l2.set(e, t2), l2.set(t2, e); ++T2 < h2; ) {
          var D2 = e[T2], z2 = t2[T2];
          if (i)
            var M2 = f2 ? i(z2, D2, T2, t2, e, l2) : i(D2, z2, T2, e, t2, l2);
          if (M2 !== o) {
            if (M2)
              continue;
            O2 = false;
            break;
          }
          if ($) {
            if (!Ri2(t2, function(J2, j) {
              if (!Fn($, j) && (D2 === J2 || s(D2, J2, n2, i, l2)))
                return $.push(j);
            })) {
              O2 = false;
              break;
            }
          } else if (!(D2 === z2 || s(D2, z2, n2, i, l2))) {
            O2 = false;
            break;
          }
        }
        return l2.delete(e), l2.delete(t2), O2;
      }
      function th2(e, t2, n2, i, s, l2, f2) {
        switch (n2) {
          case pn:
            if (e.byteLength != t2.byteLength || e.byteOffset != t2.byteOffset)
              return false;
            e = e.buffer, t2 = t2.buffer;
          case Mn:
            return !(e.byteLength != t2.byteLength || !l2(new Tr(e), new Tr(t2)));
          case Rn:
          case Ln:
          case $n:
            return ht(+e, +t2);
          case fr:
            return e.name == t2.name && e.message == t2.message;
          case Bn:
          case Pn:
            return e == t2 + "";
          case lt:
            var h2 = Mi2;
          case ct:
            var v2 = i & B2;
            if (h2 || (h2 = wr), e.size != t2.size && !v2)
              return false;
            var b = f2.get(e);
            if (b)
              return b == t2;
            i |= ne2, f2.set(e, t2);
            var C2 = Pa2(h2(e), h2(t2), i, s, l2, f2);
            return f2.delete(e), C2;
          case hr:
            if (Hn)
              return Hn.call(e) == Hn.call(t2);
        }
        return false;
      }
      function nh2(e, t2, n2, i, s, l2) {
        var f2 = n2 & B2, h2 = uo(e), v2 = h2.length, b = uo(t2), C2 = b.length;
        if (v2 != C2 && !f2)
          return false;
        for (var T2 = v2; T2--; ) {
          var O2 = h2[T2];
          if (!(f2 ? O2 in t2 : ue2.call(t2, O2)))
            return false;
        }
        var $ = l2.get(e), D2 = l2.get(t2);
        if ($ && D2)
          return $ == t2 && D2 == e;
        var z2 = true;
        l2.set(e, t2), l2.set(t2, e);
        for (var M2 = f2; ++T2 < v2; ) {
          O2 = h2[T2];
          var J2 = e[O2], j = t2[O2];
          if (i)
            var Ke2 = f2 ? i(j, J2, O2, t2, e, l2) : i(J2, j, O2, e, t2, l2);
          if (!(Ke2 === o ? J2 === j || s(J2, j, n2, i, l2) : Ke2)) {
            z2 = false;
            break;
          }
          M2 || (M2 = O2 == "constructor");
        }
        if (z2 && !M2) {
          var Me2 = e.constructor, Ye2 = t2.constructor;
          Me2 != Ye2 && "constructor" in e && "constructor" in t2 && !(typeof Me2 == "function" && Me2 instanceof Me2 && typeof Ye2 == "function" && Ye2 instanceof Ye2) && (z2 = false);
        }
        return l2.delete(e), l2.delete(t2), z2;
      }
      function Et(e) {
        return _o(Va2(e, o, Xa2), e + "");
      }
      function uo(e) {
        return ta2(e, Ie2, ho);
      }
      function lo(e) {
        return ta2(e, We2, Da2);
      }
      var co = Rr ? function(e) {
        return Rr.get(e);
      } : Eo;
      function zr(e) {
        for (var t2 = e.name + "", n2 = Cn[t2], i = ue2.call(Cn, t2) ? n2.length : 0; i--; ) {
          var s = n2[i], l2 = s.func;
          if (l2 == null || l2 == e)
            return s.name;
        }
        return t2;
      }
      function kn(e) {
        var t2 = ue2.call(u2, "placeholder") ? u2 : e;
        return t2.placeholder;
      }
      function P2() {
        var e = u2.iteratee || xo;
        return e = e === xo ? ia2 : e, arguments.length ? e(arguments[0], arguments[1]) : e;
      }
      function Zr(e, t2) {
        var n2 = e.__data__;
        return ch2(t2) ? n2[typeof t2 == "string" ? "string" : "hash"] : n2.map;
      }
      function fo(e) {
        for (var t2 = Ie2(e), n2 = t2.length; n2--; ) {
          var i = t2[n2], s = e[i];
          t2[n2] = [i, s, Na2(s)];
        }
        return t2;
      }
      function on(e, t2) {
        var n2 = hf(e, t2);
        return ra2(n2) ? n2 : o;
      }
      function rh2(e) {
        var t2 = ue2.call(e, jt), n2 = e[jt];
        try {
          e[jt] = o;
          var i = true;
        } catch {
        }
        var s = Sr.call(e);
        return i && (t2 ? e[jt] = n2 : delete e[jt]), s;
      }
      var ho = Ni2 ? function(e) {
        return e == null ? [] : (e = fe2(e), Ut(Ni2(e), function(t2) {
          return Ws.call(e, t2);
        }));
      } : Ro, Da2 = Ni2 ? function(e) {
        for (var t2 = []; e; )
          Vt(t2, ho(e)), e = kr(e);
        return t2;
      } : Ro, Le2 = Pe2;
      (Ui2 && Le2(new Ui2(new ArrayBuffer(1))) != pn || Un && Le2(new Un()) != lt || Vi2 && Le2(Vi2.resolve()) != Qo || bn && Le2(new bn()) != ct || Vn && Le2(new Vn()) != Dn) && (Le2 = function(e) {
        var t2 = Pe2(e), n2 = t2 == Tt ? e.constructor : o, i = n2 ? sn(n2) : "";
        if (i)
          switch (i) {
            case Nf2:
              return pn;
            case Uf2:
              return lt;
            case Vf2:
              return Qo;
            case Wf2:
              return ct;
            case Hf2:
              return Dn;
          }
        return t2;
      });
      function ih2(e, t2, n2) {
        for (var i = -1, s = n2.length; ++i < s; ) {
          var l2 = n2[i], f2 = l2.size;
          switch (l2.type) {
            case "drop":
              e += f2;
              break;
            case "dropRight":
              t2 -= f2;
              break;
            case "take":
              t2 = Re2(t2, e + f2);
              break;
            case "takeRight":
              e = ke2(e, t2 - f2);
              break;
          }
        }
        return { start: e, end: t2 };
      }
      function oh2(e) {
        var t2 = e.match(cc2);
        return t2 ? t2[1].split(fc2) : [];
      }
      function Ma2(e, t2, n2) {
        t2 = Zt(t2, e);
        for (var i = -1, s = t2.length, l2 = false; ++i < s; ) {
          var f2 = bt(t2[i]);
          if (!(l2 = e != null && n2(e, f2)))
            break;
          e = e[f2];
        }
        return l2 || ++i != s ? l2 : (s = e == null ? 0 : e.length, !!s && jr(s) && Rt(f2, s) && (H2(e) || an(e)));
      }
      function sh2(e) {
        var t2 = e.length, n2 = new e.constructor(t2);
        return t2 && typeof e[0] == "string" && ue2.call(e, "index") && (n2.index = e.index, n2.input = e.input), n2;
      }
      function Fa2(e) {
        return typeof e.constructor == "function" && !Xn(e) ? Sn(kr(e)) : {};
      }
      function ah2(e, t2, n2) {
        var i = e.constructor;
        switch (t2) {
          case Mn:
            return oo(e);
          case Rn:
          case Ln:
            return new i(+e);
          case pn:
            return Gd2(e, n2);
          case fi2:
          case di2:
          case hi2:
          case pi2:
          case vi2:
          case gi2:
          case _i:
          case mi2:
          case wi2:
            return ya2(e, n2);
          case lt:
            return new i();
          case $n:
          case Pn:
            return new i(e);
          case Bn:
            return zd2(e);
          case ct:
            return new i();
          case hr:
            return Zd2(e);
        }
      }
      function uh2(e, t2) {
        var n2 = t2.length;
        if (!n2)
          return e;
        var i = n2 - 1;
        return t2[i] = (n2 > 1 ? "& " : "") + t2[i], t2 = t2.join(n2 > 2 ? ", " : " "), e.replace(lc2, `{
/* [wrapped with ` + t2 + `] */
`);
      }
      function lh2(e) {
        return H2(e) || an(e) || !!(Hs && e && e[Hs]);
      }
      function Rt(e, t2) {
        var n2 = typeof e;
        return t2 = t2 ?? Nt, !!t2 && (n2 == "number" || n2 != "symbol" && yc2.test(e)) && e > -1 && e % 1 == 0 && e < t2;
      }
      function De2(e, t2, n2) {
        if (!_e(n2))
          return false;
        var i = typeof t2;
        return (i == "number" ? Ve2(n2) && Rt(t2, n2.length) : i == "string" && t2 in n2) ? ht(n2[t2], e) : false;
      }
      function po(e, t2) {
        if (H2(e))
          return false;
        var n2 = typeof e;
        return n2 == "number" || n2 == "symbol" || n2 == "boolean" || e == null || qe2(e) ? true : oc2.test(e) || !ic2.test(e) || t2 != null && e in fe2(t2);
      }
      function ch2(e) {
        var t2 = typeof e;
        return t2 == "string" || t2 == "number" || t2 == "symbol" || t2 == "boolean" ? e !== "__proto__" : e === null;
      }
      function vo(e) {
        var t2 = zr(e), n2 = u2[t2];
        if (typeof n2 != "function" || !(t2 in Q2.prototype))
          return false;
        if (e === n2)
          return true;
        var i = co(n2);
        return !!i && e === i[0];
      }
      function fh2(e) {
        return !!Ns && Ns in e;
      }
      var dh2 = br ? Lt : Lo;
      function Xn(e) {
        var t2 = e && e.constructor, n2 = typeof t2 == "function" && t2.prototype || yn;
        return e === n2;
      }
      function Na2(e) {
        return e === e && !_e(e);
      }
      function Ua2(e, t2) {
        return function(n2) {
          return n2 == null ? false : n2[e] === t2 && (t2 !== o || e in fe2(n2));
        };
      }
      function hh2(e) {
        var t2 = Jr(e, function(i) {
          return n2.size === y2 && n2.clear(), i;
        }), n2 = t2.cache;
        return t2;
      }
      function ph2(e, t2) {
        var n2 = e[1], i = t2[1], s = n2 | i, l2 = s < (E2 | Z2 | ge2), f2 = i == ge2 && n2 == N2 || i == ge2 && n2 == Ne2 && e[7].length <= t2[8] || i == (ge2 | Ne2) && t2[7].length <= t2[8] && n2 == N2;
        if (!(l2 || f2))
          return e;
        i & E2 && (e[2] = t2[2], s |= n2 & E2 ? 0 : U2);
        var h2 = t2[3];
        if (h2) {
          var v2 = e[3];
          e[3] = v2 ? Ca2(v2, h2, t2[4]) : h2, e[4] = v2 ? Wt(e[3], k2) : t2[4];
        }
        return h2 = t2[5], h2 && (v2 = e[5], e[5] = v2 ? Sa2(v2, h2, t2[6]) : h2, e[6] = v2 ? Wt(e[5], k2) : t2[6]), h2 = t2[7], h2 && (e[7] = h2), i & ge2 && (e[8] = e[8] == null ? t2[8] : Re2(e[8], t2[8])), e[9] == null && (e[9] = t2[9]), e[0] = t2[0], e[1] = s, e;
      }
      function vh2(e) {
        var t2 = [];
        if (e != null)
          for (var n2 in fe2(e))
            t2.push(n2);
        return t2;
      }
      function gh2(e) {
        return Sr.call(e);
      }
      function Va2(e, t2, n2) {
        return t2 = ke2(t2 === o ? e.length - 1 : t2, 0), function() {
          for (var i = arguments, s = -1, l2 = ke2(i.length - t2, 0), f2 = m2(l2); ++s < l2; )
            f2[s] = i[t2 + s];
          s = -1;
          for (var h2 = m2(t2 + 1); ++s < t2; )
            h2[s] = i[s];
          return h2[t2] = n2(f2), Ge2(e, this, h2);
        };
      }
      function Wa2(e, t2) {
        return t2.length < 2 ? e : rn(e, rt(t2, 0, -1));
      }
      function _h(e, t2) {
        for (var n2 = e.length, i = Re2(t2.length, n2), s = Ue2(e); i--; ) {
          var l2 = t2[i];
          e[i] = Rt(l2, n2) ? s[l2] : o;
        }
        return e;
      }
      function go(e, t2) {
        if (!(t2 === "constructor" && typeof e[t2] == "function") && t2 != "__proto__")
          return e[t2];
      }
      var Ha2 = za2(da2), Jn = Lf2 || function(e, t2) {
        return xe.setTimeout(e, t2);
      }, _o = za2(Ud2);
      function Ga2(e, t2, n2) {
        var i = t2 + "";
        return _o(e, uh2(i, mh2(oh2(i), n2)));
      }
      function za2(e) {
        var t2 = 0, n2 = 0;
        return function() {
          var i = Df2(), s = Fl - (i - n2);
          if (n2 = i, s > 0) {
            if (++t2 >= Ml)
              return arguments[0];
          } else
            t2 = 0;
          return e.apply(o, arguments);
        };
      }
      function qr(e, t2) {
        var n2 = -1, i = e.length, s = i - 1;
        for (t2 = t2 === o ? i : t2; ++n2 < t2; ) {
          var l2 = Qi2(n2, s), f2 = e[l2];
          e[l2] = e[n2], e[n2] = f2;
        }
        return e.length = t2, e;
      }
      var Za2 = hh2(function(e) {
        var t2 = [];
        return e.charCodeAt(0) === 46 && t2.push(""), e.replace(sc2, function(n2, i, s, l2) {
          t2.push(s ? l2.replace(pc2, "$1") : i || n2);
        }), t2;
      });
      function bt(e) {
        if (typeof e == "string" || qe2(e))
          return e;
        var t2 = e + "";
        return t2 == "0" && 1 / e == -Jt ? "-0" : t2;
      }
      function sn(e) {
        if (e != null) {
          try {
            return Cr.call(e);
          } catch {
          }
          try {
            return e + "";
          } catch {
          }
        }
        return "";
      }
      function mh2(e, t2) {
        return je2(Gl, function(n2) {
          var i = "_." + n2[0];
          t2 & n2[1] && !_r(e, i) && e.push(i);
        }), e.sort();
      }
      function qa2(e) {
        if (e instanceof Q2)
          return e.clone();
        var t2 = new tt(e.__wrapped__, e.__chain__);
        return t2.__actions__ = Ue2(e.__actions__), t2.__index__ = e.__index__, t2.__values__ = e.__values__, t2;
      }
      function wh2(e, t2, n2) {
        (n2 ? De2(e, t2, n2) : t2 === o) ? t2 = 1 : t2 = ke2(G2(t2), 0);
        var i = e == null ? 0 : e.length;
        if (!i || t2 < 1)
          return [];
        for (var s = 0, l2 = 0, f2 = m2(Or(i / t2)); s < i; )
          f2[l2++] = rt(e, s, s += t2);
        return f2;
      }
      function yh2(e) {
        for (var t2 = -1, n2 = e == null ? 0 : e.length, i = 0, s = []; ++t2 < n2; ) {
          var l2 = e[t2];
          l2 && (s[i++] = l2);
        }
        return s;
      }
      function bh2() {
        var e = arguments.length;
        if (!e)
          return [];
        for (var t2 = m2(e - 1), n2 = arguments[0], i = e; i--; )
          t2[i - 1] = arguments[i];
        return Vt(H2(n2) ? Ue2(n2) : [n2], Oe2(t2, 1));
      }
      var Ch2 = K2(function(e, t2) {
        return Ce2(e) ? zn(e, Oe2(t2, 1, Ce2, true)) : [];
      }), Sh2 = K2(function(e, t2) {
        var n2 = it(t2);
        return Ce2(n2) && (n2 = o), Ce2(e) ? zn(e, Oe2(t2, 1, Ce2, true), P2(n2, 2)) : [];
      }), Ah2 = K2(function(e, t2) {
        var n2 = it(t2);
        return Ce2(n2) && (n2 = o), Ce2(e) ? zn(e, Oe2(t2, 1, Ce2, true), o, n2) : [];
      });
      function Th2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        return i ? (t2 = n2 || t2 === o ? 1 : G2(t2), rt(e, t2 < 0 ? 0 : t2, i)) : [];
      }
      function kh2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        return i ? (t2 = n2 || t2 === o ? 1 : G2(t2), t2 = i - t2, rt(e, 0, t2 < 0 ? 0 : t2)) : [];
      }
      function Ih2(e, t2) {
        return e && e.length ? Nr(e, P2(t2, 3), true, true) : [];
      }
      function xh2(e, t2) {
        return e && e.length ? Nr(e, P2(t2, 3), true) : [];
      }
      function Oh2(e, t2, n2, i) {
        var s = e == null ? 0 : e.length;
        return s ? (n2 && typeof n2 != "number" && De2(e, t2, n2) && (n2 = 0, i = s), bd2(e, t2, n2, i)) : [];
      }
      function Ka2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        if (!i)
          return -1;
        var s = n2 == null ? 0 : G2(n2);
        return s < 0 && (s = ke2(i + s, 0)), mr(e, P2(t2, 3), s);
      }
      function Ya2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        if (!i)
          return -1;
        var s = i - 1;
        return n2 !== o && (s = G2(n2), s = n2 < 0 ? ke2(i + s, 0) : Re2(s, i - 1)), mr(e, P2(t2, 3), s, true);
      }
      function Xa2(e) {
        var t2 = e == null ? 0 : e.length;
        return t2 ? Oe2(e, 1) : [];
      }
      function Eh2(e) {
        var t2 = e == null ? 0 : e.length;
        return t2 ? Oe2(e, Jt) : [];
      }
      function Rh2(e, t2) {
        var n2 = e == null ? 0 : e.length;
        return n2 ? (t2 = t2 === o ? 1 : G2(t2), Oe2(e, t2)) : [];
      }
      function Lh2(e) {
        for (var t2 = -1, n2 = e == null ? 0 : e.length, i = {}; ++t2 < n2; ) {
          var s = e[t2];
          i[s[0]] = s[1];
        }
        return i;
      }
      function Ja2(e) {
        return e && e.length ? e[0] : o;
      }
      function $h2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        if (!i)
          return -1;
        var s = n2 == null ? 0 : G2(n2);
        return s < 0 && (s = ke2(i + s, 0)), gn(e, t2, s);
      }
      function Bh2(e) {
        var t2 = e == null ? 0 : e.length;
        return t2 ? rt(e, 0, -1) : [];
      }
      var Ph2 = K2(function(e) {
        var t2 = ve2(e, ro);
        return t2.length && t2[0] === e[0] ? qi2(t2) : [];
      }), Dh2 = K2(function(e) {
        var t2 = it(e), n2 = ve2(e, ro);
        return t2 === it(n2) ? t2 = o : n2.pop(), n2.length && n2[0] === e[0] ? qi2(n2, P2(t2, 2)) : [];
      }), Mh2 = K2(function(e) {
        var t2 = it(e), n2 = ve2(e, ro);
        return t2 = typeof t2 == "function" ? t2 : o, t2 && n2.pop(), n2.length && n2[0] === e[0] ? qi2(n2, o, t2) : [];
      });
      function Fh2(e, t2) {
        return e == null ? "" : Bf2.call(e, t2);
      }
      function it(e) {
        var t2 = e == null ? 0 : e.length;
        return t2 ? e[t2 - 1] : o;
      }
      function Nh2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        if (!i)
          return -1;
        var s = i;
        return n2 !== o && (s = G2(n2), s = s < 0 ? ke2(i + s, 0) : Re2(s, i - 1)), t2 === t2 ? mf2(e, t2, s) : mr(e, Rs, s, true);
      }
      function Uh2(e, t2) {
        return e && e.length ? ua2(e, G2(t2)) : o;
      }
      var Vh2 = K2(Qa2);
      function Qa2(e, t2) {
        return e && e.length && t2 && t2.length ? Ji2(e, t2) : e;
      }
      function Wh2(e, t2, n2) {
        return e && e.length && t2 && t2.length ? Ji2(e, t2, P2(n2, 2)) : e;
      }
      function Hh2(e, t2, n2) {
        return e && e.length && t2 && t2.length ? Ji2(e, t2, o, n2) : e;
      }
      var Gh2 = Et(function(e, t2) {
        var n2 = e == null ? 0 : e.length, i = Hi2(e, t2);
        return fa2(e, ve2(t2, function(s) {
          return Rt(s, n2) ? +s : s;
        }).sort(ba)), i;
      });
      function zh2(e, t2) {
        var n2 = [];
        if (!(e && e.length))
          return n2;
        var i = -1, s = [], l2 = e.length;
        for (t2 = P2(t2, 3); ++i < l2; ) {
          var f2 = e[i];
          t2(f2, i, e) && (n2.push(f2), s.push(i));
        }
        return fa2(e, s), n2;
      }
      function mo(e) {
        return e == null ? e : Ff2.call(e);
      }
      function Zh2(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        return i ? (n2 && typeof n2 != "number" && De2(e, t2, n2) ? (t2 = 0, n2 = i) : (t2 = t2 == null ? 0 : G2(t2), n2 = n2 === o ? i : G2(n2)), rt(e, t2, n2)) : [];
      }
      function qh2(e, t2) {
        return Fr(e, t2);
      }
      function Kh2(e, t2, n2) {
        return eo(e, t2, P2(n2, 2));
      }
      function Yh2(e, t2) {
        var n2 = e == null ? 0 : e.length;
        if (n2) {
          var i = Fr(e, t2);
          if (i < n2 && ht(e[i], t2))
            return i;
        }
        return -1;
      }
      function Xh2(e, t2) {
        return Fr(e, t2, true);
      }
      function Jh2(e, t2, n2) {
        return eo(e, t2, P2(n2, 2), true);
      }
      function Qh2(e, t2) {
        var n2 = e == null ? 0 : e.length;
        if (n2) {
          var i = Fr(e, t2, true) - 1;
          if (ht(e[i], t2))
            return i;
        }
        return -1;
      }
      function jh2(e) {
        return e && e.length ? ha2(e) : [];
      }
      function ep(e, t2) {
        return e && e.length ? ha2(e, P2(t2, 2)) : [];
      }
      function tp(e) {
        var t2 = e == null ? 0 : e.length;
        return t2 ? rt(e, 1, t2) : [];
      }
      function np(e, t2, n2) {
        return e && e.length ? (t2 = n2 || t2 === o ? 1 : G2(t2), rt(e, 0, t2 < 0 ? 0 : t2)) : [];
      }
      function rp(e, t2, n2) {
        var i = e == null ? 0 : e.length;
        return i ? (t2 = n2 || t2 === o ? 1 : G2(t2), t2 = i - t2, rt(e, t2 < 0 ? 0 : t2, i)) : [];
      }
      function ip(e, t2) {
        return e && e.length ? Nr(e, P2(t2, 3), false, true) : [];
      }
      function op(e, t2) {
        return e && e.length ? Nr(e, P2(t2, 3)) : [];
      }
      var sp = K2(function(e) {
        return zt(Oe2(e, 1, Ce2, true));
      }), ap = K2(function(e) {
        var t2 = it(e);
        return Ce2(t2) && (t2 = o), zt(Oe2(e, 1, Ce2, true), P2(t2, 2));
      }), up = K2(function(e) {
        var t2 = it(e);
        return t2 = typeof t2 == "function" ? t2 : o, zt(Oe2(e, 1, Ce2, true), o, t2);
      });
      function lp(e) {
        return e && e.length ? zt(e) : [];
      }
      function cp(e, t2) {
        return e && e.length ? zt(e, P2(t2, 2)) : [];
      }
      function fp(e, t2) {
        return t2 = typeof t2 == "function" ? t2 : o, e && e.length ? zt(e, o, t2) : [];
      }
      function wo(e) {
        if (!(e && e.length))
          return [];
        var t2 = 0;
        return e = Ut(e, function(n2) {
          if (Ce2(n2))
            return t2 = ke2(n2.length, t2), true;
        }), Pi2(t2, function(n2) {
          return ve2(e, Li2(n2));
        });
      }
      function ja2(e, t2) {
        if (!(e && e.length))
          return [];
        var n2 = wo(e);
        return t2 == null ? n2 : ve2(n2, function(i) {
          return Ge2(t2, o, i);
        });
      }
      var dp = K2(function(e, t2) {
        return Ce2(e) ? zn(e, t2) : [];
      }), hp = K2(function(e) {
        return no(Ut(e, Ce2));
      }), pp = K2(function(e) {
        var t2 = it(e);
        return Ce2(t2) && (t2 = o), no(Ut(e, Ce2), P2(t2, 2));
      }), vp = K2(function(e) {
        var t2 = it(e);
        return t2 = typeof t2 == "function" ? t2 : o, no(Ut(e, Ce2), o, t2);
      }), gp = K2(wo);
      function _p(e, t2) {
        return _a(e || [], t2 || [], Gn);
      }
      function mp(e, t2) {
        return _a(e || [], t2 || [], Kn);
      }
      var wp = K2(function(e) {
        var t2 = e.length, n2 = t2 > 1 ? e[t2 - 1] : o;
        return n2 = typeof n2 == "function" ? (e.pop(), n2) : o, ja2(e, n2);
      });
      function eu(e) {
        var t2 = u2(e);
        return t2.__chain__ = true, t2;
      }
      function yp(e, t2) {
        return t2(e), e;
      }
      function Kr(e, t2) {
        return t2(e);
      }
      var bp = Et(function(e) {
        var t2 = e.length, n2 = t2 ? e[0] : 0, i = this.__wrapped__, s = function(l2) {
          return Hi2(l2, e);
        };
        return t2 > 1 || this.__actions__.length || !(i instanceof Q2) || !Rt(n2) ? this.thru(s) : (i = i.slice(n2, +n2 + (t2 ? 1 : 0)), i.__actions__.push({
          func: Kr,
          args: [s],
          thisArg: o
        }), new tt(i, this.__chain__).thru(function(l2) {
          return t2 && !l2.length && l2.push(o), l2;
        }));
      });
      function Cp() {
        return eu(this);
      }
      function Sp() {
        return new tt(this.value(), this.__chain__);
      }
      function Ap() {
        this.__values__ === o && (this.__values__ = pu(this.value()));
        var e = this.__index__ >= this.__values__.length, t2 = e ? o : this.__values__[this.__index__++];
        return { done: e, value: t2 };
      }
      function Tp() {
        return this;
      }
      function kp(e) {
        for (var t2, n2 = this; n2 instanceof $r; ) {
          var i = qa2(n2);
          i.__index__ = 0, i.__values__ = o, t2 ? s.__wrapped__ = i : t2 = i;
          var s = i;
          n2 = n2.__wrapped__;
        }
        return s.__wrapped__ = e, t2;
      }
      function Ip() {
        var e = this.__wrapped__;
        if (e instanceof Q2) {
          var t2 = e;
          return this.__actions__.length && (t2 = new Q2(this)), t2 = t2.reverse(), t2.__actions__.push({
            func: Kr,
            args: [mo],
            thisArg: o
          }), new tt(t2, this.__chain__);
        }
        return this.thru(mo);
      }
      function xp() {
        return ga(this.__wrapped__, this.__actions__);
      }
      var Op = Ur(function(e, t2, n2) {
        ue2.call(e, n2) ? ++e[n2] : xt(e, n2, 1);
      });
      function Ep(e, t2, n2) {
        var i = H2(e) ? Os : yd2;
        return n2 && De2(e, t2, n2) && (t2 = o), i(e, P2(t2, 3));
      }
      function Rp(e, t2) {
        var n2 = H2(e) ? Ut : js;
        return n2(e, P2(t2, 3));
      }
      var Lp = Ia2(Ka2), $p = Ia2(Ya2);
      function Bp(e, t2) {
        return Oe2(Yr(e, t2), 1);
      }
      function Pp(e, t2) {
        return Oe2(Yr(e, t2), Jt);
      }
      function Dp(e, t2, n2) {
        return n2 = n2 === o ? 1 : G2(n2), Oe2(Yr(e, t2), n2);
      }
      function tu(e, t2) {
        var n2 = H2(e) ? je2 : Gt;
        return n2(e, P2(t2, 3));
      }
      function nu(e, t2) {
        var n2 = H2(e) ? ef2 : Qs;
        return n2(e, P2(t2, 3));
      }
      var Mp = Ur(function(e, t2, n2) {
        ue2.call(e, n2) ? e[n2].push(t2) : xt(e, n2, [t2]);
      });
      function Fp(e, t2, n2, i) {
        e = Ve2(e) ? e : xn(e), n2 = n2 && !i ? G2(n2) : 0;
        var s = e.length;
        return n2 < 0 && (n2 = ke2(s + n2, 0)), ei2(e) ? n2 <= s && e.indexOf(t2, n2) > -1 : !!s && gn(e, t2, n2) > -1;
      }
      var Np = K2(function(e, t2, n2) {
        var i = -1, s = typeof t2 == "function", l2 = Ve2(e) ? m2(e.length) : [];
        return Gt(e, function(f2) {
          l2[++i] = s ? Ge2(t2, f2, n2) : Zn(f2, t2, n2);
        }), l2;
      }), Up = Ur(function(e, t2, n2) {
        xt(e, n2, t2);
      });
      function Yr(e, t2) {
        var n2 = H2(e) ? ve2 : oa2;
        return n2(e, P2(t2, 3));
      }
      function Vp(e, t2, n2, i) {
        return e == null ? [] : (H2(t2) || (t2 = t2 == null ? [] : [t2]), n2 = i ? o : n2, H2(n2) || (n2 = n2 == null ? [] : [n2]), la2(e, t2, n2));
      }
      var Wp = Ur(function(e, t2, n2) {
        e[n2 ? 0 : 1].push(t2);
      }, function() {
        return [[], []];
      });
      function Hp(e, t2, n2) {
        var i = H2(e) ? Ei2 : $s, s = arguments.length < 3;
        return i(e, P2(t2, 4), n2, s, Gt);
      }
      function Gp(e, t2, n2) {
        var i = H2(e) ? tf2 : $s, s = arguments.length < 3;
        return i(e, P2(t2, 4), n2, s, Qs);
      }
      function zp(e, t2) {
        var n2 = H2(e) ? Ut : js;
        return n2(e, Qr(P2(t2, 3)));
      }
      function Zp(e) {
        var t2 = H2(e) ? Ks : Fd2;
        return t2(e);
      }
      function qp(e, t2, n2) {
        (n2 ? De2(e, t2, n2) : t2 === o) ? t2 = 1 : t2 = G2(t2);
        var i = H2(e) ? vd2 : Nd2;
        return i(e, t2);
      }
      function Kp(e) {
        var t2 = H2(e) ? gd2 : Vd2;
        return t2(e);
      }
      function Yp(e) {
        if (e == null)
          return 0;
        if (Ve2(e))
          return ei2(e) ? mn(e) : e.length;
        var t2 = Le2(e);
        return t2 == lt || t2 == ct ? e.size : Yi2(e).length;
      }
      function Xp(e, t2, n2) {
        var i = H2(e) ? Ri2 : Wd2;
        return n2 && De2(e, t2, n2) && (t2 = o), i(e, P2(t2, 3));
      }
      var Jp = K2(function(e, t2) {
        if (e == null)
          return [];
        var n2 = t2.length;
        return n2 > 1 && De2(e, t2[0], t2[1]) ? t2 = [] : n2 > 2 && De2(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), la2(e, Oe2(t2, 1), []);
      }), Xr = Rf2 || function() {
        return xe.Date.now();
      };
      function Qp(e, t2) {
        if (typeof t2 != "function")
          throw new et(_);
        return e = G2(e), function() {
          if (--e < 1)
            return t2.apply(this, arguments);
        };
      }
      function ru(e, t2, n2) {
        return t2 = n2 ? o : t2, t2 = e && t2 == null ? e.length : t2, Ot(e, ge2, o, o, o, o, t2);
      }
      function iu(e, t2) {
        var n2;
        if (typeof t2 != "function")
          throw new et(_);
        return e = G2(e), function() {
          return --e > 0 && (n2 = t2.apply(this, arguments)), e <= 1 && (t2 = o), n2;
        };
      }
      var yo = K2(function(e, t2, n2) {
        var i = E2;
        if (n2.length) {
          var s = Wt(n2, kn(yo));
          i |= x2;
        }
        return Ot(e, i, t2, n2, s);
      }), ou = K2(function(e, t2, n2) {
        var i = E2 | Z2;
        if (n2.length) {
          var s = Wt(n2, kn(ou));
          i |= x2;
        }
        return Ot(t2, i, e, n2, s);
      });
      function su(e, t2, n2) {
        t2 = n2 ? o : t2;
        var i = Ot(e, N2, o, o, o, o, o, t2);
        return i.placeholder = su.placeholder, i;
      }
      function au(e, t2, n2) {
        t2 = n2 ? o : t2;
        var i = Ot(e, X2, o, o, o, o, o, t2);
        return i.placeholder = au.placeholder, i;
      }
      function uu(e, t2, n2) {
        var i, s, l2, f2, h2, v2, b = 0, C2 = false, T2 = false, O2 = true;
        if (typeof e != "function")
          throw new et(_);
        t2 = ot(t2) || 0, _e(n2) && (C2 = !!n2.leading, T2 = "maxWait" in n2, l2 = T2 ? ke2(ot(n2.maxWait) || 0, t2) : l2, O2 = "trailing" in n2 ? !!n2.trailing : O2);
        function $(Se2) {
          var pt = i, Bt = s;
          return i = s = o, b = Se2, f2 = e.apply(Bt, pt), f2;
        }
        function D2(Se2) {
          return b = Se2, h2 = Jn(J2, t2), C2 ? $(Se2) : f2;
        }
        function z2(Se2) {
          var pt = Se2 - v2, Bt = Se2 - b, Iu = t2 - pt;
          return T2 ? Re2(Iu, l2 - Bt) : Iu;
        }
        function M2(Se2) {
          var pt = Se2 - v2, Bt = Se2 - b;
          return v2 === o || pt >= t2 || pt < 0 || T2 && Bt >= l2;
        }
        function J2() {
          var Se2 = Xr();
          if (M2(Se2))
            return j(Se2);
          h2 = Jn(J2, z2(Se2));
        }
        function j(Se2) {
          return h2 = o, O2 && i ? $(Se2) : (i = s = o, f2);
        }
        function Ke2() {
          h2 !== o && ma2(h2), b = 0, i = v2 = s = h2 = o;
        }
        function Me2() {
          return h2 === o ? f2 : j(Xr());
        }
        function Ye2() {
          var Se2 = Xr(), pt = M2(Se2);
          if (i = arguments, s = this, v2 = Se2, pt) {
            if (h2 === o)
              return D2(v2);
            if (T2)
              return ma2(h2), h2 = Jn(J2, t2), $(v2);
          }
          return h2 === o && (h2 = Jn(J2, t2)), f2;
        }
        return Ye2.cancel = Ke2, Ye2.flush = Me2, Ye2;
      }
      var jp = K2(function(e, t2) {
        return Js(e, 1, t2);
      }), ev = K2(function(e, t2, n2) {
        return Js(e, ot(t2) || 0, n2);
      });
      function tv(e) {
        return Ot(e, Ft);
      }
      function Jr(e, t2) {
        if (typeof e != "function" || t2 != null && typeof t2 != "function")
          throw new et(_);
        var n2 = function() {
          var i = arguments, s = t2 ? t2.apply(this, i) : i[0], l2 = n2.cache;
          if (l2.has(s))
            return l2.get(s);
          var f2 = e.apply(this, i);
          return n2.cache = l2.set(s, f2) || l2, f2;
        };
        return n2.cache = new (Jr.Cache || It)(), n2;
      }
      Jr.Cache = It;
      function Qr(e) {
        if (typeof e != "function")
          throw new et(_);
        return function() {
          var t2 = arguments;
          switch (t2.length) {
            case 0:
              return !e.call(this);
            case 1:
              return !e.call(this, t2[0]);
            case 2:
              return !e.call(this, t2[0], t2[1]);
            case 3:
              return !e.call(this, t2[0], t2[1], t2[2]);
          }
          return !e.apply(this, t2);
        };
      }
      function nv(e) {
        return iu(2, e);
      }
      var rv = Hd2(function(e, t2) {
        t2 = t2.length == 1 && H2(t2[0]) ? ve2(t2[0], ze(P2())) : ve2(Oe2(t2, 1), ze(P2()));
        var n2 = t2.length;
        return K2(function(i) {
          for (var s = -1, l2 = Re2(i.length, n2); ++s < l2; )
            i[s] = t2[s].call(this, i[s]);
          return Ge2(e, this, i);
        });
      }), bo = K2(function(e, t2) {
        var n2 = Wt(t2, kn(bo));
        return Ot(e, x2, o, t2, n2);
      }), lu = K2(function(e, t2) {
        var n2 = Wt(t2, kn(lu));
        return Ot(e, q2, o, t2, n2);
      }), iv = Et(function(e, t2) {
        return Ot(e, Ne2, o, o, o, t2);
      });
      function ov(e, t2) {
        if (typeof e != "function")
          throw new et(_);
        return t2 = t2 === o ? t2 : G2(t2), K2(e, t2);
      }
      function sv(e, t2) {
        if (typeof e != "function")
          throw new et(_);
        return t2 = t2 == null ? 0 : ke2(G2(t2), 0), K2(function(n2) {
          var i = n2[t2], s = qt(n2, 0, t2);
          return i && Vt(s, i), Ge2(e, this, s);
        });
      }
      function av(e, t2, n2) {
        var i = true, s = true;
        if (typeof e != "function")
          throw new et(_);
        return _e(n2) && (i = "leading" in n2 ? !!n2.leading : i, s = "trailing" in n2 ? !!n2.trailing : s), uu(e, t2, {
          leading: i,
          maxWait: t2,
          trailing: s
        });
      }
      function uv(e) {
        return ru(e, 1);
      }
      function lv(e, t2) {
        return bo(io(t2), e);
      }
      function cv() {
        if (!arguments.length)
          return [];
        var e = arguments[0];
        return H2(e) ? e : [e];
      }
      function fv(e) {
        return nt(e, se2);
      }
      function dv(e, t2) {
        return t2 = typeof t2 == "function" ? t2 : o, nt(e, se2, t2);
      }
      function hv(e) {
        return nt(e, V2 | se2);
      }
      function pv(e, t2) {
        return t2 = typeof t2 == "function" ? t2 : o, nt(e, V2 | se2, t2);
      }
      function vv(e, t2) {
        return t2 == null || Xs(e, t2, Ie2(t2));
      }
      function ht(e, t2) {
        return e === t2 || e !== e && t2 !== t2;
      }
      var gv = Gr(Zi2), _v = Gr(function(e, t2) {
        return e >= t2;
      }), an = na(function() {
        return arguments;
      }()) ? na : function(e) {
        return ye(e) && ue2.call(e, "callee") && !Ws.call(e, "callee");
      }, H2 = m2.isArray, mv = Ss ? ze(Ss) : kd2;
      function Ve2(e) {
        return e != null && jr(e.length) && !Lt(e);
      }
      function Ce2(e) {
        return ye(e) && Ve2(e);
      }
      function wv(e) {
        return e === true || e === false || ye(e) && Pe2(e) == Rn;
      }
      var Kt = $f2 || Lo, yv = As ? ze(As) : Id2;
      function bv(e) {
        return ye(e) && e.nodeType === 1 && !Qn(e);
      }
      function Cv(e) {
        if (e == null)
          return true;
        if (Ve2(e) && (H2(e) || typeof e == "string" || typeof e.splice == "function" || Kt(e) || In(e) || an(e)))
          return !e.length;
        var t2 = Le2(e);
        if (t2 == lt || t2 == ct)
          return !e.size;
        if (Xn(e))
          return !Yi2(e).length;
        for (var n2 in e)
          if (ue2.call(e, n2))
            return false;
        return true;
      }
      function Sv(e, t2) {
        return qn(e, t2);
      }
      function Av(e, t2, n2) {
        n2 = typeof n2 == "function" ? n2 : o;
        var i = n2 ? n2(e, t2) : o;
        return i === o ? qn(e, t2, o, n2) : !!i;
      }
      function Co(e) {
        if (!ye(e))
          return false;
        var t2 = Pe2(e);
        return t2 == fr || t2 == Zl || typeof e.message == "string" && typeof e.name == "string" && !Qn(e);
      }
      function Tv(e) {
        return typeof e == "number" && Gs(e);
      }
      function Lt(e) {
        if (!_e(e))
          return false;
        var t2 = Pe2(e);
        return t2 == dr || t2 == Jo || t2 == zl || t2 == Kl;
      }
      function cu(e) {
        return typeof e == "number" && e == G2(e);
      }
      function jr(e) {
        return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Nt;
      }
      function _e(e) {
        var t2 = typeof e;
        return e != null && (t2 == "object" || t2 == "function");
      }
      function ye(e) {
        return e != null && typeof e == "object";
      }
      var fu = Ts ? ze(Ts) : Od2;
      function kv(e, t2) {
        return e === t2 || Ki2(e, t2, fo(t2));
      }
      function Iv(e, t2, n2) {
        return n2 = typeof n2 == "function" ? n2 : o, Ki2(e, t2, fo(t2), n2);
      }
      function xv(e) {
        return du(e) && e != +e;
      }
      function Ov(e) {
        if (dh2(e))
          throw new W2(g);
        return ra2(e);
      }
      function Ev(e) {
        return e === null;
      }
      function Rv(e) {
        return e == null;
      }
      function du(e) {
        return typeof e == "number" || ye(e) && Pe2(e) == $n;
      }
      function Qn(e) {
        if (!ye(e) || Pe2(e) != Tt)
          return false;
        var t2 = kr(e);
        if (t2 === null)
          return true;
        var n2 = ue2.call(t2, "constructor") && t2.constructor;
        return typeof n2 == "function" && n2 instanceof n2 && Cr.call(n2) == If2;
      }
      var So = ks ? ze(ks) : Ed2;
      function Lv(e) {
        return cu(e) && e >= -Nt && e <= Nt;
      }
      var hu = Is ? ze(Is) : Rd2;
      function ei2(e) {
        return typeof e == "string" || !H2(e) && ye(e) && Pe2(e) == Pn;
      }
      function qe2(e) {
        return typeof e == "symbol" || ye(e) && Pe2(e) == hr;
      }
      var In = xs ? ze(xs) : Ld2;
      function $v(e) {
        return e === o;
      }
      function Bv(e) {
        return ye(e) && Le2(e) == Dn;
      }
      function Pv(e) {
        return ye(e) && Pe2(e) == Xl;
      }
      var Dv = Gr(Xi2), Mv = Gr(function(e, t2) {
        return e <= t2;
      });
      function pu(e) {
        if (!e)
          return [];
        if (Ve2(e))
          return ei2(e) ? ft(e) : Ue2(e);
        if (Nn && e[Nn])
          return vf2(e[Nn]());
        var t2 = Le2(e), n2 = t2 == lt ? Mi2 : t2 == ct ? wr : xn;
        return n2(e);
      }
      function $t(e) {
        if (!e)
          return e === 0 ? e : 0;
        if (e = ot(e), e === Jt || e === -Jt) {
          var t2 = e < 0 ? -1 : 1;
          return t2 * Vl;
        }
        return e === e ? e : 0;
      }
      function G2(e) {
        var t2 = $t(e), n2 = t2 % 1;
        return t2 === t2 ? n2 ? t2 - n2 : t2 : 0;
      }
      function vu(e) {
        return e ? nn(G2(e), 0, mt) : 0;
      }
      function ot(e) {
        if (typeof e == "number")
          return e;
        if (qe2(e))
          return lr;
        if (_e(e)) {
          var t2 = typeof e.valueOf == "function" ? e.valueOf() : e;
          e = _e(t2) ? t2 + "" : t2;
        }
        if (typeof e != "string")
          return e === 0 ? e : +e;
        e = Bs(e);
        var n2 = _c.test(e);
        return n2 || wc2.test(e) ? Jc2(e.slice(2), n2 ? 2 : 8) : gc2.test(e) ? lr : +e;
      }
      function gu(e) {
        return yt(e, We2(e));
      }
      function Fv(e) {
        return e ? nn(G2(e), -Nt, Nt) : e === 0 ? e : 0;
      }
      function ae2(e) {
        return e == null ? "" : Ze2(e);
      }
      var Nv = An(function(e, t2) {
        if (Xn(t2) || Ve2(t2)) {
          yt(t2, Ie2(t2), e);
          return;
        }
        for (var n2 in t2)
          ue2.call(t2, n2) && Gn(e, n2, t2[n2]);
      }), _u = An(function(e, t2) {
        yt(t2, We2(t2), e);
      }), ti2 = An(function(e, t2, n2, i) {
        yt(t2, We2(t2), e, i);
      }), Uv = An(function(e, t2, n2, i) {
        yt(t2, Ie2(t2), e, i);
      }), Vv = Et(Hi2);
      function Wv(e, t2) {
        var n2 = Sn(e);
        return t2 == null ? n2 : Ys(n2, t2);
      }
      var Hv = K2(function(e, t2) {
        e = fe2(e);
        var n2 = -1, i = t2.length, s = i > 2 ? t2[2] : o;
        for (s && De2(t2[0], t2[1], s) && (i = 1); ++n2 < i; )
          for (var l2 = t2[n2], f2 = We2(l2), h2 = -1, v2 = f2.length; ++h2 < v2; ) {
            var b = f2[h2], C2 = e[b];
            (C2 === o || ht(C2, yn[b]) && !ue2.call(e, b)) && (e[b] = l2[b]);
          }
        return e;
      }), Gv = K2(function(e) {
        return e.push(o, Ba2), Ge2(mu, o, e);
      });
      function zv(e, t2) {
        return Es(e, P2(t2, 3), wt);
      }
      function Zv(e, t2) {
        return Es(e, P2(t2, 3), zi2);
      }
      function qv(e, t2) {
        return e == null ? e : Gi2(e, P2(t2, 3), We2);
      }
      function Kv(e, t2) {
        return e == null ? e : ea2(e, P2(t2, 3), We2);
      }
      function Yv(e, t2) {
        return e && wt(e, P2(t2, 3));
      }
      function Xv(e, t2) {
        return e && zi2(e, P2(t2, 3));
      }
      function Jv(e) {
        return e == null ? [] : Dr(e, Ie2(e));
      }
      function Qv(e) {
        return e == null ? [] : Dr(e, We2(e));
      }
      function Ao(e, t2, n2) {
        var i = e == null ? o : rn(e, t2);
        return i === o ? n2 : i;
      }
      function jv(e, t2) {
        return e != null && Ma2(e, t2, Cd2);
      }
      function To(e, t2) {
        return e != null && Ma2(e, t2, Sd2);
      }
      var eg2 = Oa2(function(e, t2, n2) {
        t2 != null && typeof t2.toString != "function" && (t2 = Sr.call(t2)), e[t2] = n2;
      }, Io(He2)), tg2 = Oa2(function(e, t2, n2) {
        t2 != null && typeof t2.toString != "function" && (t2 = Sr.call(t2)), ue2.call(e, t2) ? e[t2].push(n2) : e[t2] = [n2];
      }, P2), ng2 = K2(Zn);
      function Ie2(e) {
        return Ve2(e) ? qs(e) : Yi2(e);
      }
      function We2(e) {
        return Ve2(e) ? qs(e, true) : $d2(e);
      }
      function rg2(e, t2) {
        var n2 = {};
        return t2 = P2(t2, 3), wt(e, function(i, s, l2) {
          xt(n2, t2(i, s, l2), i);
        }), n2;
      }
      function ig2(e, t2) {
        var n2 = {};
        return t2 = P2(t2, 3), wt(e, function(i, s, l2) {
          xt(n2, s, t2(i, s, l2));
        }), n2;
      }
      var og2 = An(function(e, t2, n2) {
        Mr(e, t2, n2);
      }), mu = An(function(e, t2, n2, i) {
        Mr(e, t2, n2, i);
      }), sg2 = Et(function(e, t2) {
        var n2 = {};
        if (e == null)
          return n2;
        var i = false;
        t2 = ve2(t2, function(l2) {
          return l2 = Zt(l2, e), i || (i = l2.length > 1), l2;
        }), yt(e, lo(e), n2), i && (n2 = nt(n2, V2 | te2 | se2, eh2));
        for (var s = t2.length; s--; )
          to(n2, t2[s]);
        return n2;
      });
      function ag2(e, t2) {
        return wu(e, Qr(P2(t2)));
      }
      var ug2 = Et(function(e, t2) {
        return e == null ? {} : Pd2(e, t2);
      });
      function wu(e, t2) {
        if (e == null)
          return {};
        var n2 = ve2(lo(e), function(i) {
          return [i];
        });
        return t2 = P2(t2), ca2(e, n2, function(i, s) {
          return t2(i, s[0]);
        });
      }
      function lg2(e, t2, n2) {
        t2 = Zt(t2, e);
        var i = -1, s = t2.length;
        for (s || (s = 1, e = o); ++i < s; ) {
          var l2 = e == null ? o : e[bt(t2[i])];
          l2 === o && (i = s, l2 = n2), e = Lt(l2) ? l2.call(e) : l2;
        }
        return e;
      }
      function cg2(e, t2, n2) {
        return e == null ? e : Kn(e, t2, n2);
      }
      function fg2(e, t2, n2, i) {
        return i = typeof i == "function" ? i : o, e == null ? e : Kn(e, t2, n2, i);
      }
      var yu = La2(Ie2), bu = La2(We2);
      function dg2(e, t2, n2) {
        var i = H2(e), s = i || Kt(e) || In(e);
        if (t2 = P2(t2, 4), n2 == null) {
          var l2 = e && e.constructor;
          s ? n2 = i ? new l2() : [] : _e(e) ? n2 = Lt(l2) ? Sn(kr(e)) : {} : n2 = {};
        }
        return (s ? je2 : wt)(e, function(f2, h2, v2) {
          return t2(n2, f2, h2, v2);
        }), n2;
      }
      function hg2(e, t2) {
        return e == null ? true : to(e, t2);
      }
      function pg2(e, t2, n2) {
        return e == null ? e : va2(e, t2, io(n2));
      }
      function vg2(e, t2, n2, i) {
        return i = typeof i == "function" ? i : o, e == null ? e : va2(e, t2, io(n2), i);
      }
      function xn(e) {
        return e == null ? [] : Di2(e, Ie2(e));
      }
      function gg2(e) {
        return e == null ? [] : Di2(e, We2(e));
      }
      function _g(e, t2, n2) {
        return n2 === o && (n2 = t2, t2 = o), n2 !== o && (n2 = ot(n2), n2 = n2 === n2 ? n2 : 0), t2 !== o && (t2 = ot(t2), t2 = t2 === t2 ? t2 : 0), nn(ot(e), t2, n2);
      }
      function mg2(e, t2, n2) {
        return t2 = $t(t2), n2 === o ? (n2 = t2, t2 = 0) : n2 = $t(n2), e = ot(e), Ad2(e, t2, n2);
      }
      function wg2(e, t2, n2) {
        if (n2 && typeof n2 != "boolean" && De2(e, t2, n2) && (t2 = n2 = o), n2 === o && (typeof t2 == "boolean" ? (n2 = t2, t2 = o) : typeof e == "boolean" && (n2 = e, e = o)), e === o && t2 === o ? (e = 0, t2 = 1) : (e = $t(e), t2 === o ? (t2 = e, e = 0) : t2 = $t(t2)), e > t2) {
          var i = e;
          e = t2, t2 = i;
        }
        if (n2 || e % 1 || t2 % 1) {
          var s = zs();
          return Re2(e + s * (t2 - e + Xc2("1e-" + ((s + "").length - 1))), t2);
        }
        return Qi2(e, t2);
      }
      var yg2 = Tn(function(e, t2, n2) {
        return t2 = t2.toLowerCase(), e + (n2 ? Cu(t2) : t2);
      });
      function Cu(e) {
        return ko(ae2(e).toLowerCase());
      }
      function Su(e) {
        return e = ae2(e), e && e.replace(bc2, cf2).replace(Uc2, "");
      }
      function bg2(e, t2, n2) {
        e = ae2(e), t2 = Ze2(t2);
        var i = e.length;
        n2 = n2 === o ? i : nn(G2(n2), 0, i);
        var s = n2;
        return n2 -= t2.length, n2 >= 0 && e.slice(n2, s) == t2;
      }
      function Cg2(e) {
        return e = ae2(e), e && tc2.test(e) ? e.replace(es, ff2) : e;
      }
      function Sg2(e) {
        return e = ae2(e), e && ac2.test(e) ? e.replace(yi2, "\\$&") : e;
      }
      var Ag2 = Tn(function(e, t2, n2) {
        return e + (n2 ? "-" : "") + t2.toLowerCase();
      }), Tg2 = Tn(function(e, t2, n2) {
        return e + (n2 ? " " : "") + t2.toLowerCase();
      }), kg2 = ka2("toLowerCase");
      function Ig2(e, t2, n2) {
        e = ae2(e), t2 = G2(t2);
        var i = t2 ? mn(e) : 0;
        if (!t2 || i >= t2)
          return e;
        var s = (t2 - i) / 2;
        return Hr(Er(s), n2) + e + Hr(Or(s), n2);
      }
      function xg2(e, t2, n2) {
        e = ae2(e), t2 = G2(t2);
        var i = t2 ? mn(e) : 0;
        return t2 && i < t2 ? e + Hr(t2 - i, n2) : e;
      }
      function Og2(e, t2, n2) {
        e = ae2(e), t2 = G2(t2);
        var i = t2 ? mn(e) : 0;
        return t2 && i < t2 ? Hr(t2 - i, n2) + e : e;
      }
      function Eg2(e, t2, n2) {
        return n2 || t2 == null ? t2 = 0 : t2 && (t2 = +t2), Mf2(ae2(e).replace(bi2, ""), t2 || 0);
      }
      function Rg2(e, t2, n2) {
        return (n2 ? De2(e, t2, n2) : t2 === o) ? t2 = 1 : t2 = G2(t2), ji2(ae2(e), t2);
      }
      function Lg2() {
        var e = arguments, t2 = ae2(e[0]);
        return e.length < 3 ? t2 : t2.replace(e[1], e[2]);
      }
      var $g2 = Tn(function(e, t2, n2) {
        return e + (n2 ? "_" : "") + t2.toLowerCase();
      });
      function Bg2(e, t2, n2) {
        return n2 && typeof n2 != "number" && De2(e, t2, n2) && (t2 = n2 = o), n2 = n2 === o ? mt : n2 >>> 0, n2 ? (e = ae2(e), e && (typeof t2 == "string" || t2 != null && !So(t2)) && (t2 = Ze2(t2), !t2 && _n(e)) ? qt(ft(e), 0, n2) : e.split(t2, n2)) : [];
      }
      var Pg2 = Tn(function(e, t2, n2) {
        return e + (n2 ? " " : "") + ko(t2);
      });
      function Dg2(e, t2, n2) {
        return e = ae2(e), n2 = n2 == null ? 0 : nn(G2(n2), 0, e.length), t2 = Ze2(t2), e.slice(n2, n2 + t2.length) == t2;
      }
      function Mg2(e, t2, n2) {
        var i = u2.templateSettings;
        n2 && De2(e, t2, n2) && (t2 = o), e = ae2(e), t2 = ti2({}, t2, i, $a);
        var s = ti2({}, t2.imports, i.imports, $a), l2 = Ie2(s), f2 = Di2(s, l2), h2, v2, b = 0, C2 = t2.interpolate || pr, T2 = "__p += '", O2 = Fi2(
          (t2.escape || pr).source + "|" + C2.source + "|" + (C2 === ts ? vc2 : pr).source + "|" + (t2.evaluate || pr).source + "|$",
          "g"
        ), $ = "//# sourceURL=" + (ue2.call(t2, "sourceURL") ? (t2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++zc2 + "]") + `
`;
        e.replace(O2, function(M2, J2, j, Ke2, Me2, Ye2) {
          return j || (j = Ke2), T2 += e.slice(b, Ye2).replace(Cc2, df2), J2 && (h2 = true, T2 += `' +
__e(` + J2 + `) +
'`), Me2 && (v2 = true, T2 += `';
` + Me2 + `;
__p += '`), j && (T2 += `' +
((__t = (` + j + `)) == null ? '' : __t) +
'`), b = Ye2 + M2.length, M2;
        }), T2 += `';
`;
        var D2 = ue2.call(t2, "variable") && t2.variable;
        if (!D2)
          T2 = `with (obj) {
` + T2 + `
}
`;
        else if (hc2.test(D2))
          throw new W2(A2);
        T2 = (v2 ? T2.replace(Jl, "") : T2).replace(Ql, "$1").replace(jl2, "$1;"), T2 = "function(" + (D2 || "obj") + `) {
` + (D2 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (h2 ? ", __e = _.escape" : "") + (v2 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + T2 + `return __p
}`;
        var z2 = Tu(function() {
          return oe2(l2, $ + "return " + T2).apply(o, f2);
        });
        if (z2.source = T2, Co(z2))
          throw z2;
        return z2;
      }
      function Fg2(e) {
        return ae2(e).toLowerCase();
      }
      function Ng2(e) {
        return ae2(e).toUpperCase();
      }
      function Ug2(e, t2, n2) {
        if (e = ae2(e), e && (n2 || t2 === o))
          return Bs(e);
        if (!e || !(t2 = Ze2(t2)))
          return e;
        var i = ft(e), s = ft(t2), l2 = Ps(i, s), f2 = Ds(i, s) + 1;
        return qt(i, l2, f2).join("");
      }
      function Vg2(e, t2, n2) {
        if (e = ae2(e), e && (n2 || t2 === o))
          return e.slice(0, Fs(e) + 1);
        if (!e || !(t2 = Ze2(t2)))
          return e;
        var i = ft(e), s = Ds(i, ft(t2)) + 1;
        return qt(i, 0, s).join("");
      }
      function Wg2(e, t2, n2) {
        if (e = ae2(e), e && (n2 || t2 === o))
          return e.replace(bi2, "");
        if (!e || !(t2 = Ze2(t2)))
          return e;
        var i = ft(e), s = Ps(i, ft(t2));
        return qt(i, s).join("");
      }
      function Hg2(e, t2) {
        var n2 = ci2, i = Dl;
        if (_e(t2)) {
          var s = "separator" in t2 ? t2.separator : s;
          n2 = "length" in t2 ? G2(t2.length) : n2, i = "omission" in t2 ? Ze2(t2.omission) : i;
        }
        e = ae2(e);
        var l2 = e.length;
        if (_n(e)) {
          var f2 = ft(e);
          l2 = f2.length;
        }
        if (n2 >= l2)
          return e;
        var h2 = n2 - mn(i);
        if (h2 < 1)
          return i;
        var v2 = f2 ? qt(f2, 0, h2).join("") : e.slice(0, h2);
        if (s === o)
          return v2 + i;
        if (f2 && (h2 += v2.length - h2), So(s)) {
          if (e.slice(h2).search(s)) {
            var b, C2 = v2;
            for (s.global || (s = Fi2(s.source, ae2(ns.exec(s)) + "g")), s.lastIndex = 0; b = s.exec(C2); )
              var T2 = b.index;
            v2 = v2.slice(0, T2 === o ? h2 : T2);
          }
        } else if (e.indexOf(Ze2(s), h2) != h2) {
          var O2 = v2.lastIndexOf(s);
          O2 > -1 && (v2 = v2.slice(0, O2));
        }
        return v2 + i;
      }
      function Gg2(e) {
        return e = ae2(e), e && ec2.test(e) ? e.replace(jo, wf2) : e;
      }
      var zg2 = Tn(function(e, t2, n2) {
        return e + (n2 ? " " : "") + t2.toUpperCase();
      }), ko = ka2("toUpperCase");
      function Au(e, t2, n2) {
        return e = ae2(e), t2 = n2 ? o : t2, t2 === o ? pf2(e) ? Cf2(e) : of2(e) : e.match(t2) || [];
      }
      var Tu = K2(function(e, t2) {
        try {
          return Ge2(e, o, t2);
        } catch (n2) {
          return Co(n2) ? n2 : new W2(n2);
        }
      }), Zg2 = Et(function(e, t2) {
        return je2(t2, function(n2) {
          n2 = bt(n2), xt(e, n2, yo(e[n2], e));
        }), e;
      });
      function qg2(e) {
        var t2 = e == null ? 0 : e.length, n2 = P2();
        return e = t2 ? ve2(e, function(i) {
          if (typeof i[1] != "function")
            throw new et(_);
          return [n2(i[0]), i[1]];
        }) : [], K2(function(i) {
          for (var s = -1; ++s < t2; ) {
            var l2 = e[s];
            if (Ge2(l2[0], this, i))
              return Ge2(l2[1], this, i);
          }
        });
      }
      function Kg2(e) {
        return wd2(nt(e, V2));
      }
      function Io(e) {
        return function() {
          return e;
        };
      }
      function Yg2(e, t2) {
        return e == null || e !== e ? t2 : e;
      }
      var Xg2 = xa(), Jg2 = xa(true);
      function He2(e) {
        return e;
      }
      function xo(e) {
        return ia2(typeof e == "function" ? e : nt(e, V2));
      }
      function Qg2(e) {
        return sa2(nt(e, V2));
      }
      function jg2(e, t2) {
        return aa2(e, nt(t2, V2));
      }
      var e_ = K2(function(e, t2) {
        return function(n2) {
          return Zn(n2, e, t2);
        };
      }), t_ = K2(function(e, t2) {
        return function(n2) {
          return Zn(e, n2, t2);
        };
      });
      function Oo(e, t2, n2) {
        var i = Ie2(t2), s = Dr(t2, i);
        n2 == null && !(_e(t2) && (s.length || !i.length)) && (n2 = t2, t2 = e, e = this, s = Dr(t2, Ie2(t2)));
        var l2 = !(_e(n2) && "chain" in n2) || !!n2.chain, f2 = Lt(e);
        return je2(s, function(h2) {
          var v2 = t2[h2];
          e[h2] = v2, f2 && (e.prototype[h2] = function() {
            var b = this.__chain__;
            if (l2 || b) {
              var C2 = e(this.__wrapped__), T2 = C2.__actions__ = Ue2(this.__actions__);
              return T2.push({ func: v2, args: arguments, thisArg: e }), C2.__chain__ = b, C2;
            }
            return v2.apply(e, Vt([this.value()], arguments));
          });
        }), e;
      }
      function n_() {
        return xe._ === this && (xe._ = xf2), this;
      }
      function Eo() {
      }
      function r_(e) {
        return e = G2(e), K2(function(t2) {
          return ua2(t2, e);
        });
      }
      var i_ = so(ve2), o_ = so(Os), s_ = so(Ri2);
      function ku(e) {
        return po(e) ? Li2(bt(e)) : Dd2(e);
      }
      function a_(e) {
        return function(t2) {
          return e == null ? o : rn(e, t2);
        };
      }
      var u_ = Ea2(), l_ = Ea2(true);
      function Ro() {
        return [];
      }
      function Lo() {
        return false;
      }
      function c_() {
        return {};
      }
      function f_() {
        return "";
      }
      function d_() {
        return true;
      }
      function h_(e, t2) {
        if (e = G2(e), e < 1 || e > Nt)
          return [];
        var n2 = mt, i = Re2(e, mt);
        t2 = P2(t2), e -= mt;
        for (var s = Pi2(i, t2); ++n2 < e; )
          t2(n2);
        return s;
      }
      function p_(e) {
        return H2(e) ? ve2(e, bt) : qe2(e) ? [e] : Ue2(Za2(ae2(e)));
      }
      function v_(e) {
        var t2 = ++kf;
        return ae2(e) + t2;
      }
      var g_ = Wr(function(e, t2) {
        return e + t2;
      }, 0), __ = ao("ceil"), m_ = Wr(function(e, t2) {
        return e / t2;
      }, 1), w_ = ao("floor");
      function y_(e) {
        return e && e.length ? Pr(e, He2, Zi2) : o;
      }
      function b_(e, t2) {
        return e && e.length ? Pr(e, P2(t2, 2), Zi2) : o;
      }
      function C_(e) {
        return Ls(e, He2);
      }
      function S_(e, t2) {
        return Ls(e, P2(t2, 2));
      }
      function A_(e) {
        return e && e.length ? Pr(e, He2, Xi2) : o;
      }
      function T_(e, t2) {
        return e && e.length ? Pr(e, P2(t2, 2), Xi2) : o;
      }
      var k_ = Wr(function(e, t2) {
        return e * t2;
      }, 1), I_ = ao("round"), x_ = Wr(function(e, t2) {
        return e - t2;
      }, 0);
      function O_(e) {
        return e && e.length ? Bi2(e, He2) : 0;
      }
      function E_(e, t2) {
        return e && e.length ? Bi2(e, P2(t2, 2)) : 0;
      }
      return u2.after = Qp, u2.ary = ru, u2.assign = Nv, u2.assignIn = _u, u2.assignInWith = ti2, u2.assignWith = Uv, u2.at = Vv, u2.before = iu, u2.bind = yo, u2.bindAll = Zg2, u2.bindKey = ou, u2.castArray = cv, u2.chain = eu, u2.chunk = wh2, u2.compact = yh2, u2.concat = bh2, u2.cond = qg2, u2.conforms = Kg2, u2.constant = Io, u2.countBy = Op, u2.create = Wv, u2.curry = su, u2.curryRight = au, u2.debounce = uu, u2.defaults = Hv, u2.defaultsDeep = Gv, u2.defer = jp, u2.delay = ev, u2.difference = Ch2, u2.differenceBy = Sh2, u2.differenceWith = Ah2, u2.drop = Th2, u2.dropRight = kh2, u2.dropRightWhile = Ih2, u2.dropWhile = xh2, u2.fill = Oh2, u2.filter = Rp, u2.flatMap = Bp, u2.flatMapDeep = Pp, u2.flatMapDepth = Dp, u2.flatten = Xa2, u2.flattenDeep = Eh2, u2.flattenDepth = Rh2, u2.flip = tv, u2.flow = Xg2, u2.flowRight = Jg2, u2.fromPairs = Lh2, u2.functions = Jv, u2.functionsIn = Qv, u2.groupBy = Mp, u2.initial = Bh2, u2.intersection = Ph2, u2.intersectionBy = Dh2, u2.intersectionWith = Mh2, u2.invert = eg2, u2.invertBy = tg2, u2.invokeMap = Np, u2.iteratee = xo, u2.keyBy = Up, u2.keys = Ie2, u2.keysIn = We2, u2.map = Yr, u2.mapKeys = rg2, u2.mapValues = ig2, u2.matches = Qg2, u2.matchesProperty = jg2, u2.memoize = Jr, u2.merge = og2, u2.mergeWith = mu, u2.method = e_, u2.methodOf = t_, u2.mixin = Oo, u2.negate = Qr, u2.nthArg = r_, u2.omit = sg2, u2.omitBy = ag2, u2.once = nv, u2.orderBy = Vp, u2.over = i_, u2.overArgs = rv, u2.overEvery = o_, u2.overSome = s_, u2.partial = bo, u2.partialRight = lu, u2.partition = Wp, u2.pick = ug2, u2.pickBy = wu, u2.property = ku, u2.propertyOf = a_, u2.pull = Vh2, u2.pullAll = Qa2, u2.pullAllBy = Wh2, u2.pullAllWith = Hh2, u2.pullAt = Gh2, u2.range = u_, u2.rangeRight = l_, u2.rearg = iv, u2.reject = zp, u2.remove = zh2, u2.rest = ov, u2.reverse = mo, u2.sampleSize = qp, u2.set = cg2, u2.setWith = fg2, u2.shuffle = Kp, u2.slice = Zh2, u2.sortBy = Jp, u2.sortedUniq = jh2, u2.sortedUniqBy = ep, u2.split = Bg2, u2.spread = sv, u2.tail = tp, u2.take = np, u2.takeRight = rp, u2.takeRightWhile = ip, u2.takeWhile = op, u2.tap = yp, u2.throttle = av, u2.thru = Kr, u2.toArray = pu, u2.toPairs = yu, u2.toPairsIn = bu, u2.toPath = p_, u2.toPlainObject = gu, u2.transform = dg2, u2.unary = uv, u2.union = sp, u2.unionBy = ap, u2.unionWith = up, u2.uniq = lp, u2.uniqBy = cp, u2.uniqWith = fp, u2.unset = hg2, u2.unzip = wo, u2.unzipWith = ja2, u2.update = pg2, u2.updateWith = vg2, u2.values = xn, u2.valuesIn = gg2, u2.without = dp, u2.words = Au, u2.wrap = lv, u2.xor = hp, u2.xorBy = pp, u2.xorWith = vp, u2.zip = gp, u2.zipObject = _p, u2.zipObjectDeep = mp, u2.zipWith = wp, u2.entries = yu, u2.entriesIn = bu, u2.extend = _u, u2.extendWith = ti2, Oo(u2, u2), u2.add = g_, u2.attempt = Tu, u2.camelCase = yg2, u2.capitalize = Cu, u2.ceil = __, u2.clamp = _g, u2.clone = fv, u2.cloneDeep = hv, u2.cloneDeepWith = pv, u2.cloneWith = dv, u2.conformsTo = vv, u2.deburr = Su, u2.defaultTo = Yg2, u2.divide = m_, u2.endsWith = bg2, u2.eq = ht, u2.escape = Cg2, u2.escapeRegExp = Sg2, u2.every = Ep, u2.find = Lp, u2.findIndex = Ka2, u2.findKey = zv, u2.findLast = $p, u2.findLastIndex = Ya2, u2.findLastKey = Zv, u2.floor = w_, u2.forEach = tu, u2.forEachRight = nu, u2.forIn = qv, u2.forInRight = Kv, u2.forOwn = Yv, u2.forOwnRight = Xv, u2.get = Ao, u2.gt = gv, u2.gte = _v, u2.has = jv, u2.hasIn = To, u2.head = Ja2, u2.identity = He2, u2.includes = Fp, u2.indexOf = $h2, u2.inRange = mg2, u2.invoke = ng2, u2.isArguments = an, u2.isArray = H2, u2.isArrayBuffer = mv, u2.isArrayLike = Ve2, u2.isArrayLikeObject = Ce2, u2.isBoolean = wv, u2.isBuffer = Kt, u2.isDate = yv, u2.isElement = bv, u2.isEmpty = Cv, u2.isEqual = Sv, u2.isEqualWith = Av, u2.isError = Co, u2.isFinite = Tv, u2.isFunction = Lt, u2.isInteger = cu, u2.isLength = jr, u2.isMap = fu, u2.isMatch = kv, u2.isMatchWith = Iv, u2.isNaN = xv, u2.isNative = Ov, u2.isNil = Rv, u2.isNull = Ev, u2.isNumber = du, u2.isObject = _e, u2.isObjectLike = ye, u2.isPlainObject = Qn, u2.isRegExp = So, u2.isSafeInteger = Lv, u2.isSet = hu, u2.isString = ei2, u2.isSymbol = qe2, u2.isTypedArray = In, u2.isUndefined = $v, u2.isWeakMap = Bv, u2.isWeakSet = Pv, u2.join = Fh2, u2.kebabCase = Ag2, u2.last = it, u2.lastIndexOf = Nh2, u2.lowerCase = Tg2, u2.lowerFirst = kg2, u2.lt = Dv, u2.lte = Mv, u2.max = y_, u2.maxBy = b_, u2.mean = C_, u2.meanBy = S_, u2.min = A_, u2.minBy = T_, u2.stubArray = Ro, u2.stubFalse = Lo, u2.stubObject = c_, u2.stubString = f_, u2.stubTrue = d_, u2.multiply = k_, u2.nth = Uh2, u2.noConflict = n_, u2.noop = Eo, u2.now = Xr, u2.pad = Ig2, u2.padEnd = xg2, u2.padStart = Og2, u2.parseInt = Eg2, u2.random = wg2, u2.reduce = Hp, u2.reduceRight = Gp, u2.repeat = Rg2, u2.replace = Lg2, u2.result = lg2, u2.round = I_, u2.runInContext = p2, u2.sample = Zp, u2.size = Yp, u2.snakeCase = $g2, u2.some = Xp, u2.sortedIndex = qh2, u2.sortedIndexBy = Kh2, u2.sortedIndexOf = Yh2, u2.sortedLastIndex = Xh2, u2.sortedLastIndexBy = Jh2, u2.sortedLastIndexOf = Qh2, u2.startCase = Pg2, u2.startsWith = Dg2, u2.subtract = x_, u2.sum = O_, u2.sumBy = E_, u2.template = Mg2, u2.times = h_, u2.toFinite = $t, u2.toInteger = G2, u2.toLength = vu, u2.toLower = Fg2, u2.toNumber = ot, u2.toSafeInteger = Fv, u2.toString = ae2, u2.toUpper = Ng2, u2.trim = Ug2, u2.trimEnd = Vg2, u2.trimStart = Wg2, u2.truncate = Hg2, u2.unescape = Gg2, u2.uniqueId = v_, u2.upperCase = zg2, u2.upperFirst = ko, u2.each = tu, u2.eachRight = nu, u2.first = Ja2, Oo(u2, function() {
        var e = {};
        return wt(u2, function(t2, n2) {
          ue2.call(u2.prototype, n2) || (e[n2] = t2);
        }), e;
      }(), { chain: false }), u2.VERSION = d, je2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(e) {
        u2[e].placeholder = u2;
      }), je2(["drop", "take"], function(e, t2) {
        Q2.prototype[e] = function(n2) {
          n2 = n2 === o ? 1 : ke2(G2(n2), 0);
          var i = this.__filtered__ && !t2 ? new Q2(this) : this.clone();
          return i.__filtered__ ? i.__takeCount__ = Re2(n2, i.__takeCount__) : i.__views__.push({
            size: Re2(n2, mt),
            type: e + (i.__dir__ < 0 ? "Right" : "")
          }), i;
        }, Q2.prototype[e + "Right"] = function(n2) {
          return this.reverse()[e](n2).reverse();
        };
      }), je2(["filter", "map", "takeWhile"], function(e, t2) {
        var n2 = t2 + 1, i = n2 == Xo || n2 == Ul;
        Q2.prototype[e] = function(s) {
          var l2 = this.clone();
          return l2.__iteratees__.push({
            iteratee: P2(s, 3),
            type: n2
          }), l2.__filtered__ = l2.__filtered__ || i, l2;
        };
      }), je2(["head", "last"], function(e, t2) {
        var n2 = "take" + (t2 ? "Right" : "");
        Q2.prototype[e] = function() {
          return this[n2](1).value()[0];
        };
      }), je2(["initial", "tail"], function(e, t2) {
        var n2 = "drop" + (t2 ? "" : "Right");
        Q2.prototype[e] = function() {
          return this.__filtered__ ? new Q2(this) : this[n2](1);
        };
      }), Q2.prototype.compact = function() {
        return this.filter(He2);
      }, Q2.prototype.find = function(e) {
        return this.filter(e).head();
      }, Q2.prototype.findLast = function(e) {
        return this.reverse().find(e);
      }, Q2.prototype.invokeMap = K2(function(e, t2) {
        return typeof e == "function" ? new Q2(this) : this.map(function(n2) {
          return Zn(n2, e, t2);
        });
      }), Q2.prototype.reject = function(e) {
        return this.filter(Qr(P2(e)));
      }, Q2.prototype.slice = function(e, t2) {
        e = G2(e);
        var n2 = this;
        return n2.__filtered__ && (e > 0 || t2 < 0) ? new Q2(n2) : (e < 0 ? n2 = n2.takeRight(-e) : e && (n2 = n2.drop(e)), t2 !== o && (t2 = G2(t2), n2 = t2 < 0 ? n2.dropRight(-t2) : n2.take(t2 - e)), n2);
      }, Q2.prototype.takeRightWhile = function(e) {
        return this.reverse().takeWhile(e).reverse();
      }, Q2.prototype.toArray = function() {
        return this.take(mt);
      }, wt(Q2.prototype, function(e, t2) {
        var n2 = /^(?:filter|find|map|reject)|While$/.test(t2), i = /^(?:head|last)$/.test(t2), s = u2[i ? "take" + (t2 == "last" ? "Right" : "") : t2], l2 = i || /^find/.test(t2);
        s && (u2.prototype[t2] = function() {
          var f2 = this.__wrapped__, h2 = i ? [1] : arguments, v2 = f2 instanceof Q2, b = h2[0], C2 = v2 || H2(f2), T2 = function(J2) {
            var j = s.apply(u2, Vt([J2], h2));
            return i && O2 ? j[0] : j;
          };
          C2 && n2 && typeof b == "function" && b.length != 1 && (v2 = C2 = false);
          var O2 = this.__chain__, $ = !!this.__actions__.length, D2 = l2 && !O2, z2 = v2 && !$;
          if (!l2 && C2) {
            f2 = z2 ? f2 : new Q2(this);
            var M2 = e.apply(f2, h2);
            return M2.__actions__.push({ func: Kr, args: [T2], thisArg: o }), new tt(M2, O2);
          }
          return D2 && z2 ? e.apply(this, h2) : (M2 = this.thru(T2), D2 ? i ? M2.value()[0] : M2.value() : M2);
        });
      }), je2(["pop", "push", "shift", "sort", "splice", "unshift"], function(e) {
        var t2 = yr[e], n2 = /^(?:push|sort|unshift)$/.test(e) ? "tap" : "thru", i = /^(?:pop|shift)$/.test(e);
        u2.prototype[e] = function() {
          var s = arguments;
          if (i && !this.__chain__) {
            var l2 = this.value();
            return t2.apply(H2(l2) ? l2 : [], s);
          }
          return this[n2](function(f2) {
            return t2.apply(H2(f2) ? f2 : [], s);
          });
        };
      }), wt(Q2.prototype, function(e, t2) {
        var n2 = u2[t2];
        if (n2) {
          var i = n2.name + "";
          ue2.call(Cn, i) || (Cn[i] = []), Cn[i].push({ name: t2, func: n2 });
        }
      }), Cn[Vr(o, Z2).name] = [{
        name: "wrapper",
        func: o
      }], Q2.prototype.clone = Gf2, Q2.prototype.reverse = zf2, Q2.prototype.value = Zf2, u2.prototype.at = bp, u2.prototype.chain = Cp, u2.prototype.commit = Sp, u2.prototype.next = Ap, u2.prototype.plant = kp, u2.prototype.reverse = Ip, u2.prototype.toJSON = u2.prototype.valueOf = u2.prototype.value = xp, u2.prototype.first = u2.prototype.head, Nn && (u2.prototype[Nn] = Tp), u2;
    }, wn = Sf2();
    Qt ? ((Qt.exports = wn)._ = wn, Ii2._ = wn) : xe._ = wn;
  }).call(jn);
})(ii$1, ii$1.exports);
ii$1.exports;
const Be$1 = (r2, a) => {
  const o = r2.__vccOpts || r2;
  for (const [d, c] of a)
    o[d] = c;
  return o;
};
const V0 = ["width", "height"], W0 = /* @__PURE__ */ createStaticVNode('<defs data-v-af9e8924><radialGradient id="paint0_angular_102_1932" cx="24" cy="0" r="48" gradientUnits="userSpaceOnUse" data-v-af9e8924><stop offset="0.177083" stop-color="currentColor" stop-opacity="0.5" data-v-af9e8924></stop><stop offset="1" stop-color="currentColor" stop-opacity="0" data-v-af9e8924></stop></radialGradient></defs><circle cx="24" cy="24" r="23" stroke="currentColor" stroke-opacity="0.1" stroke-width="2" data-v-af9e8924></circle><path fill-rule="evenodd" clip-rule="evenodd" d="M24 0C10.7452 0 0 10.7452 0 24C0 37.2548 10.7452 48 24 48V46C11.8497 46 2 36.1503 2 24C2 11.8497 11.8497 2 24 2V0Z" fill="url(#paint0_angular_102_1932)" data-v-af9e8924></path><circle cx="24" cy="1" r="1" fill="currentColor" data-v-af9e8924></circle><animateTransform from="0 0 0" to="360 0 0" attributeName="transform" type="rotate" repeatCount="indefinite" dur="1300ms" data-v-af9e8924></animateTransform>', 5), H0 = [
  W0
], G0 = /* @__PURE__ */ defineComponent({
  __name: "CdekSpinner",
  props: {
    color: { default: "green" },
    size: { default: "small" }
  },
  setup(r2) {
    const a = r2, o = {
      small: 24,
      medium: 32,
      big: 48
    }, d = computed(() => o[a.size] || a.size), c = computed(() => ["green", "white"].includes(a.color) ? {} : {
      "--spinner-color": a.color
    });
    return (g, _) => (openBlock(), createElementBlock("svg", {
      class: normalizeClass(["spinner", { white: g.color === "white" }]),
      style: normalizeStyle(c.value),
      width: d.value,
      height: d.value,
      viewBox: "0 0 48 48",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, H0, 14, V0));
  }
});
const Ku = /* @__PURE__ */ Be$1(G0, [["__scopeId", "data-v-af9e8924"]]), z0 = ["disabled"], Z0 = /* @__PURE__ */ defineComponent({
  __name: "CdekButton",
  props: {
    theme: { default: "primary" },
    width: { default: "auto" },
    small: { type: Boolean },
    disabled: { type: Boolean },
    loading: { type: Boolean },
    spinnerBefore: { type: Boolean },
    icon: { type: Boolean }
  },
  setup(r2) {
    const a = r2, o = computed(() => a.theme === "primary" || a.theme === "toaster" || a.disabled ? "white" : "green");
    return (d, c) => (openBlock(), createElementBlock("button", {
      class: normalizeClass(["cdek-button", {
        [d.theme]: true,
        small: d.small,
        inline: d.width === "content",
        icon: d.icon
      }]),
      disabled: d.disabled
    }, [
      d.loading ? (openBlock(), createBlock(Ku, {
        key: 0,
        color: o.value
      }, null, 8, ["color"])) : createCommentVNode("", true),
      !d.loading || d.spinnerBefore ? renderSlot(d.$slots, "default", { key: 1 }, void 0, true) : createCommentVNode("", true)
    ], 10, z0));
  }
});
const Do = /* @__PURE__ */ Be$1(Z0, [["__scopeId", "data-v-38cc074e"]]);
let oi$1 = class oi {
  init() {
  }
};
Xe$1(oi$1, "instance", null), /**
*      
*/
Xe$1(oi$1, "scopedInstances", {});
var Mo = ((r2) => (r2[r2.None = 0] = "None", r2[r2.RenderStrategy = 1] = "RenderStrategy", r2[r2.Static = 2] = "Static", r2))(Mo || {}), b1 = ((r2) => (r2[r2.Unmount = 0] = "Unmount", r2[r2.Hidden = 1] = "Hidden", r2))(b1 || {});
var Ae$1 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(Ae$1 || {});
var Fe$1 = ((r2) => (r2[r2.First = 0] = "First", r2[r2.Previous = 1] = "Previous", r2[r2.Next = 2] = "Next", r2[r2.Last = 3] = "Last", r2[r2.Specific = 4] = "Specific", r2[r2.Nothing = 5] = "Nothing", r2))(Fe$1 || {});
var ir = ((r2) => (r2[r2.Open = 1] = "Open", r2[r2.Closed = 2] = "Closed", r2[r2.Closing = 4] = "Closing", r2[r2.Opening = 8] = "Opening", r2))(ir || {});
var O1 = Object.defineProperty, E1 = (r2, a, o) => a in r2 ? O1(r2, a, { enumerable: true, configurable: true, writable: true, value: o }) : r2[a] = o, Eu = (r2, a, o) => (E1(r2, typeof a != "symbol" ? a + "" : a, o), o);
let R1 = class {
  constructor() {
    Eu(this, "current", this.detect()), Eu(this, "currentId", 0);
  }
  set(a) {
    this.current !== a && (this.currentId = 0, this.current = a);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
};
new R1();
var $1 = ((r2) => (r2[r2.First = 1] = "First", r2[r2.Previous = 2] = "Previous", r2[r2.Next = 4] = "Next", r2[r2.Last = 8] = "Last", r2[r2.WrapAround = 16] = "WrapAround", r2[r2.NoScroll = 32] = "NoScroll", r2))($1 || {}), B1 = ((r2) => (r2[r2.Error = 0] = "Error", r2[r2.Overflow = 1] = "Overflow", r2[r2.Success = 2] = "Success", r2[r2.Underflow = 3] = "Underflow", r2))(B1 || {}), P1 = ((r2) => (r2[r2.Previous = -1] = "Previous", r2[r2.Next = 1] = "Next", r2))(P1 || {}), Zo = ((r2) => (r2[r2.Strict = 0] = "Strict", r2[r2.Loose = 1] = "Loose", r2))(Zo || {});
var qo = ((r2) => (r2[r2.None = 1] = "None", r2[r2.Focusable = 2] = "Focusable", r2[r2.Hidden = 4] = "Hidden", r2))(qo || {});
var H1 = ((r2) => (r2[r2.Open = 0] = "Open", r2[r2.Closed = 1] = "Closed", r2))(H1 || {}), G1 = ((r2) => (r2[r2.Single = 0] = "Single", r2[r2.Multi = 1] = "Multi", r2))(G1 || {}), z1 = ((r2) => (r2[r2.Pointer = 0] = "Pointer", r2[r2.Other = 1] = "Other", r2))(z1 || {});
var ui$1 = (r2) => typeof r2 == "function", li$1 = (r2) => typeof r2 == "string", ml$1 = (r2) => li$1(r2) && r2.trim().length > 0, Sw = (r2) => typeof r2 == "number", un = (r2) => typeof r2 > "u", or = (r2) => typeof r2 == "object" && r2 !== null, Aw = (r2) => St(r2, "tag") && ml$1(r2.tag), wl$1 = (r2) => window.TouchEvent && r2 instanceof TouchEvent, yl = (r2) => St(r2, "component") && bl$1(r2.component), Tw = (r2) => ui$1(r2) || or(r2), bl$1 = (r2) => !un(r2) && (li$1(r2) || Tw(r2) || yl(r2)), Du = (r2) => or(r2) && ["height", "width", "right", "left", "top", "bottom"].every((a) => Sw(r2[a])), St = (r2, a) => (or(r2) || ui$1(r2)) && a in r2;
function Po(r2) {
  return wl$1(r2) ? r2.targetTouches[0].clientX : r2.clientX;
}
function Mu(r2) {
  return wl$1(r2) ? r2.targetTouches[0].clientY : r2.clientY;
}
var Iw = (r2) => {
  un(r2.remove) ? r2.parentNode && r2.parentNode.removeChild(r2) : r2.remove();
}, ur = (r2) => yl(r2) ? ur(r2.component) : Aw(r2) ? defineComponent({
  render() {
    return r2;
  }
}) : typeof r2 == "string" ? r2 : toRaw(unref(r2)), xw = (r2) => {
  if (typeof r2 == "string")
    return r2;
  const a = St(r2, "props") && or(r2.props) ? r2.props : {}, o = St(r2, "listeners") && or(r2.listeners) ? r2.listeners : {};
  return { component: ur(r2), props: a, listeners: o };
}, Yo = class {
  constructor() {
    this.allHandlers = {};
  }
  getHandlers(r2) {
    return this.allHandlers[r2] || [];
  }
  on(r2, a) {
    const o = this.getHandlers(r2);
    o.push(a), this.allHandlers[r2] = o;
  }
  off(r2, a) {
    const o = this.getHandlers(r2);
    o.splice(o.indexOf(a) >>> 0, 1);
  }
  emit(r2, a) {
    this.getHandlers(r2).forEach((d) => d(a));
  }
}, $e$1;
(function(r2) {
  r2.SUCCESS = "success", r2.ERROR = "error", r2.WARNING = "warning", r2.INFO = "info", r2.DEFAULT = "default";
})($e$1 || ($e$1 = {}));
var On;
(function(r2) {
  r2.TOP_LEFT = "top-left", r2.TOP_CENTER = "top-center", r2.TOP_RIGHT = "top-right", r2.BOTTOM_LEFT = "bottom-left", r2.BOTTOM_CENTER = "bottom-center", r2.BOTTOM_RIGHT = "bottom-right";
})(On || (On = {}));
var Je$1;
(function(r2) {
  r2.ADD = "add", r2.DISMISS = "dismiss", r2.UPDATE = "update", r2.CLEAR = "clear", r2.UPDATE_DEFAULTS = "update_defaults";
})(Je$1 || (Je$1 = {}));
var gt = "Vue-Toastification", vt = {
  type: {
    type: String,
    default: $e$1.DEFAULT
  },
  classNames: {
    type: [String, Array],
    default: () => []
  },
  trueBoolean: {
    type: Boolean,
    default: true
  }
}, Cl = {
  type: vt.type,
  customIcon: {
    type: [String, Boolean, Object, Function],
    default: true
  }
}, ri$1 = {
  component: {
    type: [String, Object, Function, Boolean],
    default: "button"
  },
  classNames: vt.classNames,
  showOnHover: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "close"
  }
}, No = {
  timeout: {
    type: [Number, Boolean],
    default: 5e3
  },
  hideProgressBar: {
    type: Boolean,
    default: false
  },
  isRunning: {
    type: Boolean,
    default: false
  }
}, Sl = {
  transition: {
    type: [Object, String],
    default: `${gt}__bounce`
  }
}, Rw = {
  position: {
    type: String,
    default: On.TOP_RIGHT
  },
  draggable: vt.trueBoolean,
  draggablePercent: {
    type: Number,
    default: 0.6
  },
  pauseOnFocusLoss: vt.trueBoolean,
  pauseOnHover: vt.trueBoolean,
  closeOnClick: vt.trueBoolean,
  timeout: No.timeout,
  hideProgressBar: No.hideProgressBar,
  toastClassName: vt.classNames,
  bodyClassName: vt.classNames,
  icon: Cl.customIcon,
  closeButton: ri$1.component,
  closeButtonClassName: ri$1.classNames,
  showCloseButtonOnHover: ri$1.showOnHover,
  accessibility: {
    type: Object,
    default: () => ({
      toastRole: "alert",
      closeButtonLabel: "close"
    })
  },
  rtl: {
    type: Boolean,
    default: false
  },
  eventBus: {
    type: Object,
    required: false,
    default: () => new Yo()
  }
}, Lw = {
  id: {
    type: [String, Number],
    required: true,
    default: 0
  },
  type: vt.type,
  content: {
    type: [String, Object, Function],
    required: true,
    default: ""
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onClose: {
    type: Function,
    default: void 0
  }
}, $w = {
  container: {
    type: [
      Object,
      Function
    ],
    default: () => document.body
  },
  newestOnTop: vt.trueBoolean,
  maxToasts: {
    type: Number,
    default: 20
  },
  transition: Sl.transition,
  toastDefaults: Object,
  filterBeforeCreate: {
    type: Function,
    default: (r2) => r2
  },
  filterToasts: {
    type: Function,
    default: (r2) => r2
  },
  containerClassName: vt.classNames,
  onMounted: Function,
  shareAppContext: [Boolean, Object]
}, Dt = {
  CORE_TOAST: Rw,
  TOAST: Lw,
  CONTAINER: $w,
  PROGRESS_BAR: No,
  ICON: Cl,
  TRANSITION: Sl,
  CLOSE_BUTTON: ri$1
}, Al = defineComponent({
  name: "VtProgressBar",
  props: Dt.PROGRESS_BAR,
  data() {
    return {
      hasClass: true
    };
  },
  computed: {
    style() {
      return {
        animationDuration: `${this.timeout}ms`,
        animationPlayState: this.isRunning ? "running" : "paused",
        opacity: this.hideProgressBar ? 0 : 1
      };
    },
    cpClass() {
      return this.hasClass ? `${gt}__progress-bar` : "";
    }
  },
  watch: {
    timeout() {
      this.hasClass = false, this.$nextTick(() => this.hasClass = true);
    }
  },
  mounted() {
    this.$el.addEventListener("animationend", this.animationEnded);
  },
  beforeUnmount() {
    this.$el.removeEventListener("animationend", this.animationEnded);
  },
  methods: {
    animationEnded() {
      this.$emit("close-toast");
    }
  }
});
function Bw(r2, a) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle(r2.style),
    class: normalizeClass(r2.cpClass)
  }, null, 6);
}
Al.render = Bw;
var Pw = Al, Tl = defineComponent({
  name: "VtCloseButton",
  props: Dt.CLOSE_BUTTON,
  computed: {
    buttonComponent() {
      return this.component !== false ? ur(this.component) : "button";
    },
    classes() {
      const r2 = [`${gt}__close-button`];
      return this.showOnHover && r2.push("show-on-hover"), r2.concat(this.classNames);
    }
  }
}), Dw = /* @__PURE__ */ createTextVNode("  ");
function Mw(r2, a) {
  return openBlock(), createBlock(resolveDynamicComponent(r2.buttonComponent), mergeProps({
    "aria-label": r2.ariaLabel,
    class: r2.classes
  }, r2.$attrs), {
    default: withCtx(() => [
      Dw
    ]),
    _: 1
  }, 16, ["aria-label", "class"]);
}
Tl.render = Mw;
var Fw = Tl, kl$1 = {}, Nw = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "check-circle",
  class: "svg-inline--fa fa-check-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
}, Uw = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
}, null, -1), Vw = [
  Uw
];
function Ww(r2, a) {
  return openBlock(), createElementBlock("svg", Nw, Vw);
}
kl$1.render = Ww;
var Hw = kl$1, Il = {}, Gw = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "info-circle",
  class: "svg-inline--fa fa-info-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
}, zw = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
}, null, -1), Zw = [
  zw
];
function qw(r2, a) {
  return openBlock(), createElementBlock("svg", Gw, Zw);
}
Il.render = qw;
var Fu = Il, xl = {}, Kw = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-circle",
  class: "svg-inline--fa fa-exclamation-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
}, Yw = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1), Xw = [
  Yw
];
function Jw(r2, a) {
  return openBlock(), createElementBlock("svg", Kw, Xw);
}
xl.render = Jw;
var Qw = xl, Ol = {}, jw = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-triangle",
  class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
}, ey = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1), ty = [
  ey
];
function ny(r2, a) {
  return openBlock(), createElementBlock("svg", jw, ty);
}
Ol.render = ny;
var ry = Ol, El = defineComponent({
  name: "VtIcon",
  props: Dt.ICON,
  computed: {
    customIconChildren() {
      return St(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
    },
    customIconClass() {
      return li$1(this.customIcon) ? this.trimValue(this.customIcon) : St(this.customIcon, "iconClass") ? this.trimValue(this.customIcon.iconClass) : "";
    },
    customIconTag() {
      return St(this.customIcon, "iconTag") ? this.trimValue(this.customIcon.iconTag, "i") : "i";
    },
    hasCustomIcon() {
      return this.customIconClass.length > 0;
    },
    component() {
      return this.hasCustomIcon ? this.customIconTag : bl$1(this.customIcon) ? ur(this.customIcon) : this.iconTypeComponent;
    },
    iconTypeComponent() {
      return {
        [$e$1.DEFAULT]: Fu,
        [$e$1.INFO]: Fu,
        [$e$1.SUCCESS]: Hw,
        [$e$1.ERROR]: ry,
        [$e$1.WARNING]: Qw
      }[this.type];
    },
    iconClasses() {
      const r2 = [`${gt}__icon`];
      return this.hasCustomIcon ? r2.concat(this.customIconClass) : r2;
    }
  },
  methods: {
    trimValue(r2, a = "") {
      return ml$1(r2) ? r2.trim() : a;
    }
  }
});
function iy(r2, a) {
  return openBlock(), createBlock(resolveDynamicComponent(r2.component), {
    class: normalizeClass(r2.iconClasses)
  }, {
    default: withCtx(() => [
      createTextVNode(toDisplayString$1(r2.customIconChildren), 1)
    ]),
    _: 1
  }, 8, ["class"]);
}
El.render = iy;
var oy = El, Rl = defineComponent({
  name: "VtToast",
  components: { ProgressBar: Pw, CloseButton: Fw, Icon: oy },
  inheritAttrs: false,
  props: Object.assign({}, Dt.CORE_TOAST, Dt.TOAST),
  data() {
    return {
      isRunning: true,
      disableTransitions: false,
      beingDragged: false,
      dragStart: 0,
      dragPos: { x: 0, y: 0 },
      dragRect: {}
    };
  },
  computed: {
    classes() {
      const r2 = [
        `${gt}__toast`,
        `${gt}__toast--${this.type}`,
        `${this.position}`
      ].concat(this.toastClassName);
      return this.disableTransitions && r2.push("disable-transition"), this.rtl && r2.push(`${gt}__toast--rtl`), r2;
    },
    bodyClasses() {
      return [
        `${gt}__toast-${li$1(this.content) ? "body" : "component-body"}`
      ].concat(this.bodyClassName);
    },
    draggableStyle() {
      return this.dragStart === this.dragPos.x ? {} : this.beingDragged ? {
        transform: `translateX(${this.dragDelta}px)`,
        opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
      } : {
        transition: "transform 0.2s, opacity 0.2s",
        transform: "translateX(0)",
        opacity: 1
      };
    },
    dragDelta() {
      return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
    },
    removalDistance() {
      return Du(this.dragRect) ? (this.dragRect.right - this.dragRect.left) * this.draggablePercent : 0;
    }
  },
  mounted() {
    this.draggable && this.draggableSetup(), this.pauseOnFocusLoss && this.focusSetup();
  },
  beforeUnmount() {
    this.draggable && this.draggableCleanup(), this.pauseOnFocusLoss && this.focusCleanup();
  },
  methods: {
    hasProp: St,
    getVueComponentFromObj: ur,
    closeToast() {
      this.eventBus.emit(Je$1.DISMISS, this.id);
    },
    clickHandler() {
      this.onClick && this.onClick(this.closeToast), this.closeOnClick && (!this.beingDragged || this.dragStart === this.dragPos.x) && this.closeToast();
    },
    timeoutHandler() {
      this.closeToast();
    },
    hoverPause() {
      this.pauseOnHover && (this.isRunning = false);
    },
    hoverPlay() {
      this.pauseOnHover && (this.isRunning = true);
    },
    focusPause() {
      this.isRunning = false;
    },
    focusPlay() {
      this.isRunning = true;
    },
    focusSetup() {
      addEventListener("blur", this.focusPause), addEventListener("focus", this.focusPlay);
    },
    focusCleanup() {
      removeEventListener("blur", this.focusPause), removeEventListener("focus", this.focusPlay);
    },
    draggableSetup() {
      const r2 = this.$el;
      r2.addEventListener("touchstart", this.onDragStart, {
        passive: true
      }), r2.addEventListener("mousedown", this.onDragStart), addEventListener("touchmove", this.onDragMove, { passive: false }), addEventListener("mousemove", this.onDragMove), addEventListener("touchend", this.onDragEnd), addEventListener("mouseup", this.onDragEnd);
    },
    draggableCleanup() {
      const r2 = this.$el;
      r2.removeEventListener("touchstart", this.onDragStart), r2.removeEventListener("mousedown", this.onDragStart), removeEventListener("touchmove", this.onDragMove), removeEventListener("mousemove", this.onDragMove), removeEventListener("touchend", this.onDragEnd), removeEventListener("mouseup", this.onDragEnd);
    },
    onDragStart(r2) {
      this.beingDragged = true, this.dragPos = { x: Po(r2), y: Mu(r2) }, this.dragStart = Po(r2), this.dragRect = this.$el.getBoundingClientRect();
    },
    onDragMove(r2) {
      this.beingDragged && (r2.preventDefault(), this.isRunning && (this.isRunning = false), this.dragPos = { x: Po(r2), y: Mu(r2) });
    },
    onDragEnd() {
      this.beingDragged && (Math.abs(this.dragDelta) >= this.removalDistance ? (this.disableTransitions = true, this.$nextTick(() => this.closeToast())) : setTimeout(() => {
        this.beingDragged = false, Du(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right ? this.isRunning = false : this.isRunning = true;
      }));
    }
  }
}), sy = ["role"];
function ay(r2, a) {
  const o = resolveComponent("Icon"), d = resolveComponent("CloseButton"), c = resolveComponent("ProgressBar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(r2.classes),
    style: normalizeStyle(r2.draggableStyle),
    onClick: a[0] || (a[0] = (...g) => r2.clickHandler && r2.clickHandler(...g)),
    onMouseenter: a[1] || (a[1] = (...g) => r2.hoverPause && r2.hoverPause(...g)),
    onMouseleave: a[2] || (a[2] = (...g) => r2.hoverPlay && r2.hoverPlay(...g))
  }, [
    r2.icon ? (openBlock(), createBlock(o, {
      key: 0,
      "custom-icon": r2.icon,
      type: r2.type
    }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
    createBaseVNode("div", {
      role: r2.accessibility.toastRole || "alert",
      class: normalizeClass(r2.bodyClasses)
    }, [
      typeof r2.content == "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString$1(r2.content), 1)
      ], 2112)) : (openBlock(), createBlock(resolveDynamicComponent(r2.getVueComponentFromObj(r2.content)), mergeProps({
        key: 1,
        "toast-id": r2.id
      }, r2.hasProp(r2.content, "props") ? r2.content.props : {}, toHandlers(r2.hasProp(r2.content, "listeners") ? r2.content.listeners : {}), { onCloseToast: r2.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
    ], 10, sy),
    r2.closeButton ? (openBlock(), createBlock(d, {
      key: 1,
      component: r2.closeButton,
      "class-names": r2.closeButtonClassName,
      "show-on-hover": r2.showCloseButtonOnHover,
      "aria-label": r2.accessibility.closeButtonLabel,
      onClick: withModifiers(r2.closeToast, ["stop"])
    }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
    r2.timeout ? (openBlock(), createBlock(c, {
      key: 2,
      "is-running": r2.isRunning,
      "hide-progress-bar": r2.hideProgressBar,
      timeout: r2.timeout,
      onCloseToast: r2.timeoutHandler
    }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
  ], 38);
}
Rl.render = ay;
var uy = Rl, Ll = defineComponent({
  name: "VtTransition",
  props: Dt.TRANSITION,
  emits: ["leave"],
  methods: {
    hasProp: St,
    leave(r2) {
      r2 instanceof HTMLElement && (r2.style.left = r2.offsetLeft + "px", r2.style.top = r2.offsetTop + "px", r2.style.width = getComputedStyle(r2).width, r2.style.position = "absolute");
    }
  }
});
function ly(r2, a) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    "enter-active-class": r2.transition.enter ? r2.transition.enter : `${r2.transition}-enter-active`,
    "move-class": r2.transition.move ? r2.transition.move : `${r2.transition}-move`,
    "leave-active-class": r2.transition.leave ? r2.transition.leave : `${r2.transition}-leave-active`,
    onLeave: r2.leave
  }, {
    default: withCtx(() => [
      renderSlot(r2.$slots, "default")
    ]),
    _: 3
  }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
}
Ll.render = ly;
var cy = Ll, $l = defineComponent({
  name: "VueToastification",
  devtools: {
    hide: true
  },
  components: { Toast: uy, VtTransition: cy },
  props: Object.assign({}, Dt.CORE_TOAST, Dt.CONTAINER, Dt.TRANSITION),
  data() {
    return {
      count: 0,
      positions: Object.values(On),
      toasts: {},
      defaults: {}
    };
  },
  computed: {
    toastArray() {
      return Object.values(this.toasts);
    },
    filteredToasts() {
      return this.defaults.filterToasts(this.toastArray);
    }
  },
  beforeMount() {
    const r2 = this.eventBus;
    r2.on(Je$1.ADD, this.addToast), r2.on(Je$1.CLEAR, this.clearToasts), r2.on(Je$1.DISMISS, this.dismissToast), r2.on(Je$1.UPDATE, this.updateToast), r2.on(Je$1.UPDATE_DEFAULTS, this.updateDefaults), this.defaults = this.$props;
  },
  mounted() {
    this.setup(this.container);
  },
  methods: {
    async setup(r2) {
      ui$1(r2) && (r2 = await r2()), Iw(this.$el), r2.appendChild(this.$el);
    },
    setToast(r2) {
      un(r2.id) || (this.toasts[r2.id] = r2);
    },
    addToast(r2) {
      r2.content = xw(r2.content);
      const a = Object.assign({}, this.defaults, r2.type && this.defaults.toastDefaults && this.defaults.toastDefaults[r2.type], r2), o = this.defaults.filterBeforeCreate(a, this.toastArray);
      o && this.setToast(o);
    },
    dismissToast(r2) {
      const a = this.toasts[r2];
      !un(a) && !un(a.onClose) && a.onClose(), delete this.toasts[r2];
    },
    clearToasts() {
      Object.keys(this.toasts).forEach((r2) => {
        this.dismissToast(r2);
      });
    },
    getPositionToasts(r2) {
      const a = this.filteredToasts.filter((o) => o.position === r2).slice(0, this.defaults.maxToasts);
      return this.defaults.newestOnTop ? a.reverse() : a;
    },
    updateDefaults(r2) {
      un(r2.container) || this.setup(r2.container), this.defaults = Object.assign({}, this.defaults, r2);
    },
    updateToast({
      id: r2,
      options: a,
      create: o
    }) {
      this.toasts[r2] ? (a.timeout && a.timeout === this.toasts[r2].timeout && a.timeout++, this.setToast(Object.assign({}, this.toasts[r2], a))) : o && this.addToast(Object.assign({}, { id: r2 }, a));
    },
    getClasses(r2) {
      return [`${gt}__container`, r2].concat(this.defaults.containerClassName);
    }
  }
});
function fy(r2, a) {
  const o = resolveComponent("Toast"), d = resolveComponent("VtTransition");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(r2.positions, (c) => (openBlock(), createElementBlock("div", { key: c }, [
      createVNode(d, {
        transition: r2.defaults.transition,
        class: normalizeClass(r2.getClasses(c))
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(r2.getPositionToasts(c), (g) => (openBlock(), createBlock(o, mergeProps({
            key: g.id
          }, g), null, 16))), 128))
        ]),
        _: 2
      }, 1032, ["transition", "class"])
    ]))), 128))
  ]);
}
$l.render = fy;
const LoaderComponent = /* @__PURE__ */ defineComponent({
  render: () => h("div", {
    class: "twc-w-full twc-h-full twc-bg-gray-100 twc-flex twc-justify-center twc-items-center twc-absolute twc-z-[9999]"
  }, [h(Ku, {
    size: 100
  })])
});
const ErrorMessageComponent = /* @__PURE__ */ defineComponent({
  render() {
    return h("div", {
      class: "twc-w-full twc-h-full twc-bg-gray-100 twc-flex twc-justify-center twc-items-center twc-absolute twc-z-[9999]"
    }, [h(
      "h1",
      {
        class: "twc-text-xl"
      },
      // @ts-ignore-next-line
      [this.$t("error")]
    )]);
  }
});
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var react = { exports: {} };
var react_production_min = {};
/**
* @license React
* react.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var l$1 = Symbol.for("react.element"), n$1 = Symbol.for("react.portal"), p$2 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v$1 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z$1 = Symbol.iterator;
function A$1(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = z$1 && a[z$1] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a, b, "setState");
};
E$1.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function F() {
}
F.prototype = E$1.prototype;
function G$1(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = D$1;
  this.updater = e || B$1;
}
var H$1 = G$1.prototype = new F();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$1(a, b, e) {
  var d, c = {}, k2 = null, h2 = null;
  if (null != b)
    for (d in void 0 !== b.ref && (h2 = b.ref), void 0 !== b.key && (k2 = "" + b.key), b)
      J.call(b, d) && !L$1.hasOwnProperty(d) && (c[d] = b[d]);
  var g = arguments.length - 2;
  if (1 === g)
    c.children = e;
  else if (1 < g) {
    for (var f2 = Array(g), m2 = 0; m2 < g; m2++)
      f2[m2] = arguments[m2 + 2];
    c.children = f2;
  }
  if (a && a.defaultProps)
    for (d in g = a.defaultProps, g)
      void 0 === c[d] && (c[d] = g[d]);
  return { $$typeof: l$1, type: a, key: k2, ref: h2, props: c, _owner: K$1.current };
}
function N$1(a, b) {
  return { $$typeof: l$1, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function O$1(a) {
  return "object" === typeof a && null !== a && a.$$typeof === l$1;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var P$1 = /\/+/g;
function Q$1(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}
function R$1(a, b, e, d, c) {
  var k2 = typeof a;
  if ("undefined" === k2 || "boolean" === k2)
    a = null;
  var h2 = false;
  if (null === a)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l$1:
          case n$1:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a, c = c(h2), a = "" === d ? "." + Q$1(h2, 0) : d, I$1(c) ? (e = "", null != a && (e = a.replace(P$1, "$&/") + "/"), R$1(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O$1(c) && (c = N$1(c, e + (!c.key || h2 && h2.key === c.key ? "" : ("" + c.key).replace(P$1, "$&/") + "/") + a)), b.push(c)), 1;
  h2 = 0;
  d = "" === d ? "." : d + ":";
  if (I$1(a))
    for (var g = 0; g < a.length; g++) {
      k2 = a[g];
      var f2 = d + Q$1(k2, g);
      h2 += R$1(k2, b, e, f2, c);
    }
  else if (f2 = A$1(a), "function" === typeof f2)
    for (a = f2.call(a), g = 0; !(k2 = a.next()).done; )
      k2 = k2.value, f2 = d + Q$1(k2, g++), h2 += R$1(k2, b, e, f2, c);
  else if ("object" === k2)
    throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$1(a, b, e) {
  if (null == a)
    return a;
  var d = [], c = 0;
  R$1(a, d, "", "", function(a2) {
    return b.call(e, a2, c++);
  });
  return d;
}
function T$1(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function(b2) {
      if (0 === a._status || -1 === a._status)
        a._status = 1, a._result = b2;
    }, function(b2) {
      if (0 === a._status || -1 === a._status)
        a._status = 2, a._result = b2;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }
  if (1 === a._status)
    return a._result.default;
  throw a._result;
}
var U$1 = { current: null }, V$1 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$1, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$1, forEach: function(a, b, e) {
  S$1(a, function() {
    b.apply(this, arguments);
  }, e);
}, count: function(a) {
  var b = 0;
  S$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return S$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!O$1(a))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$2;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a, b, e) {
  if (null === a || void 0 === a)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
  var d = C$1({}, a.props), c = a.key, k2 = a.ref, h2 = a._owner;
  if (null != b) {
    void 0 !== b.ref && (k2 = b.ref, h2 = K$1.current);
    void 0 !== b.key && (c = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f2 in b)
      J.call(b, f2) && !L$1.hasOwnProperty(f2) && (d[f2] = void 0 === b[f2] && void 0 !== g ? g[f2] : b[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d.children = e;
  else if (1 < f2) {
    g = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g[m2] = arguments[m2 + 2];
    d.children = g;
  }
  return { $$typeof: l$1, type: a.type, key: c, ref: k2, props: d, _owner: h2 };
};
react_production_min.createContext = function(a) {
  a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a.Provider = { $$typeof: t, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = M$1;
react_production_min.createFactory = function(a) {
  var b = M$1.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: v$1, render: a };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a) {
  return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T$1 };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
};
react_production_min.startTransition = function(a) {
  var b = V$1.transition;
  V$1.transition = {};
  try {
    a();
  } finally {
    V$1.transition = b;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a, b) {
  return U$1.current.useCallback(a, b);
};
react_production_min.useContext = function(a) {
  return U$1.current.useContext(a);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a) {
  return U$1.current.useDeferredValue(a);
};
react_production_min.useEffect = function(a, b) {
  return U$1.current.useEffect(a, b);
};
react_production_min.useId = function() {
  return U$1.current.useId();
};
react_production_min.useImperativeHandle = function(a, b, e) {
  return U$1.current.useImperativeHandle(a, b, e);
};
react_production_min.useInsertionEffect = function(a, b) {
  return U$1.current.useInsertionEffect(a, b);
};
react_production_min.useLayoutEffect = function(a, b) {
  return U$1.current.useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return U$1.current.useMemo(a, b);
};
react_production_min.useReducer = function(a, b, e) {
  return U$1.current.useReducer(a, b, e);
};
react_production_min.useRef = function(a) {
  return U$1.current.useRef(a);
};
react_production_min.useState = function(a) {
  return U$1.current.useState(a);
};
react_production_min.useSyncExternalStore = function(a, b, e) {
  return U$1.current.useSyncExternalStore(a, b, e);
};
react_production_min.useTransition = function() {
  return U$1.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(exports) {
  function f2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g(e, b))
          a[d] = b, a[c] = e, c = d;
        else
          break a;
      }
  }
  function h2(a) {
    return 0 === a.length ? null : a[0];
  }
  function k2(a) {
    if (0 === a.length)
      return null;
    var b = a[0], c = a.pop();
    if (c !== b) {
      a[0] = c;
      a:
        for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n2 = m2 + 1, x2 = a[n2];
          if (0 > g(C2, c))
            n2 < e && 0 > g(x2, C2) ? (a[d] = x2, a[n2] = c, d = n2) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n2 < e && 0 > g(x2, c))
            a[d] = x2, a[n2] = c, d = n2;
          else
            break a;
        }
    }
    return b;
  }
  function g(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a) {
    for (var b = h2(t2); null !== b; ) {
      if (null === b.callback)
        k2(t2);
      else if (b.startTime <= a)
        k2(t2), b.sortIndex = b.expirationTime, f2(r2, b);
      else
        break;
      b = h2(t2);
    }
  }
  function H2(a) {
    B2 = false;
    G2(a);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b = h2(t2);
        null !== b && K2(H2, b.startTime - a);
      }
  }
  function J2(a, b) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c = y2;
    try {
      G2(b);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b) || a && !M2()); ) {
        var d = v2.callback;
        if ("function" === typeof d) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e = d(v2.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e ? v2.callback = e : v2 === h2(r2) && k2(r2);
          G2(b);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a = exports.unstable_now();
      Q2 = a;
      var b = true;
      try {
        b = O2(true, a);
      } finally {
        b ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a) {
    O2 = a;
    N2 || (N2 = true, S2());
  }
  function K2(a, b) {
    L2 = D2(function() {
      a(exports.unstable_now());
    }, b);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = y2;
    }
    var c = y2;
    y2 = b;
    try {
      return a();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = y2;
    y2 = a;
    try {
      return b();
    } finally {
      y2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: u2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, f2(t2, a), null === h2(r2) && a === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c - d))) : (a.sortIndex = e, f2(r2, a), A2 || z2 || (A2 = true, I2(J2)));
    return a;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a) {
    var b = y2;
    return function() {
      var c = y2;
      y2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        y2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var aa = reactExports, ca = schedulerExports;
function p$1(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a, b) {
  ha(a, b);
  ha(a + "Capture", b);
}
function ha(a, b) {
  ea[a] = b;
  for (a = 0; a < b.length; a++)
    da.add(b[a]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a) {
  if (ja.call(ma, a))
    return true;
  if (ja.call(la, a))
    return false;
  if (ka.test(a))
    return ma[a] = true;
  la[a] = true;
  return false;
}
function pa(a, b, c, d) {
  if (null !== c && 0 === c.type)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (null !== c)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;
    default:
      return false;
  }
}
function qa(a, b, c, d) {
  if (null === b || "undefined" === typeof b || pa(a, b, c, d))
    return true;
  if (d)
    return false;
  if (null !== c)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function v(a, b, c, d, e, f2, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f2;
  this.removeEmptyString = g;
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  z[a] = new v(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  z[b] = new v(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  z[a] = new v(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  z[a] = new v(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  z[a] = new v(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  z[a] = new v(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(
    ra,
    sa
  );
  z[b] = new v(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(ra, sa);
  z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
});
z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
});
function ta(a, b, c, d) {
  var e = z.hasOwnProperty(b) ? z[b] : null;
  if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1])
    qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a) {
  if (null === a || "object" !== typeof a)
    return null;
  a = Ja && a[Ja] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}
var A = Object.assign, La;
function Ma(a) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
  return "\n" + La + a;
}
var Na = false;
function Oa(a, b) {
  if (!a || Na)
    return "";
  Na = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l2) {
          d = l2;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d = l2;
      }
      a();
    }
  } catch (l2) {
    if (l2 && d && "string" === typeof l2.stack) {
      for (var e = l2.stack.split("\n"), f2 = d.stack.split("\n"), g = e.length - 1, h2 = f2.length - 1; 1 <= g && 0 <= h2 && e[g] !== f2[h2]; )
        h2--;
      for (; 1 <= g && 0 <= h2; g--, h2--)
        if (e[g] !== f2[h2]) {
          if (1 !== g || 1 !== h2) {
            do
              if (g--, h2--, 0 > h2 || e[g] !== f2[h2]) {
                var k2 = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName));
                return k2;
              }
            while (1 <= g && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
}
function Pa(a) {
  switch (a.tag) {
    case 5:
      return Ma(a.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Oa(a.type, false), a;
    case 11:
      return a = Oa(a.type.render, false), a;
    case 1:
      return a = Oa(a.type, true), a;
    default:
      return "";
  }
}
function Qa(a) {
  if (null == a)
    return null;
  if ("function" === typeof a)
    return a.displayName || a.name || null;
  if ("string" === typeof a)
    return a;
  switch (a) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a)
    switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Ra(a) {
  var b = a.type;
  switch (a.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b.displayName || "Context") + ".Consumer";
    case 10:
      return (b._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b);
    case 8:
      return b === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b)
        return b.displayName || b.name || null;
      if ("string" === typeof b)
        return b;
  }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a;
    case "object":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get, f2 = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f2.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a)
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function ab(a, b) {
  b = b.checked;
  null != b && ta(a, "checked", b, false);
}
function bb(a, b) {
  ab(a, b);
  var c = Sa(b.value), d = b.type;
  if (null != c)
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function db(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}
function cb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a)
    null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
var eb = Array.isArray;
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++)
      b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      null !== b || a[e].disabled || (b = a[e]);
    }
    null !== b && (b.selected = true);
  }
}
function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML)
    throw Error(p$1(91));
  return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (null == c) {
    c = b.children;
    b = b.defaultValue;
    if (null != c) {
      if (null != b)
        throw Error(p$1(92));
      if (eb(c)) {
        if (1 < c.length)
          throw Error(p$1(93));
        c = c[0];
      }
      b = c;
    }
    null == b && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}
function kb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var mb, nb = function(a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a)
    a.innerHTML = b;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = mb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function ob(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a) {
  qb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    pb[b] = pb[a];
  });
});
function rb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
}
function sb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a, b) {
  if (b) {
    if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML))
      throw Error(p$1(137, a));
    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children)
        throw Error(p$1(60));
      if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML))
        throw Error(p$1(61));
    }
    if (null != b.style && "object" !== typeof b.style)
      throw Error(p$1(62));
  }
}
function vb(a, b) {
  if (-1 === a.indexOf("-"))
    return "string" === typeof b.is;
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb)
      throw Error(p$1(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb() {
}
var Ib = false;
function Jb(a, b, c) {
  if (Ib)
    return a(b, c);
  Ib = true;
  try {
    return Gb(a, b, c);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a, b) {
  var c = a.stateNode;
  if (null === c)
    return null;
  var d = Db(c);
  if (null === d)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && "function" !== typeof c)
    throw Error(p$1(231, b, typeof c));
  return c;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
function Nb(a, b, c, d, e, f2, g, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
  Ob = true;
  Pb = a;
} };
function Tb(a, b, c, d, e, f2, g, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a, b, c, d, e, f2, g, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
    while (a);
  }
  return 3 === b.tag ? c : null;
}
function Wb(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b)
      return b.dehydrated;
  }
  return null;
}
function Xb(a) {
  if (Vb(a) !== a)
    throw Error(p$1(188));
}
function Yb(a) {
  var b = a.alternate;
  if (!b) {
    b = Vb(a);
    if (null === b)
      throw Error(p$1(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (null === e)
      break;
    var f2 = e.alternate;
    if (null === f2) {
      d = e.return;
      if (null !== d) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f2.child) {
      for (f2 = e.child; f2; ) {
        if (f2 === c)
          return Xb(e), a;
        if (f2 === d)
          return Xb(e), b;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c.return !== d.return)
      c = e, d = f2;
    else {
      for (var g = false, h2 = e.child; h2; ) {
        if (h2 === c) {
          g = true;
          c = e;
          d = f2;
          break;
        }
        if (h2 === d) {
          g = true;
          d = e;
          c = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c) {
            g = true;
            c = f2;
            d = e;
            break;
          }
          if (h2 === d) {
            g = true;
            d = f2;
            c = e;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g)
          throw Error(p$1(189));
      }
    }
    if (c.alternate !== d)
      throw Error(p$1(190));
  }
  if (3 !== c.tag)
    throw Error(p$1(188));
  return c.stateNode.current === c ? a : b;
}
function Zb(a) {
  a = Yb(a);
  return null !== a ? $b(a) : null;
}
function $b(a) {
  if (5 === a.tag || 6 === a.tag)
    return a;
  for (a = a.child; null !== a; ) {
    var b = $b(a);
    if (null !== b)
      return b;
    a = a.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a) {
  a >>>= 0;
  return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a) {
  switch (a & -a) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a;
  }
}
function uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c)
    return 0;
  var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g = c & 268435455;
  if (0 !== g) {
    var h2 = g & ~e;
    0 !== h2 ? d = tc(h2) : (f2 &= g, 0 !== f2 && (d = tc(f2)));
  } else
    g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f2 && (d = tc(f2));
  if (0 === d)
    return 0;
  if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f2 = b & -b, e >= f2 || 16 === e && 0 !== (f2 & 4194240)))
    return b;
  0 !== (d & 4) && (d |= c & 16);
  b = a.entangledLanes;
  if (0 !== b)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function vc(a, b) {
  switch (a) {
    case 1:
    case 2:
    case 4:
      return b + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a, b) {
  for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
    var g = 31 - oc(f2), h2 = 1 << g, k2 = e[g];
    if (-1 === k2) {
      if (0 === (h2 & c) || 0 !== (h2 & d))
        e[g] = vc(h2, b);
    } else
      k2 <= b && (a.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a;
}
function zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function Ac(a, b, c) {
  a.pendingLanes |= b;
  536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
  a = a.eventTimes;
  b = 31 - oc(b);
  a[b] = c;
}
function Bc(a, b) {
  var c = a.pendingLanes & ~b;
  a.pendingLanes = b;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= b;
  a.mutableReadLanes &= b;
  a.entangledLanes &= b;
  b = a.entanglements;
  var d = a.eventTimes;
  for (a = a.expirationTimes; 0 < c; ) {
    var e = 31 - oc(c), f2 = 1 << e;
    b[e] = 0;
    d[e] = -1;
    a[e] = -1;
    c &= ~f2;
  }
}
function Cc(a, b) {
  var c = a.entangledLanes |= b;
  for (a = a.entanglements; c; ) {
    var d = 31 - oc(c), e = 1 << d;
    e & b | a[d] & b && (a[d] |= b);
    c &= ~e;
  }
}
var C = 0;
function Dc(a) {
  a &= -a;
  return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b.pointerId);
  }
}
function Tc(a, b, c, d, e, f2) {
  if (null === a || a.nativeEvent !== f2)
    return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}
function Uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return Lc = Tc(Lc, a, b, c, d, e), true;
    case "dragenter":
      return Mc = Tc(Mc, a, b, c, d, e), true;
    case "mouseover":
      return Nc = Tc(Nc, a, b, c, d, e), true;
    case "pointerover":
      var f2 = e.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d, e)), true;
  }
  return false;
}
function Vc(a) {
  var b = Wc(a.target);
  if (null !== b) {
    var c = Vb(b);
    if (null !== c) {
      if (b = c.tag, 13 === b) {
        if (b = Wb(c), null !== b) {
          a.blockedOn = b;
          Ic(a.priority, function() {
            Gc(c);
          });
          return;
        }
      } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function Xc(a) {
  if (null !== a.blockedOn)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null === c) {
      c = a.nativeEvent;
      var d = new c.constructor(c.type, c);
      wb = d;
      c.target.dispatchEvent(d);
      wb = null;
    } else
      return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function Zc(a, b, c) {
  Xc(a) && c.delete(b);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a, b) {
  a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a) {
  function b(b2) {
    return ad(b2, a);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a);
    for (var c = 1; c < Kc.length; c++) {
      var d = Kc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a);
  null !== Mc && ad(Mc, a);
  null !== Nc && ad(Nc, a);
  Oc.forEach(b);
  Pc.forEach(b);
  for (c = 0; c < Qc.length; c++)
    d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); )
    Vc(c), null === c.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a, b, c, d) {
  var e = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f2;
  }
}
function gd(a, b, c, d) {
  var e = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a, b, c, d);
  } finally {
    C = e, cd.transition = f2;
  }
}
function fd(a, b, c, d) {
  if (dd) {
    var e = Yc(a, b, c, d);
    if (null === e)
      hd(a, b, d, id, c), Sc(a, d);
    else if (Uc(e, a, b, c, d))
      d.stopPropagation();
    else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
      for (; null !== e; ) {
        var f2 = Cb(e);
        null !== f2 && Ec(f2);
        f2 = Yc(a, b, c, d);
        null === f2 && hd(a, b, d, id, c);
        if (f2 === e)
          break;
        e = f2;
      }
      null !== e && d.stopPropagation();
    } else
      hd(a, b, d, null, c);
  }
}
var id = null;
function Yc(a, b, c, d) {
  id = null;
  a = xb(d);
  a = Wc(a);
  if (null !== a)
    if (b = Vb(a), null === b)
      a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a)
        return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated)
        return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else
      b !== a && (a = null);
  id = a;
  return null;
}
function jd(a) {
  switch (a) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++)
    ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f2 - d]; d++)
    ;
  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f2, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f2;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = A({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if ("Unidentified" !== b)
      return b;
  }
  return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return "keypress" === a.type ? od(a) : 0;
}, keyCode: function(a) {
  return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
}, which: function(a) {
  return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);
    case "keydown":
      return 229 !== b.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (32 !== b.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a = b.data, a === ee && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
}
function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if ("change" === a)
    return b;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    Jb(re, b);
  }
}
function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}
function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a)
    return te(qe);
}
function Ee(a, b) {
  if ("click" === a)
    return te(b);
}
function Fe(a, b) {
  if ("input" === a || "change" === a)
    return te(b);
}
function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a, b) {
  if (He(a, b))
    return true;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++) {
    var e = c[d];
    if (!ja.call(b, e) || !He(a[e], b[e]))
      return false;
  }
  return true;
}
function Je(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Ke(a, b) {
  var c = Je(a);
  a = 0;
  for (var d; c; ) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Je(c);
  }
}
function Le(a, b) {
  return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Me() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Ne(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}
function Oe(a) {
  var b = Me(), c = a.focusedElem, d = a.selectionRange;
  if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
    if (null !== d && Ne(c)) {
      if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c)
        c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
      else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
        a = a.getSelection();
        var e = c.textContent.length, f2 = Math.min(d.start, e);
        d = void 0 === d.end ? f2 : Math.min(d.end, e);
        !a.extend && f2 > d && (e = d, d = f2, f2 = e);
        e = Ke(c, f2);
        var g = Ke(
          c,
          d
        );
        e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
      }
    }
    b = [];
    for (a = c; a = a.parentNode; )
      1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
    "function" === typeof c.focus && c.focus();
    for (c = 0; c < b.length; c++)
      a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
function Ve(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a) {
  if (Xe[a])
    return Xe[a];
  if (!We[a])
    return a;
  var b = We[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Ye)
      return Xe[a] = b[c];
  return a;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a, b) {
  df.set(a, b);
  fa(b, [a]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Ub(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = 0 !== (b & 4);
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f2 = void 0;
      if (b)
        for (var g = d.length - 1; 0 <= g; g--) {
          var h2 = d[g], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped())
            break a;
          nf(e, h2, l2);
          f2 = k2;
        }
      else
        for (g = 0; g < d.length; g++) {
          h2 = d[g];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e.isPropagationStopped())
            break a;
          nf(e, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a = Rb, Qb = false, Rb = null, a;
}
function D(a, b) {
  var c = b[of];
  void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
  var d = a + "__bubble";
  c.has(d) || (pf(b, a, 2, false), c.add(d));
}
function qf(a, b, c) {
  var d = 0;
  b && (d |= 4);
  pf(c, a, d, b);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a) {
  if (!a[rf]) {
    a[rf] = true;
    da.forEach(function(b2) {
      "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
    });
    var b = 9 === a.nodeType ? a : a.ownerDocument;
    null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
  }
}
function pf(a, b, c, d) {
  switch (jd(b)) {
    case 1:
      var e = ed;
      break;
    case 4:
      e = gd;
      break;
    default:
      e = fd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
  d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function hd(a, b, c, d, e) {
  var f2 = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d)
    a:
      for (; ; ) {
        if (null === d)
          return;
        var g = d.tag;
        if (3 === g || 4 === g) {
          var h2 = d.stateNode.containerInfo;
          if (h2 === e || 8 === h2.nodeType && h2.parentNode === e)
            break;
          if (4 === g)
            for (g = d.return; null !== g; ) {
              var k2 = g.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g.stateNode.containerInfo, k2 === e || 8 === k2.nodeType && k2.parentNode === e)
                  return;
              }
              g = g.return;
            }
          for (; null !== h2; ) {
            g = Wc(h2);
            if (null === g)
              return;
            k2 = g.tag;
            if (5 === k2 || 6 === k2) {
              d = f2 = g;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d = d.return;
      }
  Jb(function() {
    var d2 = f2, e2 = xb(c), g2 = [];
    a: {
      var h3 = df.get(a);
      if (void 0 !== h3) {
        var k3 = td, n2 = a;
        switch (a) {
          case "keypress":
            if (0 === od(c))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b & 4), J2 = !t2 && "scroll" === a, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d2, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c, e2), g2.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b & 7)) {
      a: {
        h3 = "mouseover" === a || "pointerover" === a;
        k3 = "mouseout" === a || "pointerout" === a;
        if (h3 && c !== wb && (n2 = c.relatedTarget || c.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c.relatedTarget || c.toElement, k3 = d2, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d2;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a || "pointerover" === a)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c, e2);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e2) === d2 && (t2 = new t2(x2, w2 + "enter", n2, c, e2), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g2, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g2, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d2 ? ue(d2) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a, d2))) {
          ne(g2, na, c, e2);
          break a;
        }
        xa && xa(a, h3, d2);
        "focusout" === a && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d2, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var $a;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
    }
    se(g2, b);
  });
}
function tf(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a; ) {
    var e = a, f2 = e.stateNode;
    5 === e.tag && null !== f2 && (e = f2, f2 = Kb(a, c), null != f2 && d.unshift(tf(a, f2, e)), f2 = Kb(a, b), null != f2 && d.push(tf(a, f2, e)));
    a = a.return;
  }
  return d;
}
function vf(a) {
  if (null === a)
    return null;
  do
    a = a.return;
  while (a && 5 !== a.tag);
  return a ? a : null;
}
function wf(a, b, c, d, e) {
  for (var f2 = b._reactName, g = []; null !== c && c !== d; ) {
    var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e ? (k2 = Kb(c, f2), null != k2 && g.unshift(tf(c, k2, h2))) : e || (k2 = Kb(c, f2), null != k2 && g.push(tf(c, k2, h2))));
    c = c.return;
  }
  0 !== g.length && a.push({ event: b, listeners: g });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a) {
  return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
}
function Af(a, b, c) {
  b = zf(b);
  if (zf(a) !== b && c)
    throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a, b) {
  return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
  return Hf.resolve(null).then(a).catch(If);
} : Ff;
function If(a) {
  setTimeout(function() {
    throw a;
  });
}
function Kf(a, b) {
  var c = b, d = 0;
  do {
    var e = c.nextSibling;
    a.removeChild(c);
    if (e && 8 === e.nodeType)
      if (c = e.data, "/$" === c) {
        if (0 === d) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d--;
      } else
        "$" !== c && "$?" !== c && "$!" !== c || d++;
    c = e;
  } while (c);
  bd(b);
}
function Lf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b)
      break;
    if (8 === b) {
      b = a.data;
      if ("$" === b || "$!" === b || "$?" === b)
        break;
      if ("/$" === b)
        return null;
    }
  }
  return a;
}
function Mf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (8 === a.nodeType) {
      var c = a.data;
      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b)
          return a;
        b--;
      } else
        "/$" === c && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a) {
  var b = a[Of];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[uf] || c[Of]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child)
        for (a = Mf(a); null !== a; ) {
          if (c = a[Of])
            return c;
          a = Mf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[Of] || a[uf];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}
function ue(a) {
  if (5 === a.tag || 6 === a.tag)
    return a.stateNode;
  throw Error(p$1(33));
}
function Db(a) {
  return a[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a) {
  return { current: a };
}
function E(a) {
  0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a, b) {
  Tf++;
  Sf[Tf] = a.current;
  a.current = b;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Vf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f2;
  for (f2 in c)
    e[f2] = b[f2];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Zf(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a, b, c) {
  if (H.current !== Vf)
    throw Error(p$1(168));
  G(H, b);
  G(Wf, c);
}
function bg(a, b, c) {
  var d = a.stateNode;
  b = b.childContextTypes;
  if ("function" !== typeof d.getChildContext)
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in b))
      throw Error(p$1(108, Ra(a) || "Unknown", e));
  return A({}, c, d);
}
function cg(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a);
  G(Wf, Wf.current);
  return true;
}
function dg(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(p$1(169));
  c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
  G(Wf, c);
}
var eg = null, fg = false, gg = false;
function hg(a) {
  null === eg ? eg = [a] : eg.push(a);
}
function ig(a) {
  fg = true;
  hg(a);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a = 0, b = C;
    try {
      var c = eg;
      for (C = 1; a < c.length; a++) {
        var d = c[a];
        do
          d = d(true);
        while (null !== d);
      }
      eg = null;
      fg = false;
    } catch (e) {
      throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
    } finally {
      C = b, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a, b) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a;
  ng = b;
}
function ug(a, b, c) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a;
  var d = rg;
  a = sg;
  var e = 32 - oc(d) - 1;
  d &= ~(1 << e);
  c += 1;
  var f2 = 32 - oc(b) + e;
  if (30 < f2) {
    var g = e - e % 5;
    f2 = (d & (1 << g) - 1).toString(32);
    d >>= g;
    e -= g;
    rg = 1 << 32 - oc(b) + e | c << e | d;
    sg = f2 + a;
  } else
    rg = 1 << f2 | c << e | d, sg = a;
}
function vg(a) {
  null !== a.return && (tg(a, 1), ug(a, 1, 0));
}
function wg(a) {
  for (; a === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a, b) {
  var c = Bg(5, null, null, 0);
  c.elementType = "DELETED";
  c.stateNode = b;
  c.return = a;
  b = a.deletions;
  null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
}
function Cg(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
    case 13:
      return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a) {
  return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
}
function Eg(a) {
  if (I) {
    var b = yg;
    if (b) {
      var c = b;
      if (!Cg(a, b)) {
        if (Dg(a))
          throw Error(p$1(418));
        b = Lf(c.nextSibling);
        var d = xg;
        b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
      }
    } else {
      if (Dg(a))
        throw Error(p$1(418));
      a.flags = a.flags & -4097 | 2;
      I = false;
      xg = a;
    }
  }
}
function Fg(a) {
  for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; )
    a = a.return;
  xg = a;
}
function Gg(a) {
  if (a !== xg)
    return false;
  if (!I)
    return Fg(a), I = true, false;
  var b;
  (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
  if (b && (b = yg)) {
    if (Dg(a))
      throw Hg(), Error(p$1(418));
    for (; b; )
      Ag(a, b), b = Lf(b.nextSibling);
  }
  Fg(a);
  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a)
      throw Error(p$1(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (8 === a.nodeType) {
          var c = a.data;
          if ("/$" === c) {
            if (0 === b) {
              yg = Lf(a.nextSibling);
              break a;
            }
            b--;
          } else
            "$" !== c && "$!" !== c && "$?" !== c || b++;
        }
        a = a.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a = yg; a; )
    a = Lf(a.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a) {
  null === zg ? zg = [a] : zg.push(a);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a, b) {
  if (a && a.defaultProps) {
    b = A({}, b);
    a = a.defaultProps;
    for (var c in a)
      void 0 === b[c] && (b[c] = a[c]);
    return b;
  }
  return b;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a) {
  var b = Mg.current;
  E(Mg);
  a._currentValue = b;
}
function Sg(a, b, c) {
  for (; null !== a; ) {
    var d = a.alternate;
    (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
    if (a === c)
      break;
    a = a.return;
  }
}
function Tg(a, b) {
  Ng = a;
  Pg = Og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (Ug = true), a.firstContext = null);
}
function Vg(a) {
  var b = a._currentValue;
  if (Pg !== a)
    if (a = { context: a, memoizedValue: b, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$1(308));
      Og = a;
      Ng.dependencies = { lanes: 0, firstContext: a };
    } else
      Og = Og.next = a;
  return b;
}
var Wg = null;
function Xg(a) {
  null === Wg ? Wg = [a] : Wg.push(a);
}
function Yg(a, b, c, d) {
  var e = b.interleaved;
  null === e ? (c.next = c, Xg(b)) : (c.next = e.next, e.next = c);
  b.interleaved = c;
  return Zg(a, d);
}
function Zg(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;
  for (a = a.return; null !== a; )
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
  return 3 === c.tag ? c.stateNode : null;
}
var $g = false;
function ah(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function ch(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function dh(a, b, c) {
  var d = a.updateQueue;
  if (null === d)
    return null;
  d = d.shared;
  if (0 !== (K & 2)) {
    var e = d.pending;
    null === e ? b.next = b : (b.next = e.next, e.next = b);
    d.pending = b;
    return Zg(a, c);
  }
  e = d.interleaved;
  null === e ? (b.next = b, Xg(d)) : (b.next = e.next, e.next = b);
  d.interleaved = b;
  return Zg(a, c);
}
function eh(a, b, c) {
  b = b.updateQueue;
  if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
function fh(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null, f2 = null;
    c = c.firstBaseUpdate;
    if (null !== c) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        null === f2 ? e = f2 = g : f2 = f2.next = g;
        c = c.next;
      } while (null !== c);
      null === f2 ? e = f2 = b : f2 = f2.next = b;
    } else
      e = f2 = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function gh(a, b, c, d) {
  var e = a.updateQueue;
  $g = false;
  var f2 = e.firstBaseUpdate, g = e.lastBaseUpdate, h2 = e.shared.pending;
  if (null !== h2) {
    e.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g ? f2 = l2 : g.next = l2;
    g = k2;
    var m2 = a.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e.baseState;
    g = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a, t2 = h2;
          r2 = b;
          y2 = c;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e.baseState = k2;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = m2;
    b = e.shared.interleaved;
    if (null !== b) {
      e = b;
      do
        g |= e.lane, e = e.next;
      while (e !== b);
    } else
      null === f2 && (e.shared.lanes = 0);
    hh |= g;
    a.lanes = g;
    a.memoizedState = q2;
  }
}
function ih(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e)
          throw Error(p$1(191, e));
        e.call(d);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : A({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}
var nh = { isMounted: function(a) {
  return (a = a._reactInternals) ? Vb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = L(), e = lh(a), f2 = ch(d, e);
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = dh(a, f2, e);
  null !== b && (mh(b, a, e, d), eh(b, a, e));
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = L(), e = lh(a), f2 = ch(d, e);
  f2.tag = 1;
  f2.payload = b;
  void 0 !== c && null !== c && (f2.callback = c);
  b = dh(a, f2, e);
  null !== b && (mh(b, a, e, d), eh(b, a, e));
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = L(), d = lh(a), e = ch(c, d);
  e.tag = 2;
  void 0 !== b && null !== b && (e.callback = b);
  b = dh(a, e, d);
  null !== b && (mh(b, a, d, c), eh(b, a, d));
} };
function oh(a, b, c, d, e, f2, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f2, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f2) : true;
}
function ph(a, b, c) {
  var d = false, e = Vf;
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f2 = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
  b = new b(c, f2);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = nh;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2);
  return b;
}
function qh(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && nh.enqueueReplaceState(b, b.state, null);
}
function rh(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = jh;
  ah(a);
  var f2 = b.contextType;
  "object" === typeof f2 && null !== f2 ? e.context = Vg(f2) : (f2 = Zf(b) ? Xf : H.current, e.context = Yf(a, f2));
  e.state = a.memoizedState;
  f2 = b.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a, b, f2, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && nh.enqueueReplaceState(e, e.state, null), gh(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4194308);
}
function sh(a, b, c) {
  a = c.ref;
  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (1 !== c.tag)
          throw Error(p$1(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(p$1(147, a));
      var e = d, f2 = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f2)
        return b.ref;
      b = function(a2) {
        var b2 = e.refs;
        b2 === jh && (b2 = e.refs = {});
        null === a2 ? delete b2[f2] : b2[f2] = a2;
      };
      b._stringRef = f2;
      return b;
    }
    if ("string" !== typeof a)
      throw Error(p$1(284));
    if (!c._owner)
      throw Error(p$1(290, a));
  }
  return a;
}
function th(a, b) {
  a = Object.prototype.toString.call(b);
  throw Error(p$1(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
}
function uh(a) {
  var b = a._init;
  return b(a._payload);
}
function vh(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.deletions;
      null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; null !== d2; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); null !== b2; )
      null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = wh(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f2(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return b2.flags |= 1048576, c2;
    d2 = b2.alternate;
    if (null !== d2)
      return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
    b2.flags |= 2;
    return c2;
  }
  function g(b2) {
    a && null === b2.alternate && (b2.flags |= 2);
    return b2;
  }
  function h2(a2, b2, c2, d2) {
    if (null === b2 || 6 !== b2.tag)
      return b2 = xh(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k2(a2, b2, c2, d2) {
    var f3 = c2.type;
    if (f3 === ya)
      return m2(a2, b2, c2.props.children, d2, c2.key);
    if (null !== b2 && (b2.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b2.type))
      return d2 = e(b2, c2.props), d2.ref = sh(a2, b2, c2), d2.return = a2, d2;
    d2 = yh(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = sh(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = zh(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function m2(a2, b2, c2, d2, f3) {
    if (null === b2 || 7 !== b2.tag)
      return b2 = Ah(c2, a2.mode, d2, f3), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function q2(a2, b2, c2) {
    if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2)
      return b2 = xh("" + b2, a2.mode, c2), b2.return = a2, b2;
    if ("object" === typeof b2 && null !== b2) {
      switch (b2.$$typeof) {
        case va:
          return c2 = yh(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = sh(a2, null, b2), c2.return = a2, c2;
        case wa:
          return b2 = zh(b2, a2.mode, c2), b2.return = a2, b2;
        case Ha:
          var d2 = b2._init;
          return q2(a2, d2(b2._payload), c2);
      }
      if (eb(b2) || Ka(b2))
        return b2 = Ah(b2, a2.mode, c2, null), b2.return = a2, b2;
      th(a2, b2);
    }
    return null;
  }
  function r2(a2, b2, c2, d2) {
    var e2 = null !== b2 ? b2.key : null;
    if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2)
      return null !== e2 ? null : h2(a2, b2, "" + c2, d2);
    if ("object" === typeof c2 && null !== c2) {
      switch (c2.$$typeof) {
        case va:
          return c2.key === e2 ? k2(a2, b2, c2, d2) : null;
        case wa:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
        case Ha:
          return e2 = c2._init, r2(
            a2,
            b2,
            e2(c2._payload),
            d2
          );
      }
      if (eb(c2) || Ka(c2))
        return null !== e2 ? null : m2(a2, b2, c2, d2, null);
      th(a2, c2);
    }
    return null;
  }
  function y2(a2, b2, c2, d2, e2) {
    if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2)
      return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e2);
    if ("object" === typeof d2 && null !== d2) {
      switch (d2.$$typeof) {
        case va:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k2(b2, a2, d2, e2);
        case wa:
          return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
        case Ha:
          var f3 = d2._init;
          return y2(a2, b2, c2, f3(d2._payload), e2);
      }
      if (eb(d2) || Ka(d2))
        return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
      th(b2, d2);
    }
    return null;
  }
  function n2(e2, g2, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g2, w2 = g2 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e2, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a && u2 && null === n3.alternate && b(e2, u2);
      g2 = f2(n3, g2, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c(e2, u2), I && tg(e2, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e2, h3[w2], k3), null !== u2 && (g2 = f2(u2, g2, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I && tg(e2, w2);
      return l3;
    }
    for (u2 = d(e2, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e2, w2, h3[w2], k3), null !== x2 && (a && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g2 = f2(x2, g2, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    I && tg(e2, w2);
    return l3;
  }
  function t2(e2, g2, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$1(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$1(151));
    for (var u2 = l3 = null, m3 = g2, w2 = g2 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e2, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a && m3 && null === t3.alternate && b(e2, m3);
      g2 = f2(t3, g2, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c(
        e2,
        m3
      ), I && tg(e2, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e2, n3.value, k3), null !== n3 && (g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I && tg(e2, w2);
      return l3;
    }
    for (m3 = d(e2, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e2, w2, n3.value, k3), null !== n3 && (a && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g2 = f2(n3, g2, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a && m3.forEach(function(a2) {
      return b(e2, a2);
    });
    I && tg(e2, w2);
    return l3;
  }
  function J2(a2, d2, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d2; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c(a2, l3.sibling);
                    d2 = e(l3, f3.props.children);
                    d2.return = a2;
                    a2 = d2;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c(a2, l3.sibling);
                  d2 = e(l3, f3.props);
                  d2.ref = sh(a2, l3, f3);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                }
                c(a2, l3);
                break;
              } else
                b(a2, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d2 = Ah(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = yh(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = sh(a2, d2, f3), h3.return = a2, a2 = h3);
          }
          return g(a2);
        case wa:
          a: {
            for (l3 = f3.key; null !== d2; ) {
              if (d2.key === l3)
                if (4 === d2.tag && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f3.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = zh(f3, a2.mode, h3);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
        case Ha:
          return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a2, d2, f3, h3);
      if (Ka(f3))
        return t2(a2, d2, f3, h3);
      th(a2, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = xh(f3, a2.mode, h3), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a) {
  if (a === Dh)
    throw Error(p$1(174));
  return a;
}
function Ih(a, b) {
  G(Gh, b);
  G(Fh, a);
  G(Eh, Dh);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
      break;
    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
  }
  E(Eh);
  G(Eh, b);
}
function Jh() {
  E(Eh);
  E(Fh);
  E(Gh);
}
function Kh(a) {
  Hh(Gh.current);
  var b = Hh(Eh.current);
  var c = lb(b, a.type);
  b !== c && (G(Fh, a), G(Eh, c));
}
function Lh(a) {
  Fh.current === a && (E(Eh), E(Fh));
}
var M = Uf(0);
function Mh(a) {
  for (var b = a; null !== b; ) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data))
        return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 128))
        return b;
    } else if (null !== b.child) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; null === b.sibling; ) {
      if (null === b.return || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a = 0; a < Nh.length; a++)
    Nh[a]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O = null, P = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$1(321));
}
function Wh(a, b) {
  if (null === b)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Xh(a, b, c, d, e, f2) {
  Rh = f2;
  N = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  Ph.current = null === a || null === a.memoizedState ? Yh : Zh;
  a = c(d, e);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$1(301));
      f2 += 1;
      P = O = null;
      b.updateQueue = null;
      Ph.current = $h;
      a = c(d, e);
    } while (Th);
  }
  Ph.current = ai;
  b = null !== O && null !== O.next;
  Rh = 0;
  P = O = N = null;
  Sh = false;
  if (b)
    throw Error(p$1(300));
  return a;
}
function bi() {
  var a = 0 !== Uh;
  Uh = 0;
  return a;
}
function ci() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P ? N.memoizedState = P = a : P = P.next = a;
  return P;
}
function di() {
  if (null === O) {
    var a = N.alternate;
    a = null !== a ? a.memoizedState : null;
  } else
    a = O.next;
  var b = null === P ? N.memoizedState : P.next;
  if (null !== b)
    P = b, O = a;
  else {
    if (null === a)
      throw Error(p$1(310));
    O = a;
    a = { memoizedState: O.memoizedState, baseState: O.baseState, baseQueue: O.baseQueue, queue: O.queue, next: null };
    null === P ? N.memoizedState = P = a : P = P.next = a;
  }
  return P;
}
function ei(a, b) {
  return "function" === typeof b ? b(a) : b;
}
function fi(a) {
  var b = di(), c = b.queue;
  if (null === c)
    throw Error(p$1(311));
  c.lastRenderedReducer = a;
  var d = O, e = d.baseQueue, f2 = c.pending;
  if (null !== f2) {
    if (null !== e) {
      var g = e.next;
      e.next = f2.next;
      f2.next = g;
    }
    d.baseQueue = e = f2;
    c.pending = null;
  }
  if (null !== e) {
    f2 = e.next;
    d = d.baseState;
    var h2 = g = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g = d) : k2 = k2.next = q2;
        N.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g = d : k2.next = h2;
    He(d, b.memoizedState) || (Ug = true);
    b.memoizedState = d;
    b.baseState = g;
    b.baseQueue = k2;
    c.lastRenderedState = d;
  }
  a = c.interleaved;
  if (null !== a) {
    e = a;
    do
      f2 = e.lane, N.lanes |= f2, hh |= f2, e = e.next;
    while (e !== a);
  } else
    null === e && (c.lanes = 0);
  return [b.memoizedState, c.dispatch];
}
function gi(a) {
  var b = di(), c = b.queue;
  if (null === c)
    throw Error(p$1(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
  if (null !== e) {
    c.pending = null;
    var g = e = e.next;
    do
      f2 = a(f2, g.action), g = g.next;
    while (g !== e);
    He(f2, b.memoizedState) || (Ug = true);
    b.memoizedState = f2;
    null === b.baseQueue && (b.baseState = f2);
    c.lastRenderedState = f2;
  }
  return [f2, d];
}
function hi() {
}
function ii(a, b) {
  var c = N, d = di(), e = b(), f2 = !He(d.memoizedState, e);
  f2 && (d.memoizedState = e, Ug = true);
  d = d.queue;
  ji(ki.bind(null, c, d, a), [a]);
  if (d.getSnapshot !== b || f2 || null !== P && P.memoizedState.tag & 1) {
    c.flags |= 2048;
    li(9, mi.bind(null, c, d, e, b), void 0, null);
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(c, b, e);
  }
  return e;
}
function ni(a, b, c) {
  a.flags |= 16384;
  a = { getSnapshot: b, value: c };
  b = N.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
}
function mi(a, b, c, d) {
  b.value = c;
  b.getSnapshot = d;
  oi2(b) && pi(a);
}
function ki(a, b, c) {
  return c(function() {
    oi2(b) && pi(a);
  });
}
function oi2(a) {
  var b = a.getSnapshot;
  a = a.value;
  try {
    var c = b();
    return !He(a, c);
  } catch (d) {
    return true;
  }
}
function pi(a) {
  var b = Zg(a, 1);
  null !== b && mh(b, a, 1, -1);
}
function qi(a) {
  var b = ci();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a };
  b.queue = a;
  a = a.dispatch = ri.bind(null, N, a);
  return [b.memoizedState, a];
}
function li(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = N.updateQueue;
  null === b ? (b = { lastEffect: null, stores: null }, N.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function si() {
  return di().memoizedState;
}
function ti(a, b, c, d) {
  var e = ci();
  N.flags |= a;
  e.memoizedState = li(1 | b, c, void 0, void 0 === d ? null : d);
}
function ui(a, b, c, d) {
  var e = di();
  d = void 0 === d ? null : d;
  var f2 = void 0;
  if (null !== O) {
    var g = O.memoizedState;
    f2 = g.destroy;
    if (null !== d && Wh(d, g.deps)) {
      e.memoizedState = li(b, c, f2, d);
      return;
    }
  }
  N.flags |= a;
  e.memoizedState = li(1 | b, c, f2, d);
}
function vi(a, b) {
  return ti(8390656, 8, a, b);
}
function ji(a, b) {
  return ui(2048, 8, a, b);
}
function wi(a, b) {
  return ui(4, 2, a, b);
}
function xi(a, b) {
  return ui(4, 4, a, b);
}
function yi(a, b) {
  if ("function" === typeof b)
    return a = a(), b(a), function() {
      b(null);
    };
  if (null !== b && void 0 !== b)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function zi(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ui(4, 4, yi.bind(null, b, a), c);
}
function Ai() {
}
function Bi(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function Ci(a, b) {
  var c = di();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Wh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function Di(a, b, c) {
  if (0 === (Rh & 21))
    return a.baseState && (a.baseState = false, Ug = true), a.memoizedState = c;
  He(c, b) || (c = yc(), N.lanes |= c, hh |= c, a.baseState = true);
  return b;
}
function Ei(a, b) {
  var c = C;
  C = 0 !== c && 4 > c ? c : 4;
  a(true);
  var d = Qh.transition;
  Qh.transition = {};
  try {
    a(false), b();
  } finally {
    C = c, Qh.transition = d;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a, b, c) {
  var d = lh(a);
  c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b, c);
  else if (c = Yg(a, b, c, d), null !== c) {
    var e = L();
    mh(c, a, d, e);
    Ji(c, b, d);
  }
}
function ri(a, b, c) {
  var d = lh(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a))
    Ii(b, e);
  else {
    var f2 = a.alternate;
    if (0 === a.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b.lastRenderedReducer, null !== f2))
      try {
        var g = b.lastRenderedState, h2 = f2(g, c);
        e.hasEagerState = true;
        e.eagerState = h2;
        if (He(h2, g)) {
          var k2 = b.interleaved;
          null === k2 ? (e.next = e, Xg(b)) : (e.next = k2.next, k2.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c = Yg(a, b, e, d);
    null !== c && (e = L(), mh(c, a, d, e), Ji(c, b, d));
  }
}
function Hi(a) {
  var b = a.alternate;
  return a === N || null !== b && b === N;
}
function Ii(a, b) {
  Th = Sh = true;
  var c = a.pending;
  null === c ? b.next = b : (b.next = c.next, c.next = b);
  a.pending = b;
}
function Ji(a, b, c) {
  if (0 !== (c & 4194240)) {
    var d = b.lanes;
    d &= a.pendingLanes;
    c |= d;
    b.lanes = c;
    Cc(a, c);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a, b) {
  ci().memoizedState = [a, void 0 === b ? null : b];
  return a;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b, a),
    c
  );
}, useLayoutEffect: function(a, b) {
  return ti(4194308, 4, a, b);
}, useInsertionEffect: function(a, b) {
  return ti(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = ci();
  b = void 0 === b ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = ci();
  b = void 0 !== c ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  d.queue = a;
  a = a.dispatch = Gi.bind(null, N, a);
  return [d.memoizedState, a];
}, useRef: function(a) {
  var b = ci();
  a = { current: a };
  return b.memoizedState = a;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a) {
  return ci().memoizedState = a;
}, useTransition: function() {
  var a = qi(false), b = a[0];
  a = Ei.bind(null, a[1]);
  ci().memoizedState = a;
  return [b, a];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a, b, c) {
  var d = N, e = ci();
  if (I) {
    if (void 0 === c)
      throw Error(p$1(407));
    c = c();
  } else {
    c = b();
    if (null === R)
      throw Error(p$1(349));
    0 !== (Rh & 30) || ni(d, b, c);
  }
  e.memoizedState = c;
  var f2 = { value: c, getSnapshot: b };
  e.queue = f2;
  vi(ki.bind(
    null,
    d,
    f2,
    a
  ), [a]);
  d.flags |= 2048;
  li(9, mi.bind(null, d, f2, c, b), void 0, null);
  return c;
}, useId: function() {
  var a = ci(), b = R.identifierPrefix;
  if (I) {
    var c = sg;
    var d = rg;
    c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
    b = ":" + b + "R" + c;
    c = Uh++;
    0 < c && (b += "H" + c.toString(32));
    b += ":";
  } else
    c = Vh++, b = ":" + b + "r" + c.toString(32) + ":";
  return a.memoizedState = b;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a) {
    var b = di();
    return Di(b, O.memoizedState, a);
  },
  useTransition: function() {
    var a = fi(ei)[0], b = di().memoizedState;
    return [a, b];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a) {
  var b = di();
  return null === O ? b.memoizedState = a : Di(b, O.memoizedState, a);
}, useTransition: function() {
  var a = gi(ei)[0], b = di().memoizedState;
  return [a, b];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a, b) {
  try {
    var c = "", d = b;
    do
      c += Pa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f2) {
    e = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a, source: b, stack: e, digest: null };
}
function Li(a, b, c) {
  return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
}
function Mi(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Pi || (Pi = true, Qi = d);
    Mi(a, b);
  };
  return c;
}
function Ri(a, b, c) {
  c = ch(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if ("function" === typeof d) {
    var e = b.value;
    c.payload = function() {
      return d(e);
    };
    c.callback = function() {
      Mi(a, b);
    };
  }
  var f2 = a.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c.callback = function() {
    Mi(a, b);
    "function" !== typeof d && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
  });
  return c;
}
function Ti(a, b, c) {
  var d = a.pingCache;
  if (null === d) {
    d = a.pingCache = new Ni();
    var e = /* @__PURE__ */ new Set();
    d.set(b, e);
  } else
    e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
  e.has(c) || (e.add(c), a = Ui.bind(null, a, b, c), b.then(a, a));
}
function Vi(a) {
  do {
    var b;
    if (b = 13 === a.tag)
      b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
    if (b)
      return a;
    a = a.return;
  } while (null !== a);
  return null;
}
function Wi(a, b, c, d, e) {
  if (0 === (a.mode & 1))
    return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = ch(-1, 1), b.tag = 2, dh(c, b, 1))), c.lanes |= 1), a;
  a.flags |= 65536;
  a.lanes = e;
  return a;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a, b, c, d) {
  b.child = null === a ? Ch(b, null, c, d) : Bh(b, a.child, c, d);
}
function Zi(a, b, c, d, e) {
  c = c.render;
  var f2 = b.ref;
  Tg(b, e);
  d = Xh(a, b, c, d, f2, e);
  c = bi();
  if (null !== a && !Ug)
    return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && c && vg(b);
  b.flags |= 1;
  Yi(a, b, d, e);
  return b.child;
}
function aj(a, b, c, d, e) {
  if (null === a) {
    var f2 = c.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c.compare && void 0 === c.defaultProps)
      return b.tag = 15, b.type = f2, cj(a, b, f2, d, e);
    a = yh(c.type, null, d, b, b.mode, e);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  f2 = a.child;
  if (0 === (a.lanes & e)) {
    var g = f2.memoizedProps;
    c = c.compare;
    c = null !== c ? c : Ie;
    if (c(g, d) && a.ref === b.ref)
      return $i(a, b, e);
  }
  b.flags |= 1;
  a = wh(f2, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function cj(a, b, c, d, e) {
  if (null !== a) {
    var f2 = a.memoizedProps;
    if (Ie(f2, d) && a.ref === b.ref)
      if (Ug = false, b.pendingProps = d = f2, 0 !== (a.lanes & e))
        0 !== (a.flags & 131072) && (Ug = true);
      else
        return b.lanes = a.lanes, $i(a, b, e);
  }
  return dj(a, b, c, d, e);
}
function ej(a, b, c) {
  var d = b.pendingProps, e = d.children, f2 = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode)
    if (0 === (b.mode & 1))
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c;
    else {
      if (0 === (c & 1073741824))
        return a = null !== f2 ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(fj, gj), gj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d = null !== f2 ? f2.baseLanes : c;
      G(fj, gj);
      gj |= d;
    }
  else
    null !== f2 ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G(fj, gj), gj |= d;
  Yi(a, b, e, c);
  return b.child;
}
function hj(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c)
    b.flags |= 512, b.flags |= 2097152;
}
function dj(a, b, c, d, e) {
  var f2 = Zf(c) ? Xf : H.current;
  f2 = Yf(b, f2);
  Tg(b, e);
  c = Xh(a, b, c, d, f2, e);
  d = bi();
  if (null !== a && !Ug)
    return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, $i(a, b, e);
  I && d && vg(b);
  b.flags |= 1;
  Yi(a, b, c, e);
  return b.child;
}
function ij(a, b, c, d, e) {
  if (Zf(c)) {
    var f2 = true;
    cg(b);
  } else
    f2 = false;
  Tg(b, e);
  if (null === b.stateNode)
    jj(a, b), ph(b, c, d), rh(b, c, d, e), d = true;
  else if (null === a) {
    var g = b.stateNode, h2 = b.memoizedProps;
    g.props = h2;
    var k2 = g.context, l2 = c.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c) ? Xf : H.current, l2 = Yf(b, l2));
    var m2 = c.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== d || k2 !== l2) && qh(b, g, d, l2);
    $g = false;
    var r2 = b.memoizedState;
    g.state = r2;
    gh(b, d, g, e);
    k2 = b.memoizedState;
    h2 !== d || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b, c, m2, d), k2 = b.memoizedState), (h2 = $g || oh(b, c, h2, d, r2, k2, l2)) ? (q2 || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g.props = d, g.state = k2, g.context = l2, d = h2) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
  } else {
    g = b.stateNode;
    bh(a, b);
    h2 = b.memoizedProps;
    l2 = b.type === b.elementType ? h2 : Lg(b.type, h2);
    g.props = l2;
    q2 = b.pendingProps;
    r2 = g.context;
    k2 = c.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c) ? Xf : H.current, k2 = Yf(b, k2));
    var y2 = c.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b, g, d, k2);
    $g = false;
    r2 = b.memoizedState;
    g.state = r2;
    gh(b, d, g, e);
    var n2 = b.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b, c, y2, d), n2 = b.memoizedState), (l2 = $g || oh(b, c, l2, d, r2, n2, k2) || false) ? (m2 || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n2, k2), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n2, k2)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n2), g.props = d, g.state = n2, g.context = k2, d = l2) : ("function" !== typeof g.componentDidUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h2 === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d = false);
  }
  return kj(a, b, c, d, f2, e);
}
function kj(a, b, c, d, e, f2) {
  hj(a, b);
  var g = 0 !== (b.flags & 128);
  if (!d && !g)
    return e && dg(b, c, false), $i(a, b, f2);
  d = b.stateNode;
  Xi.current = b;
  var h2 = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Bh(b, a.child, null, f2), b.child = Bh(b, null, h2, f2)) : Yi(a, b, h2, f2);
  b.memoizedState = d.state;
  e && dg(b, c, true);
  return b.child;
}
function lj(a) {
  var b = a.stateNode;
  b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
  Ih(a, b.containerInfo);
}
function mj(a, b, c, d, e) {
  Ig();
  Jg(e);
  b.flags |= 256;
  Yi(a, b, c, d);
  return b.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a) {
  return { baseLanes: a, cachePool: null, transitions: null };
}
function pj(a, b, c) {
  var d = b.pendingProps, e = M.current, f2 = false, g = 0 !== (b.flags & 128), h2;
  (h2 = g) || (h2 = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
  if (h2)
    f2 = true, b.flags &= -129;
  else if (null === a || null !== a.memoizedState)
    e |= 1;
  G(M, e & 1);
  if (null === a) {
    Eg(b);
    a = b.memoizedState;
    if (null !== a && (a = a.dehydrated, null !== a))
      return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
    g = d.children;
    a = d.fallback;
    return f2 ? (d = b.mode, f2 = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g) : f2 = qj(g, d, 0, null), a = Ah(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = oj(c), b.memoizedState = nj, a) : rj(b, g);
  }
  e = a.memoizedState;
  if (null !== e && (h2 = e.dehydrated, null !== h2))
    return sj(a, b, g, d, h2, e, c);
  if (f2) {
    f2 = d.fallback;
    g = b.mode;
    e = a.child;
    h2 = e.sibling;
    var k2 = { mode: "hidden", children: d.children };
    0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = wh(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g, c, null), f2.flags |= 2);
    f2.return = b;
    d.return = b;
    d.sibling = f2;
    b.child = d;
    d = f2;
    f2 = b.child;
    g = a.child.memoizedState;
    g = null === g ? oj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
    f2.memoizedState = g;
    f2.childLanes = a.childLanes & ~c;
    b.memoizedState = nj;
    return d;
  }
  f2 = a.child;
  a = f2.sibling;
  d = wh(f2, { mode: "visible", children: d.children });
  0 === (b.mode & 1) && (d.lanes = c);
  d.return = b;
  d.sibling = null;
  null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
  b.child = d;
  b.memoizedState = null;
  return d;
}
function rj(a, b) {
  b = qj({ mode: "visible", children: b }, a.mode, 0, null);
  b.return = a;
  return a.child = b;
}
function tj(a, b, c, d) {
  null !== d && Jg(d);
  Bh(b, a.child, null, c);
  a = rj(b, b.pendingProps.children);
  a.flags |= 2;
  b.memoizedState = null;
  return a;
}
function sj(a, b, c, d, e, f2, g) {
  if (c) {
    if (b.flags & 256)
      return b.flags &= -257, d = Li(Error(p$1(422))), tj(a, b, g, d);
    if (null !== b.memoizedState)
      return b.child = a.child, b.flags |= 128, null;
    f2 = d.fallback;
    e = b.mode;
    d = qj({ mode: "visible", children: d.children }, e, 0, null);
    f2 = Ah(f2, e, g, null);
    f2.flags |= 2;
    d.return = b;
    f2.return = b;
    d.sibling = f2;
    b.child = d;
    0 !== (b.mode & 1) && Bh(b, a.child, null, g);
    b.child.memoizedState = oj(g);
    b.memoizedState = nj;
    return f2;
  }
  if (0 === (b.mode & 1))
    return tj(a, b, g, null);
  if ("$!" === e.data) {
    d = e.nextSibling && e.nextSibling.dataset;
    if (d)
      var h2 = d.dgst;
    d = h2;
    f2 = Error(p$1(419));
    d = Li(f2, d, void 0);
    return tj(a, b, g, d);
  }
  h2 = 0 !== (g & a.childLanes);
  if (Ug || h2) {
    d = R;
    if (null !== d) {
      switch (g & -g) {
        case 4:
          e = 2;
          break;
        case 16:
          e = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e = 32;
          break;
        case 536870912:
          e = 268435456;
          break;
        default:
          e = 0;
      }
      e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
      0 !== e && e !== f2.retryLane && (f2.retryLane = e, Zg(a, e), mh(d, a, e, -1));
    }
    uj();
    d = Li(Error(p$1(421)));
    return tj(a, b, g, d);
  }
  if ("$?" === e.data)
    return b.flags |= 128, b.child = a.child, b = vj.bind(null, a), e._reactRetry = b, null;
  a = f2.treeContext;
  yg = Lf(e.nextSibling);
  xg = b;
  I = true;
  zg = null;
  null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
  b = rj(b, d.children);
  b.flags |= 4096;
  return b;
}
function wj(a, b, c) {
  a.lanes |= b;
  var d = a.alternate;
  null !== d && (d.lanes |= b);
  Sg(a.return, b, c);
}
function xj(a, b, c, d, e) {
  var f2 = a.memoizedState;
  null === f2 ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
}
function yj(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
  Yi(a, b, d.children, c);
  d = M.current;
  if (0 !== (d & 2))
    d = d & 1 | 2, b.flags |= 128;
  else {
    if (null !== a && 0 !== (a.flags & 128))
      a:
        for (a = b.child; null !== a; ) {
          if (13 === a.tag)
            null !== a.memoizedState && wj(a, c, b);
          else if (19 === a.tag)
            wj(a, c, b);
          else if (null !== a.child) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; null === a.sibling; ) {
            if (null === a.return || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  G(M, d);
  if (0 === (b.mode & 1))
    b.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; )
          a = c.alternate, null !== a && null === Mh(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        xj(b, false, e, c, f2);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Mh(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        xj(b, true, c, null, f2);
        break;
      case "together":
        xj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function jj(a, b) {
  0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
}
function $i(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  hh |= b.lanes;
  if (0 === (c & b.childLanes))
    return null;
  if (null !== a && b.child !== a.child)
    throw Error(p$1(153));
  if (null !== b.child) {
    a = b.child;
    c = wh(a, a.pendingProps);
    b.child = c;
    for (c.return = b; null !== a.sibling; )
      a = a.sibling, c = c.sibling = wh(a, a.pendingProps), c.return = b;
    c.sibling = null;
  }
  return b.child;
}
function zj(a, b, c) {
  switch (b.tag) {
    case 3:
      lj(b);
      Ig();
      break;
    case 5:
      Kh(b);
      break;
    case 1:
      Zf(b.type) && cg(b);
      break;
    case 4:
      Ih(b, b.stateNode.containerInfo);
      break;
    case 10:
      var d = b.type._context, e = b.memoizedProps.value;
      G(Mg, d._currentValue);
      d._currentValue = e;
      break;
    case 13:
      d = b.memoizedState;
      if (null !== d) {
        if (null !== d.dehydrated)
          return G(M, M.current & 1), b.flags |= 128, null;
        if (0 !== (c & b.child.childLanes))
          return pj(a, b, c);
        G(M, M.current & 1);
        a = $i(a, b, c);
        return null !== a ? a.sibling : null;
      }
      G(M, M.current & 1);
      break;
    case 19:
      d = 0 !== (c & b.childLanes);
      if (0 !== (a.flags & 128)) {
        if (d)
          return yj(a, b, c);
        b.flags |= 128;
      }
      e = b.memoizedState;
      null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
      G(M, M.current);
      if (d)
        break;
      else
        return null;
    case 22:
    case 23:
      return b.lanes = 0, ej(a, b, c);
  }
  return $i(a, b, c);
}
var Aj, Bj, Cj, Dj;
Aj = function(a, b) {
  for (var c = b.child; null !== c; ) {
    if (5 === c.tag || 6 === c.tag)
      a.appendChild(c.stateNode);
    else if (4 !== c.tag && null !== c.child) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; null === c.sibling; ) {
      if (null === c.return || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Bj = function() {
};
Cj = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f2 = [];
        break;
      case "select":
        e = A({}, e, { value: void 0 });
        d = A({}, d, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f2 = [];
        break;
      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
    }
    ub(c, d);
    var g;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && null != e[l2])
        if ("style" === l2) {
          var h2 = e[l2];
          for (g in h2)
            h2.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d) {
      var k2 = d[l2];
      h2 = null != e ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g in h2)
              !h2.hasOwnProperty(g) || k2 && k2.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k2)
              k2.hasOwnProperty(g) && h2[g] !== k2[g] && (c || (c = {}), c[g] = k2[g]);
          } else
            c || (f2 || (f2 = []), f2.push(
              l2,
              c
            )), c = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c && (f2 = f2 || []).push("style", c);
    var l2 = f2;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Dj = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Ej(a, b) {
  if (!I)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; )
          null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; null !== c; )
          null !== c.alternate && (d = c), c = c.sibling;
        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function S(a) {
  var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
  if (b)
    for (var e = a.child; null !== e; )
      c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
  else
    for (e = a.child; null !== e; )
      c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
  a.subtreeFlags |= d;
  a.childLanes = c;
  return b;
}
function Fj(a, b, c) {
  var d = b.pendingProps;
  wg(b);
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b), null;
    case 1:
      return Zf(b.type) && $f(), S(b), null;
    case 3:
      d = b.stateNode;
      Jh();
      E(Wf);
      E(H);
      Oh();
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child)
        Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a, b);
      S(b);
      return null;
    case 5:
      Lh(b);
      var e = Hh(Gh.current);
      c = b.type;
      if (null !== a && null != b.stateNode)
        Cj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      else {
        if (!d) {
          if (null === b.stateNode)
            throw Error(p$1(166));
          S(b);
          return null;
        }
        a = Hh(Eh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.type;
          var f2 = b.memoizedProps;
          d[Of] = b;
          d[Pf] = f2;
          a = 0 !== (b.mode & 1);
          switch (c) {
            case "dialog":
              D("cancel", d);
              D("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d);
              break;
            case "video":
            case "audio":
              for (e = 0; e < lf.length; e++)
                D(lf[e], d);
              break;
            case "source":
              D("error", d);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d
              );
              D("load", d);
              break;
            case "details":
              D("toggle", d);
              break;
            case "input":
              Za(d, f2);
              D("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d);
              break;
            case "textarea":
              hb(d, f2), D("invalid", d);
          }
          ub(c, f2);
          e = null;
          for (var g in f2)
            if (f2.hasOwnProperty(g)) {
              var h2 = f2[g];
              "children" === g ? "string" === typeof h2 ? d.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d.textContent, h2, a), e = ["children", h2]) : "number" === typeof h2 && d.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d.textContent,
                h2,
                a
              ), e = ["children", "" + h2]) : ea.hasOwnProperty(g) && null != h2 && "onScroll" === g && D("scroll", d);
            }
          switch (c) {
            case "input":
              Va(d);
              db(d, f2, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d.onclick = Bf);
          }
          d = e;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
          "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[Of] = b;
          a[Pf] = d;
          Aj(a, b, false, false);
          b.stateNode = a;
          a: {
            g = vb(c, d);
            switch (c) {
              case "dialog":
                D("cancel", a);
                D("close", a);
                e = d;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a);
                e = d;
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++)
                  D(lf[e], a);
                e = d;
                break;
              case "source":
                D("error", a);
                e = d;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a
                );
                D("load", a);
                e = d;
                break;
              case "details":
                D("toggle", a);
                e = d;
                break;
              case "input":
                Za(a, d);
                e = Ya(a, d);
                D("invalid", a);
                break;
              case "option":
                e = d;
                break;
              case "select":
                a._wrapperState = { wasMultiple: !!d.multiple };
                e = A({}, d, { value: void 0 });
                D("invalid", a);
                break;
              case "textarea":
                hb(a, d);
                e = gb(a, d);
                D("invalid", a);
                break;
              default:
                e = d;
            }
            ub(c, e);
            h2 = e;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c || "" !== k2) && ob(a, k2) : "number" === typeof k2 && ob(a, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D("scroll", a) : null != k2 && ta(a, f2, k2, g));
              }
            switch (c) {
              case "input":
                Va(a);
                db(a, d, false);
                break;
              case "textarea":
                Va(a);
                jb(a);
                break;
              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;
              case "select":
                a.multiple = !!d.multiple;
                f2 = d.value;
                null != f2 ? fb(a, !!d.multiple, f2, false) : null != d.defaultValue && fb(
                  a,
                  !!d.multiple,
                  d.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e.onClick && (a.onclick = Bf);
            }
            switch (c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d = !!d.autoFocus;
                break a;
              case "img":
                d = true;
                break a;
              default:
                d = false;
            }
          }
          d && (b.flags |= 4);
        }
        null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
      }
      S(b);
      return null;
    case 6:
      if (a && null != b.stateNode)
        Dj(a, b, a.memoizedProps, d);
      else {
        if ("string" !== typeof d && null === b.stateNode)
          throw Error(p$1(166));
        c = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b)) {
          d = b.stateNode;
          c = b.memoizedProps;
          d[Of] = b;
          if (f2 = d.nodeValue !== c) {
            if (a = xg, null !== a)
              switch (a.tag) {
                case 3:
                  Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
              }
          }
          f2 && (b.flags |= 4);
        } else
          d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
      }
      S(b);
      return null;
    case 13:
      E(M);
      d = b.memoizedState;
      if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128))
          Hg(), Ig(), b.flags |= 98560, f2 = false;
        else if (f2 = Gg(b), null !== d && null !== d.dehydrated) {
          if (null === a) {
            if (!f2)
              throw Error(p$1(318));
            f2 = b.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$1(317));
            f2[Of] = b;
          } else
            Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
          S(b);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b.flags & 65536 ? b : null;
      }
      if (0 !== (b.flags & 128))
        return b.lanes = c, b;
      d = null !== d;
      d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (M.current & 1) ? 0 === T && (T = 3) : uj()));
      null !== b.updateQueue && (b.flags |= 4);
      S(b);
      return null;
    case 4:
      return Jh(), Bj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
    case 10:
      return Rg(b.type._context), S(b), null;
    case 17:
      return Zf(b.type) && $f(), S(b), null;
    case 19:
      E(M);
      f2 = b.memoizedState;
      if (null === f2)
        return S(b), null;
      d = 0 !== (b.flags & 128);
      g = f2.rendering;
      if (null === g)
        if (d)
          Ej(f2, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128))
            for (a = b.child; null !== a; ) {
              g = Mh(a);
              if (null !== g) {
                b.flags |= 128;
                Ej(f2, false);
                d = g.updateQueue;
                null !== d && (b.updateQueue = d, b.flags |= 4);
                b.subtreeFlags = 0;
                d = c;
                for (c = b.child; null !== c; )
                  f2 = c, a = d, f2.flags &= 14680066, g = f2.alternate, null === g ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g.childLanes, f2.lanes = g.lanes, f2.child = g.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g.memoizedProps, f2.memoizedState = g.memoizedState, f2.updateQueue = g.updateQueue, f2.type = g.type, a = g.dependencies, f2.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                G(M, M.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          null !== f2.tail && B() > Hj && (b.flags |= 128, d = true, Ej(f2, false), b.lanes = 4194304);
        }
      else {
        if (!d)
          if (a = Mh(g), null !== a) {
            if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g.alternate && !I)
              return S(b), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c && (b.flags |= 128, d = true, Ej(f2, false), b.lanes = 4194304);
        f2.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f2.last, null !== c ? c.sibling = g : b.child = g, f2.last = g);
      }
      if (null !== f2.tail)
        return b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B(), b.sibling = null, c = M.current, G(M, d ? c & 1 | 2 : c & 1), b;
      S(b);
      return null;
    case 22:
    case 23:
      return Ij(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (gj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b.tag));
}
function Jj(a, b) {
  wg(b);
  switch (b.tag) {
    case 1:
      return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 3:
      return Jh(), E(Wf), E(H), Oh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
    case 5:
      return Lh(b), null;
    case 13:
      E(M);
      a = b.memoizedState;
      if (null !== a && null !== a.dehydrated) {
        if (null === b.alternate)
          throw Error(p$1(340));
        Ig();
      }
      a = b.flags;
      return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
    case 19:
      return E(M), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a, b) {
  var c = a.ref;
  if (null !== c)
    if ("function" === typeof c)
      try {
        c(null);
      } catch (d) {
        W(a, b, d);
      }
    else
      c.current = null;
}
function Nj(a, b, c) {
  try {
    c();
  } catch (d) {
    W(a, b, d);
  }
}
var Oj = false;
function Pj(a, b) {
  Cf = dd;
  a = Me();
  if (Ne(a)) {
    if ("selectionStart" in a)
      var c = { start: a.selectionStart, end: a.selectionEnd };
    else
      a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && 0 !== d.rangeCount) {
          c = d.anchorNode;
          var e = d.anchorOffset, f2 = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch (F2) {
            c = null;
            break a;
          }
          var g = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c || 0 !== e && 3 !== q2.nodeType || (h2 = g + e);
                q2 !== f2 || 0 !== d && 3 !== q2.nodeType || (k2 = g + d);
                3 === q2.nodeType && (g += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a)
                  break b;
                r2 === c && ++l2 === e && (h2 = g);
                r2 === f2 && ++m2 === d && (k2 = g);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c = null;
      }
    c = c || { start: 0, end: 0 };
  } else
    c = null;
  Df = { focusedElem: a, selectionRange: c };
  dd = false;
  for (V = b; null !== V; )
    if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a)
      a.return = b, V = a;
    else
      for (; null !== V; ) {
        b = V;
        try {
          var n2 = b.alternate;
          if (0 !== (b.flags & 1024))
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t2 : Lg(b.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$1(163));
            }
        } catch (F2) {
          W(b, b.return, F2);
        }
        a = b.sibling;
        if (null !== a) {
          a.return = b.return;
          V = a;
          break;
        }
        V = b.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a, b, c) {
  var d = b.updateQueue;
  d = null !== d ? d.lastEffect : null;
  if (null !== d) {
    var e = d = d.next;
    do {
      if ((e.tag & a) === a) {
        var f2 = e.destroy;
        e.destroy = void 0;
        void 0 !== f2 && Nj(b, c, f2);
      }
      e = e.next;
    } while (e !== d);
  }
}
function Rj(a, b) {
  b = b.updateQueue;
  b = null !== b ? b.lastEffect : null;
  if (null !== b) {
    var c = b = b.next;
    do {
      if ((c.tag & a) === a) {
        var d = c.create;
        c.destroy = d();
      }
      c = c.next;
    } while (c !== b);
  }
}
function Sj(a) {
  var b = a.ref;
  if (null !== b) {
    var c = a.stateNode;
    switch (a.tag) {
      case 5:
        a = c;
        break;
      default:
        a = c;
    }
    "function" === typeof b ? b(a) : b.current = a;
  }
}
function Tj(a) {
  var b = a.alternate;
  null !== b && (a.alternate = null, Tj(b));
  a.child = null;
  a.deletions = null;
  a.sibling = null;
  5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
  a.stateNode = null;
  a.return = null;
  a.dependencies = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.stateNode = null;
  a.updateQueue = null;
}
function Uj(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}
function Vj(a) {
  a:
    for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Uj(a.return))
          return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2)
          continue a;
        if (null === a.child || 4 === a.tag)
          continue a;
        else
          a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2))
        return a.stateNode;
    }
}
function Wj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d)
    a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
  else if (4 !== d && (a = a.child, null !== a))
    for (Wj(a, b, c), a = a.sibling; null !== a; )
      Wj(a, b, c), a = a.sibling;
}
function Xj(a, b, c) {
  var d = a.tag;
  if (5 === d || 6 === d)
    a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (4 !== d && (a = a.child, null !== a))
    for (Xj(a, b, c), a = a.sibling; null !== a; )
      Xj(a, b, c), a = a.sibling;
}
var X = null, Yj = false;
function Zj(a, b, c) {
  for (c = c.child; null !== c; )
    ak(a, b, c), c = c.sibling;
}
function ak(a, b, c) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h2) {
    }
  switch (c.tag) {
    case 5:
      U || Mj(c, b);
    case 6:
      var d = X, e = Yj;
      X = null;
      Zj(a, b, c);
      X = d;
      Yj = e;
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
      break;
    case 4:
      d = X;
      e = Yj;
      X = c.stateNode.containerInfo;
      Yj = true;
      Zj(a, b, c);
      X = d;
      Yj = e;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
        e = d = d.next;
        do {
          var f2 = e, g = f2.destroy;
          f2 = f2.tag;
          void 0 !== g && (0 !== (f2 & 2) ? Nj(c, b, g) : 0 !== (f2 & 4) && Nj(c, b, g));
          e = e.next;
        } while (e !== d);
      }
      Zj(a, b, c);
      break;
    case 1:
      if (!U && (Mj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount))
        try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          W(c, b, h2);
        }
      Zj(a, b, c);
      break;
    case 21:
      Zj(a, b, c);
      break;
    case 22:
      c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Zj(a, b, c), U = d) : Zj(a, b, c);
      break;
    default:
      Zj(a, b, c);
  }
}
function bk(a) {
  var b = a.updateQueue;
  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Lj());
    b.forEach(function(b2) {
      var d = ck.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function dk(a, b) {
  var c = b.deletions;
  if (null !== c)
    for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f2 = a, g = b, h2 = g;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X)
          throw Error(p$1(160));
        ak(f2, g, e);
        X = null;
        Yj = false;
        var k2 = e.alternate;
        null !== k2 && (k2.return = null);
        e.return = null;
      } catch (l2) {
        W(e, b, l2);
      }
    }
  if (b.subtreeFlags & 12854)
    for (b = b.child; null !== b; )
      ek(b, a), b = b.sibling;
}
function ek(a, b) {
  var c = a.alternate, d = a.flags;
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b, a);
      fk(a);
      if (d & 4) {
        try {
          Qj(3, a, a.return), Rj(3, a);
        } catch (t2) {
          W(a, a.return, t2);
        }
        try {
          Qj(5, a, a.return);
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 1:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      break;
    case 5:
      dk(b, a);
      fk(a);
      d & 512 && null !== c && Mj(c, c.return);
      if (a.flags & 32) {
        var e = a.stateNode;
        try {
          ob(e, "");
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      if (d & 4 && (e = a.stateNode, null != e)) {
        var f2 = a.memoizedProps, g = null !== c ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
        a.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e, f2);
            vb(h2, g);
            var l2 = vb(h2, f2);
            for (g = 0; g < k2.length; g += 2) {
              var m2 = k2[g], q2 = k2[g + 1];
              "style" === m2 ? sb(e, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e, q2) : "children" === m2 ? ob(e, q2) : ta(e, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e, f2);
                break;
              case "textarea":
                ib(e, f2);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e[Pf] = f2;
          } catch (t2) {
            W(a, a.return, t2);
          }
      }
      break;
    case 6:
      dk(b, a);
      fk(a);
      if (d & 4) {
        if (null === a.stateNode)
          throw Error(p$1(162));
        e = a.stateNode;
        f2 = a.memoizedProps;
        try {
          e.nodeValue = f2;
        } catch (t2) {
          W(a, a.return, t2);
        }
      }
      break;
    case 3:
      dk(b, a);
      fk(a);
      if (d & 4 && null !== c && c.memoizedState.isDehydrated)
        try {
          bd(b.containerInfo);
        } catch (t2) {
          W(a, a.return, t2);
        }
      break;
    case 4:
      dk(b, a);
      fk(a);
      break;
    case 13:
      dk(b, a);
      fk(a);
      e = a.child;
      e.flags & 8192 && (f2 = null !== e.memoizedState, e.stateNode.isHidden = f2, !f2 || null !== e.alternate && null !== e.alternate.memoizedState || (gk = B()));
      d & 4 && bk(a);
      break;
    case 22:
      m2 = null !== c && null !== c.memoizedState;
      a.mode & 1 ? (U = (l2 = U) || m2, dk(b, a), U = l2) : dk(b, a);
      fk(a);
      if (d & 8192) {
        l2 = null !== a.memoizedState;
        if ((a.stateNode.isHidden = l2) && !m2 && 0 !== (a.mode & 1))
          for (V = a, m2 = a.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d = r2;
                    c = r2.return;
                    try {
                      b = d, n2.props = b.memoizedProps, n2.state = b.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W(d, c, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e = q2.stateNode, l2 ? (f2 = e.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g));
                } catch (t2) {
                  W(a, a.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W(a, a.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b, a);
      fk(a);
      d & 4 && bk(a);
      break;
    case 21:
      break;
    default:
      dk(
        b,
        a
      ), fk(a);
  }
}
function fk(a) {
  var b = a.flags;
  if (b & 2) {
    try {
      a: {
        for (var c = a.return; null !== c; ) {
          if (Uj(c)) {
            var d = c;
            break a;
          }
          c = c.return;
        }
        throw Error(p$1(160));
      }
      switch (d.tag) {
        case 5:
          var e = d.stateNode;
          d.flags & 32 && (ob(e, ""), d.flags &= -33);
          var f2 = Vj(a);
          Xj(a, f2, e);
          break;
        case 3:
        case 4:
          var g = d.stateNode.containerInfo, h2 = Vj(a);
          Wj(a, h2, g);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k2) {
      W(a, a.return, k2);
    }
    a.flags &= -3;
  }
  b & 4096 && (a.flags &= -4097);
}
function ik(a, b, c) {
  V = a;
  jk(a);
}
function jk(a, b, c) {
  for (var d = 0 !== (a.mode & 1); null !== V; ) {
    var e = V, f2 = e.child;
    if (22 === e.tag && d) {
      var g = null !== e.memoizedState || Kj;
      if (!g) {
        var h2 = e.alternate, k2 = null !== h2 && null !== h2.memoizedState || U;
        h2 = Kj;
        var l2 = U;
        Kj = g;
        if ((U = k2) && !l2)
          for (V = e; null !== V; )
            g = V, k2 = g.child, 22 === g.tag && null !== g.memoizedState ? kk(e) : null !== k2 ? (k2.return = g, V = k2) : kk(e);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e;
        Kj = h2;
        U = l2;
      }
      lk(a);
    } else
      0 !== (e.subtreeFlags & 8772) && null !== f2 ? (f2.return = e, V = f2) : lk(a);
  }
}
function lk(a) {
  for (; null !== V; ) {
    var b = V;
    if (0 !== (b.flags & 8772)) {
      var c = b.alternate;
      try {
        if (0 !== (b.flags & 8772))
          switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U)
                if (null === c)
                  d.componentDidMount();
                else {
                  var e = b.elementType === b.type ? c.memoizedProps : Lg(b.type, c.memoizedProps);
                  d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b.updateQueue;
              null !== f2 && ih(b, f2, d);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child)
                  switch (b.child.tag) {
                    case 5:
                      c = b.child.stateNode;
                      break;
                    case 1:
                      c = b.child.stateNode;
                  }
                ih(b, g, c);
              }
              break;
            case 5:
              var h2 = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h2;
                var k2 = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l2 = b.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$1(163));
          }
        U || b.flags & 512 && Sj(b);
      } catch (r2) {
        W(b, b.return, r2);
      }
    }
    if (b === a) {
      V = null;
      break;
    }
    c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function hk(a) {
  for (; null !== V; ) {
    var b = V;
    if (b === a) {
      V = null;
      break;
    }
    var c = b.sibling;
    if (null !== c) {
      c.return = b.return;
      V = c;
      break;
    }
    V = b.return;
  }
}
function kk(a) {
  for (; null !== V; ) {
    var b = V;
    try {
      switch (b.tag) {
        case 0:
        case 11:
        case 15:
          var c = b.return;
          try {
            Rj(4, b);
          } catch (k2) {
            W(b, c, k2);
          }
          break;
        case 1:
          var d = b.stateNode;
          if ("function" === typeof d.componentDidMount) {
            var e = b.return;
            try {
              d.componentDidMount();
            } catch (k2) {
              W(b, e, k2);
            }
          }
          var f2 = b.return;
          try {
            Sj(b);
          } catch (k2) {
            W(b, f2, k2);
          }
          break;
        case 5:
          var g = b.return;
          try {
            Sj(b);
          } catch (k2) {
            W(b, g, k2);
          }
      }
    } catch (k2) {
      W(b, b.return, k2);
    }
    if (b === a) {
      V = null;
      break;
    }
    var h2 = b.sibling;
    if (null !== h2) {
      h2.return = b.return;
      V = h2;
      break;
    }
    V = b.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a) {
  if (0 === (a.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a = C;
  if (0 !== a)
    return a;
  a = window.event;
  a = void 0 === a ? 16 : jd(a.type);
  return a;
}
function mh(a, b, c, d) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$1(185));
  Ac(a, c, d);
  if (0 === (K & 2) || a !== R)
    a === R && (0 === (K & 2) && (rk |= c), 4 === T && Dk(a, Z)), Ek(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a, b) {
  var c = a.callbackNode;
  wc(a, b);
  var d = uc(a, a === R ? Z : 0);
  if (0 === d)
    null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
  else if (b = d & -d, a.callbackPriority !== b) {
    null != c && bc(c);
    if (1 === b)
      0 === a.tag ? ig(Fk.bind(null, a)) : hg(Fk.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
    else {
      switch (Dc(d)) {
        case 1:
          c = fc;
          break;
        case 4:
          c = gc;
          break;
        case 16:
          c = hc;
          break;
        case 536870912:
          c = jc;
          break;
        default:
          c = hc;
      }
      c = Gk(c, Hk.bind(null, a));
    }
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Hk(a, b) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$1(327));
  var c = a.callbackNode;
  if (Ik() && a.callbackNode !== c)
    return null;
  var d = uc(a, a === R ? Z : 0);
  if (0 === d)
    return null;
  if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b)
    b = Jk(a, d);
  else {
    b = d;
    var e = K;
    K |= 2;
    var f2 = Kk();
    if (R !== a || Z !== b)
      vk = null, Hj = B() + 500, Lk(a, b);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e;
    null !== Y ? b = 0 : (R = null, Z = 0, b = T);
  }
  if (0 !== b) {
    2 === b && (e = xc(a), 0 !== e && (d = e, b = Ok(a, e)));
    if (1 === b)
      throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
    if (6 === b)
      Dk(a, d);
    else {
      e = a.current.alternate;
      if (0 === (d & 30) && !Pk(e) && (b = Jk(a, d), 2 === b && (f2 = xc(a), 0 !== f2 && (d = f2, b = Ok(a, f2))), 1 === b))
        throw c = qk, Lk(a, 0), Dk(a, d), Ek(a, B()), c;
      a.finishedWork = e;
      a.finishedLanes = d;
      switch (b) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Qk(a, uk, vk);
          break;
        case 3:
          Dk(a, d);
          if ((d & 130023424) === d && (b = gk + 500 - B(), 10 < b)) {
            if (0 !== uc(a, 0))
              break;
            e = a.suspendedLanes;
            if ((e & d) !== d) {
              L();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), b);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 4:
          Dk(a, d);
          if ((d & 4194240) === d)
            break;
          b = a.eventTimes;
          for (e = -1; 0 < d; ) {
            var g = 31 - oc(d);
            f2 = 1 << g;
            g = b[g];
            g > e && (e = g);
            d &= ~f2;
          }
          d = e;
          d = B() - d;
          d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * mk(d / 1960)) - d;
          if (10 < d) {
            a.timeoutHandle = Ff(Qk.bind(null, a, uk, vk), d);
            break;
          }
          Qk(a, uk, vk);
          break;
        case 5:
          Qk(a, uk, vk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Ek(a, B());
  return a.callbackNode === c ? Hk.bind(null, a) : null;
}
function Ok(a, b) {
  var c = tk;
  a.current.memoizedState.isDehydrated && (Lk(a, b).flags |= 256);
  a = Jk(a, b);
  2 !== a && (b = uk, uk = c, null !== b && Gj(b));
  return a;
}
function Gj(a) {
  null === uk ? uk = a : uk.push.apply(uk, a);
}
function Pk(a) {
  for (var b = a; ; ) {
    if (b.flags & 16384) {
      var c = b.updateQueue;
      if (null !== c && (c = c.stores, null !== c))
        for (var d = 0; d < c.length; d++) {
          var e = c[d], f2 = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f2(), e))
              return false;
          } catch (g) {
            return false;
          }
        }
    }
    c = b.child;
    if (b.subtreeFlags & 16384 && null !== c)
      c.return = b, b = c;
    else {
      if (b === a)
        break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a)
          return true;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return true;
}
function Dk(a, b) {
  b &= ~sk;
  b &= ~rk;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - oc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Fk(a) {
  if (0 !== (K & 6))
    throw Error(p$1(327));
  Ik();
  var b = uc(a, 0);
  if (0 === (b & 1))
    return Ek(a, B()), null;
  var c = Jk(a, b);
  if (0 !== a.tag && 2 === c) {
    var d = xc(a);
    0 !== d && (b = d, c = Ok(a, d));
  }
  if (1 === c)
    throw c = qk, Lk(a, 0), Dk(a, b), Ek(a, B()), c;
  if (6 === c)
    throw Error(p$1(345));
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Qk(a, uk, vk);
  Ek(a, B());
  return null;
}
function Rk(a, b) {
  var c = K;
  K |= 1;
  try {
    return a(b);
  } finally {
    K = c, 0 === K && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b = K;
  K |= 1;
  var c = pk.transition, d = C;
  try {
    if (pk.transition = null, C = 1, a)
      return a();
  } finally {
    C = d, pk.transition = c, K = b, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E(fj);
}
function Lk(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, Gf(c));
  if (null !== Y)
    for (c = Y.return; null !== c; ) {
      var d = c;
      wg(d);
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && $f();
          break;
        case 3:
          Jh();
          E(Wf);
          E(H);
          Oh();
          break;
        case 5:
          Lh(d);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E(M);
          break;
        case 19:
          E(M);
          break;
        case 10:
          Rg(d.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c = c.return;
    }
  R = a;
  Y = a = wh(a.current, null);
  Z = gj = b;
  T = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b = 0; b < Wg.length; b++)
      if (c = Wg[b], d = c.interleaved, null !== d) {
        c.interleaved = null;
        var e = d.next, f2 = c.pending;
        if (null !== f2) {
          var g = f2.next;
          f2.next = e;
          d.next = g;
        }
        c.pending = d;
      }
    Wg = null;
  }
  return a;
}
function Nk(a, b) {
  do {
    var c = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d = N.memoizedState; null !== d; ) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }
        Sh = false;
      }
      Rh = 0;
      P = O = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c || null === c.return) {
        T = 1;
        qk = b;
        Y = null;
        break;
      }
      a: {
        var f2 = a, g = c.return, h2 = c, k2 = b;
        b = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g, h2, f2, b);
            y2.mode & 1 && Ti(f2, l2, b);
            b = y2;
            k2 = l2;
            var n2 = b.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b & 1)) {
              Ti(f2, l2, b);
              uj();
              break a;
            }
            k2 = Error(p$1(426));
          }
        } else if (I && h2.mode & 1) {
          var J2 = Vi(g);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g, h2, f2, b);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T && (T = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b &= -b;
              f2.lanes |= b;
              var x2 = Oi(f2, k2, b);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b &= -b;
                f2.lanes |= b;
                var F2 = Ri(f2, h2, b);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c);
    } catch (na) {
      b = na;
      Y === c && null !== c && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a = nk.current;
  nk.current = ai;
  return null === a ? ai : a;
}
function uj() {
  if (0 === T || 3 === T || 2 === T)
    T = 4;
  null === R || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R, Z);
}
function Jk(a, b) {
  var c = K;
  K |= 2;
  var d = Kk();
  if (R !== a || Z !== b)
    vk = null, Lk(a, b);
  do
    try {
      Uk();
      break;
    } catch (e) {
      Nk(a, e);
    }
  while (1);
  Qg();
  K = c;
  nk.current = d;
  if (null !== Y)
    throw Error(p$1(261));
  R = null;
  Z = 0;
  return T;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a) {
  var b = Wk(a.alternate, a, gj);
  a.memoizedProps = a.pendingProps;
  null === b ? Tk(a) : Y = b;
  ok.current = null;
}
function Tk(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if (0 === (b.flags & 32768)) {
      if (c = Fj(c, b, gj), null !== c) {
        Y = c;
        return;
      }
    } else {
      c = Jj(c, b);
      if (null !== c) {
        c.flags &= 32767;
        Y = c;
        return;
      }
      if (null !== a)
        a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
      else {
        T = 6;
        Y = null;
        return;
      }
    }
    b = b.sibling;
    if (null !== b) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (null !== b);
  0 === T && (T = 5);
}
function Qk(a, b, c) {
  var d = C, e = pk.transition;
  try {
    pk.transition = null, C = 1, Xk(a, b, c, d);
  } finally {
    pk.transition = e, C = d;
  }
  return null;
}
function Xk(a, b, c, d) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$1(327));
  c = a.finishedWork;
  var e = a.finishedLanes;
  if (null === c)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(p$1(177));
  a.callbackNode = null;
  a.callbackPriority = 0;
  var f2 = c.lanes | c.childLanes;
  Bc(a, f2);
  a === R && (Y = R = null, Z = 0);
  0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c.flags & 15990);
  if (0 !== (c.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g = C;
    C = 1;
    var h2 = K;
    K |= 4;
    ok.current = null;
    Pj(a, c);
    ek(c, a);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a.current = c;
    ik(c);
    dc();
    K = h2;
    C = g;
    pk.transition = f2;
  } else
    a.current = c;
  wk && (wk = false, xk = a, yk = e);
  f2 = a.pendingLanes;
  0 === f2 && (Si = null);
  mc(c.stateNode);
  Ek(a, B());
  if (null !== b)
    for (d = a.onRecoverableError, c = 0; c < b.length; c++)
      e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
  if (Pi)
    throw Pi = false, a = Qi, Qi = null, a;
  0 !== (yk & 1) && 0 !== a.tag && Ik();
  f2 = a.pendingLanes;
  0 !== (f2 & 1) ? a === Ak ? zk++ : (zk = 0, Ak = a) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a = Dc(yk), b = pk.transition, c = C;
    try {
      pk.transition = null;
      C = 16 > a ? 16 : a;
      if (null === xk)
        var d = false;
      else {
        a = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$1(331));
        var e = K;
        K |= 4;
        for (V = a.current; null !== V; ) {
          var f2 = V, g = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g)
            g.return = f2, V = g;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a.current;
        for (V = w2; null !== V; ) {
          g = V;
          var u2 = g.child;
          if (0 !== (g.subtreeFlags & 2064) && null !== u2)
            u2.return = g, V = u2;
          else
            b:
              for (g = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W(h2, h2.return, na);
                  }
                if (h2 === g) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
        d = true;
      }
      return d;
    } finally {
      C = c, pk.transition = b;
    }
  }
  return false;
}
function Yk(a, b, c) {
  b = Ki(c, b);
  b = Oi(a, b, 1);
  a = dh(a, b, 1);
  b = L();
  null !== a && (Ac(a, 1, b), Ek(a, b));
}
function W(a, b, c) {
  if (3 === a.tag)
    Yk(a, a, c);
  else
    for (; null !== b; ) {
      if (3 === b.tag) {
        Yk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Si || !Si.has(d))) {
          a = Ki(c, a);
          a = Ri(b, a, 1);
          b = dh(b, a, 1);
          a = L();
          null !== b && (Ac(b, 1, a), Ek(b, a));
          break;
        }
      }
      b = b.return;
    }
}
function Ui(a, b, c) {
  var d = a.pingCache;
  null !== d && d.delete(b);
  b = L();
  a.pingedLanes |= a.suspendedLanes & c;
  R === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a, 0) : sk |= c);
  Ek(a, b);
}
function Zk(a, b) {
  0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c = L();
  a = Zg(a, b);
  null !== a && (Ac(a, b, c), Ek(a, c));
}
function vj(a) {
  var b = a.memoizedState, c = 0;
  null !== b && (c = b.retryLane);
  Zk(a, c);
}
function ck(a, b) {
  var c = 0;
  switch (a.tag) {
    case 13:
      var d = a.stateNode;
      var e = a.memoizedState;
      null !== e && (c = e.retryLane);
      break;
    case 19:
      d = a.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d && d.delete(b);
  Zk(a, c);
}
var Wk;
Wk = function(a, b, c) {
  if (null !== a)
    if (a.memoizedProps !== b.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128))
        return Ug = false, zj(a, b, c);
      Ug = 0 !== (a.flags & 131072) ? true : false;
    }
  else
    Ug = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      var d = b.type;
      jj(a, b);
      a = b.pendingProps;
      var e = Yf(b, H.current);
      Tg(b, c);
      e = Xh(null, b, d, a, e, c);
      var f2 = bi();
      b.flags |= 1;
      "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = true, cg(b)) : f2 = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, ah(b), e.updater = nh, b.stateNode = e, e._reactInternals = b, rh(b, d, a, c), b = kj(null, b, d, true, f2, c)) : (b.tag = 0, I && f2 && vg(b), Yi(null, b, e, c), b = b.child);
      return b;
    case 16:
      d = b.elementType;
      a: {
        jj(a, b);
        a = b.pendingProps;
        e = d._init;
        d = e(d._payload);
        b.type = d;
        e = b.tag = $k(d);
        a = Lg(d, a);
        switch (e) {
          case 0:
            b = dj(null, b, d, a, c);
            break a;
          case 1:
            b = ij(null, b, d, a, c);
            break a;
          case 11:
            b = Zi(null, b, d, a, c);
            break a;
          case 14:
            b = aj(null, b, d, Lg(d.type, a), c);
            break a;
        }
        throw Error(p$1(
          306,
          d,
          ""
        ));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), dj(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), ij(a, b, d, e, c);
    case 3:
      a: {
        lj(b);
        if (null === a)
          throw Error(p$1(387));
        d = b.pendingProps;
        f2 = b.memoizedState;
        e = f2.element;
        bh(a, b);
        gh(b, d, null, c);
        var g = b.memoizedState;
        d = g.element;
        if (f2.isDehydrated)
          if (f2 = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
            e = Ki(Error(p$1(423)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ki(Error(p$1(424)), b);
            b = mj(a, b, d, c, e);
            break a;
          } else
            for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Ch(b, null, d, c), b.child = c; c; )
              c.flags = c.flags & -3 | 4096, c = c.sibling;
        else {
          Ig();
          if (d === e) {
            b = $i(a, b, c);
            break a;
          }
          Yi(a, b, d, c);
        }
        b = b.child;
      }
      return b;
    case 5:
      return Kh(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f2 = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f2 && Ef(d, f2) && (b.flags |= 32), hj(a, b), Yi(a, b, g, c), b.child;
    case 6:
      return null === a && Eg(b), null;
    case 13:
      return pj(a, b, c);
    case 4:
      return Ih(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Bh(b, null, d, c) : Yi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), Zi(a, b, d, e, c);
    case 7:
      return Yi(a, b, b.pendingProps, c), b.child;
    case 8:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return Yi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        f2 = b.memoizedProps;
        g = e.value;
        G(Mg, d._currentValue);
        d._currentValue = g;
        if (null !== f2)
          if (He(f2.value, g)) {
            if (f2.children === e.children && !Wf.current) {
              b = $i(a, b, c);
              break a;
            }
          } else
            for (f2 = b.child, null !== f2 && (f2.return = b); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c & -c);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c);
                    Sg(
                      f2.return,
                      c,
                      b
                    );
                    h2.lanes |= c;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g = f2.type === b.type ? null : f2.child;
              else if (18 === f2.tag) {
                g = f2.return;
                if (null === g)
                  throw Error(p$1(341));
                g.lanes |= c;
                h2 = g.alternate;
                null !== h2 && (h2.lanes |= c);
                Sg(g, c, b);
                g = f2.sibling;
              } else
                g = f2.child;
              if (null !== g)
                g.return = f2;
              else
                for (g = f2; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f2 = g.sibling;
                  if (null !== f2) {
                    f2.return = g.return;
                    g = f2;
                    break;
                  }
                  g = g.return;
                }
              f2 = g;
            }
        Yi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, d = b.pendingProps.children, Tg(b, c), e = Vg(e), d = d(e), b.flags |= 1, Yi(a, b, d, c), b.child;
    case 14:
      return d = b.type, e = Lg(d, b.pendingProps), e = Lg(d.type, e), aj(a, b, d, e, c);
    case 15:
      return cj(a, b, b.type, b.pendingProps, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Lg(d, e), jj(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, Tg(b, c), ph(b, d, e), rh(b, d, e, c), kj(null, b, d, true, a, c);
    case 19:
      return yj(a, b, c);
    case 22:
      return ej(a, b, c);
  }
  throw Error(p$1(156, b.tag));
};
function Gk(a, b) {
  return ac(a, b);
}
function al(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a, b, c, d) {
  return new al(a, b, c, d);
}
function bj(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function $k(a) {
  if ("function" === typeof a)
    return bj(a) ? 1 : 0;
  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Da)
      return 11;
    if (a === Ga)
      return 14;
  }
  return 2;
}
function wh(a, b) {
  var c = a.alternate;
  null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
  c.flags = a.flags & 14680064;
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function yh(a, b, c, d, e, f2) {
  var g = 2;
  d = a;
  if ("function" === typeof a)
    bj(a) && (g = 1);
  else if ("string" === typeof a)
    g = 5;
  else
    a:
      switch (a) {
        case ya:
          return Ah(c.children, e, f2, b);
        case za:
          g = 8;
          e |= 8;
          break;
        case Aa:
          return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f2, a;
        case Ea:
          return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f2, a;
        case Fa:
          return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f2, a;
        case Ia:
          return qj(c, e, f2, b);
        default:
          if ("object" === typeof a && null !== a)
            switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
          throw Error(p$1(130, null == a ? a : typeof a, ""));
      }
  b = Bg(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f2;
  return b;
}
function Ah(a, b, c, d) {
  a = Bg(7, a, d, b);
  a.lanes = c;
  return a;
}
function qj(a, b, c, d) {
  a = Bg(22, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  a.stateNode = { isHidden: false };
  return a;
}
function xh(a, b, c) {
  a = Bg(6, a, null, b);
  a.lanes = c;
  return a;
}
function zh(a, b, c) {
  b = Bg(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function bl(a, b, c, d, e) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d;
  this.onRecoverableError = e;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a, b, c, d, e, f2, g, h2, k2) {
  a = new bl(a, b, c, h2, k2);
  1 === b ? (b = 1, true === f2 && (b |= 8)) : b = 0;
  f2 = Bg(3, null, null, b);
  a.current = f2;
  f2.stateNode = a;
  f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a;
}
function dl(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function el(a) {
  if (!a)
    return Vf;
  a = a._reactInternals;
  a: {
    if (Vb(a) !== a || 1 !== a.tag)
      throw Error(p$1(170));
    var b = a;
    do {
      switch (b.tag) {
        case 3:
          b = b.stateNode.context;
          break a;
        case 1:
          if (Zf(b.type)) {
            b = b.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b = b.return;
    } while (null !== b);
    throw Error(p$1(171));
  }
  if (1 === a.tag) {
    var c = a.type;
    if (Zf(c))
      return bg(a, c, b);
  }
  return b;
}
function fl(a, b, c, d, e, f2, g, h2, k2) {
  a = cl(c, d, true, a, e, f2, g, h2, k2);
  a.context = el(null);
  c = a.current;
  d = L();
  e = lh(c);
  f2 = ch(d, e);
  f2.callback = void 0 !== b && null !== b ? b : null;
  dh(c, f2, e);
  a.current.lanes = e;
  Ac(a, e, d);
  Ek(a, d);
  return a;
}
function gl(a, b, c, d) {
  var e = b.current, f2 = L(), g = lh(e);
  c = el(c);
  null === b.context ? b.context = c : b.pendingContext = c;
  b = ch(f2, g);
  b.payload = { element: a };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  a = dh(e, b, g);
  null !== a && (mh(a, e, g, f2), eh(a, e, g));
  return g;
}
function hl(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function il(a, b) {
  a = a.memoizedState;
  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}
function jl(a, b) {
  il(a, b);
  (a = a.alternate) && il(a, b);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a) {
  console.error(a);
};
function ml(a) {
  this._internalRoot = a;
}
nl.prototype.render = ml.prototype.render = function(a) {
  var b = this._internalRoot;
  if (null === b)
    throw Error(p$1(409));
  gl(a, b, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a = this._internalRoot;
  if (null !== a) {
    this._internalRoot = null;
    var b = a.containerInfo;
    Sk(function() {
      gl(null, a, null, null);
    });
    b[uf] = null;
  }
};
function nl(a) {
  this._internalRoot = a;
}
nl.prototype.unstable_scheduleHydration = function(a) {
  if (a) {
    var b = Hc();
    a = { blockedOn: null, target: a, priority: b };
    for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++)
      ;
    Qc.splice(c, 0, a);
    0 === c && Vc(a);
  }
};
function ol(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
}
function pl(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function ql() {
}
function rl(a, b, c, d, e) {
  if (e) {
    if ("function" === typeof d) {
      var f2 = d;
      d = function() {
        var a2 = hl(g);
        f2.call(a2);
      };
    }
    var g = fl(b, d, a, 0, null, false, false, "", ql);
    a._reactRootContainer = g;
    a[uf] = g.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Sk();
    return g;
  }
  for (; e = a.lastChild; )
    a.removeChild(e);
  if ("function" === typeof d) {
    var h2 = d;
    d = function() {
      var a2 = hl(k2);
      h2.call(a2);
    };
  }
  var k2 = cl(a, 0, false, null, null, false, false, "", ql);
  a._reactRootContainer = k2;
  a[uf] = k2.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  Sk(function() {
    gl(b, k2, c, d);
  });
  return k2;
}
function sl(a, b, c, d, e) {
  var f2 = c._reactRootContainer;
  if (f2) {
    var g = f2;
    if ("function" === typeof e) {
      var h2 = e;
      e = function() {
        var a2 = hl(g);
        h2.call(a2);
      };
    }
    gl(b, g, a, e);
  } else
    g = rl(c, b, a, e, d);
  return hl(g);
}
Ec = function(a) {
  switch (a.tag) {
    case 3:
      var b = a.stateNode;
      if (b.current.memoizedState.isDehydrated) {
        var c = tc(b.pendingLanes);
        0 !== c && (Cc(b, c | 1), Ek(b, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b2 = Zg(a, 1);
        if (null !== b2) {
          var c2 = L();
          mh(b2, a, 1, c2);
        }
      }), jl(a, 1);
  }
};
Fc = function(a) {
  if (13 === a.tag) {
    var b = Zg(a, 134217728);
    if (null !== b) {
      var c = L();
      mh(b, a, 134217728, c);
    }
    jl(a, 134217728);
  }
};
Gc = function(a) {
  if (13 === a.tag) {
    var b = lh(a), c = Zg(a, b);
    if (null !== c) {
      var d = L();
      mh(c, a, b, d);
    }
    jl(a, b);
  }
};
Hc = function() {
  return C;
};
Ic = function(a, b) {
  var c = C;
  try {
    return C = a, b();
  } finally {
    C = c;
  }
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      bb(a, c);
      b = c.name;
      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e)
              throw Error(p$1(90));
            Wa(d);
            bb(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = Zb(a);
  return null === a ? null : a.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b))
    throw Error(p$1(200));
  return dl(a, b, null, c);
};
reactDom_production_min.createRoot = function(a, b) {
  if (!ol(a))
    throw Error(p$1(299));
  var c = false, d = "", e = ll;
  null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
  b = cl(a, 1, false, null, null, c, false, d, e);
  a[uf] = b.current;
  sf(8 === a.nodeType ? a.parentNode : a);
  return new ml(b);
};
reactDom_production_min.findDOMNode = function(a) {
  if (null == a)
    return null;
  if (1 === a.nodeType)
    return a;
  var b = a._reactInternals;
  if (void 0 === b) {
    if ("function" === typeof a.render)
      throw Error(p$1(188));
    a = Object.keys(a).join(",");
    throw Error(p$1(268, a));
  }
  a = Zb(b);
  a = null === a ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a) {
  return Sk(a);
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!pl(b))
    throw Error(p$1(200));
  return sl(null, a, b, true, c);
};
reactDom_production_min.hydrateRoot = function(a, b, c) {
  if (!ol(a))
    throw Error(p$1(405));
  var d = null != c && c.hydratedSources || null, e = false, f2 = "", g = ll;
  null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f2 = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
  b = fl(b, null, a, 1, null != c ? c : null, e, false, f2, g);
  a[uf] = b.current;
  sf(a);
  if (d)
    for (a = 0; a < d.length; a++)
      c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
        c,
        e
      );
  return new nl(b);
};
reactDom_production_min.render = function(a, b, c) {
  if (!pl(b))
    throw Error(p$1(200));
  return sl(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!pl(a))
    throw Error(p$1(40));
  return a._reactRootContainer ? (Sk(function() {
    sl(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!pl(c))
    throw Error(p$1(200));
  if (null == a || void 0 === a._reactInternals)
    throw Error(p$1(38));
  return sl(a, b, c, false, d);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function ownKeys(t2, e) {
  var r2, n2 = Object.keys(t2);
  return Object.getOwnPropertySymbols && (r2 = Object.getOwnPropertySymbols(t2), e && (r2 = r2.filter(function(e2) {
    return Object.getOwnPropertyDescriptor(t2, e2).enumerable;
  })), n2.push.apply(n2, r2)), n2;
}
function _objectSpread2(t2) {
  for (var e = 1; e < arguments.length; e++) {
    var r2 = null != arguments[e] ? arguments[e] : {};
    e % 2 ? ownKeys(Object(r2), true).forEach(function(e2) {
      _defineProperty(t2, e2, r2[e2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(r2)) : ownKeys(Object(r2)).forEach(function(e2) {
      Object.defineProperty(t2, e2, Object.getOwnPropertyDescriptor(r2, e2));
    });
  }
  return t2;
}
function _typeof(e) {
  return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e2) {
    return typeof e2;
  } : function(e2) {
    return e2 && "function" == typeof Symbol && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
  })(e);
}
function _classCallCheck(e, t2) {
  if (!(e instanceof t2))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, t2) {
  for (var r2 = 0; r2 < t2.length; r2++) {
    var n2 = t2[r2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e, n2.key, n2);
  }
}
function _createClass(e, t2, r2) {
  return t2 && _defineProperties(e.prototype, t2), r2 && _defineProperties(e, r2), Object.defineProperty(e, "prototype", { writable: false }), e;
}
function _defineProperty(e, t2, r2) {
  return t2 in e ? Object.defineProperty(e, t2, { value: r2, enumerable: true, configurable: true, writable: true }) : e[t2] = r2, e;
}
function _extends() {
  return (_extends = Object.assign ? Object.assign.bind() : function(e) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2, n2 = arguments[t2];
      for (r2 in n2)
        Object.prototype.hasOwnProperty.call(n2, r2) && (e[r2] = n2[r2]);
    }
    return e;
  }).apply(this, arguments);
}
function _inherits(e, t2) {
  if ("function" != typeof t2 && null !== t2)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e, writable: true, configurable: true } }), Object.defineProperty(e, "prototype", { writable: false }), t2 && _setPrototypeOf(e, t2);
}
function _getPrototypeOf(e) {
  return (_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e2) {
    return e2.__proto__ || Object.getPrototypeOf(e2);
  })(e);
}
function _setPrototypeOf(e, t2) {
  return (_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e2, t3) {
    return e2.__proto__ = t3, e2;
  })(e, t2);
}
function _isNativeReflectConstruct() {
  if ("undefined" == typeof Reflect || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if ("function" == typeof Proxy)
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch (e) {
    return false;
  }
}
function _objectWithoutPropertiesLoose(e, t2) {
  if (null == e)
    return {};
  for (var r2, n2 = {}, o = Object.keys(e), a = 0; a < o.length; a++)
    r2 = o[a], 0 <= t2.indexOf(r2) || (n2[r2] = e[r2]);
  return n2;
}
function _objectWithoutProperties(e, t2) {
  if (null == e)
    return {};
  var r2, n2 = _objectWithoutPropertiesLoose(e, t2);
  if (Object.getOwnPropertySymbols)
    for (var o = Object.getOwnPropertySymbols(e), a = 0; a < o.length; a++)
      r2 = o[a], 0 <= t2.indexOf(r2) || Object.prototype.propertyIsEnumerable.call(e, r2) && (n2[r2] = e[r2]);
  return n2;
}
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _possibleConstructorReturn(e, t2) {
  if (t2 && ("object" == typeof t2 || "function" == typeof t2))
    return t2;
  if (void 0 !== t2)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(e);
}
function _createSuper(r2) {
  var n2 = _isNativeReflectConstruct();
  return function() {
    var e, t2 = _getPrototypeOf(r2);
    return _possibleConstructorReturn(this, n2 ? (e = _getPrototypeOf(this).constructor, Reflect.construct(t2, arguments, e)) : t2.apply(this, arguments));
  };
}
function _slicedToArray(e, t2) {
  return _arrayWithHoles(e) || _iterableToArrayLimit(e, t2) || _unsupportedIterableToArray(e, t2) || _nonIterableRest();
}
function _toConsumableArray(e) {
  return _arrayWithoutHoles(e) || _iterableToArray(e) || _unsupportedIterableToArray(e) || _nonIterableSpread();
}
function _arrayWithoutHoles(e) {
  if (Array.isArray(e))
    return _arrayLikeToArray(e);
}
function _arrayWithHoles(e) {
  if (Array.isArray(e))
    return e;
}
function _iterableToArray(e) {
  if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"])
    return Array.from(e);
}
function _iterableToArrayLimit(e, t2) {
  var r2 = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
  if (null != r2) {
    var n2, o, a = [], i = true, u2 = false;
    try {
      for (r2 = r2.call(e); !(i = (n2 = r2.next()).done) && (a.push(n2.value), !t2 || a.length !== t2); i = true)
        ;
    } catch (e2) {
      u2 = true, o = e2;
    } finally {
      try {
        i || null == r2.return || r2.return();
      } finally {
        if (u2)
          throw o;
      }
    }
    return a;
  }
}
function _unsupportedIterableToArray(e, t2) {
  var r2;
  if (e)
    return "string" == typeof e ? _arrayLikeToArray(e, t2) : "Map" === (r2 = "Object" === (r2 = Object.prototype.toString.call(e).slice(8, -1)) && e.constructor ? e.constructor.name : r2) || "Set" === r2 ? Array.from(e) : "Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? _arrayLikeToArray(e, t2) : void 0;
}
function _arrayLikeToArray(e, t2) {
  (null == t2 || t2 > e.length) && (t2 = e.length);
  for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
    n2[r2] = e[r2];
  return n2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toPrimitive(e, t2) {
  if ("object" != typeof e || null === e)
    return e;
  var r2 = e[Symbol.toPrimitive];
  if (void 0 === r2)
    return ("string" === t2 ? String : Number)(e);
  r2 = r2.call(e, t2 || "default");
  if ("object" != typeof r2)
    return r2;
  throw new TypeError("@@toPrimitive must return a primitive value.");
}
function _toPropertyKey(e) {
  e = _toPrimitive(e, "string");
  return "symbol" == typeof e ? e : String(e);
}
var originOptions = { react: { componentWrap: "div", slotWrap: "div", componentWrapAttrs: { __use_react_component_wrap: "", style: { all: "unset" } }, slotWrapAttrs: { __use_react_slot_wrap: "", style: { all: "unset" } }, vueNamedSlotsKey: ["node:"] }, vue: { componentWrapHOC: function(t2) {
  return function() {
    var e = (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}).portals;
    return reactExports.createElement(reactExports.Fragment, null, t2, (void 0 === e ? [] : e).map(function(e2) {
      var t3 = e2.Portal, e2 = e2.key;
      return reactExports.createElement(t3, { key: e2 });
    }));
  };
}, componentWrapAttrs: { "data-use-vue-component-wrap": "", style: { all: "unset" } }, slotWrapAttrs: { "data-use-vue-slot-wrap": "", style: { all: "unset" } } } };
function setOptions() {
  var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : { react: {}, vue: {} }, t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : originOptions, r2 = 2 < arguments.length ? arguments[2] : void 0, t2 = (e.vue || (e.vue = {}), e.react || (e.react = {}), [t2, _objectSpread2(_objectSpread2({}, e), {}, { react: _objectSpread2(_objectSpread2(_objectSpread2({}, t2.react), e.react), {}, { componentWrapAttrs: _objectSpread2(_objectSpread2({}, t2.react.componentWrapAttrs), e.react.componentWrapAttrs), slotWrapAttrs: _objectSpread2(_objectSpread2({}, t2.react.slotWrapAttrs), e.react.slotWrapAttrs) }), vue: _objectSpread2(_objectSpread2(_objectSpread2({}, t2.vue), e.vue), {}, { componentWrapAttrs: _objectSpread2(_objectSpread2({}, t2.vue.componentWrapAttrs), e.vue.componentWrapAttrs), slotWrapAttrs: _objectSpread2(_objectSpread2({}, t2.vue.slotWrapAttrs), e.vue.slotWrapAttrs) }) })]);
  return r2 && t2.unshift({}), Object.assign.apply(this, t2);
}
var domMethods = ["getElementById", "getElementsByClassName", "getElementsByTagName", "getElementsByTagNameNS", "querySelector", "querySelectorAll"], domTopObject = { Document: {}, Element: {} };
function overwriteDomMethods(i) {
  Object.keys(domTopObject).forEach(function(e) {
    domMethods.forEach(function(o) {
      var a = window[e].prototype[o];
      domTopObject[e][o] = a, window[e].prototype[o] = function() {
        for (var e2 = arguments.length, t2 = new Array(e2), r2 = 0; r2 < e2; r2++)
          t2[r2] = arguments[r2];
        var n2 = a.apply(this, t2);
        return n2 && (n2.constructor !== NodeList || n2.constructor === NodeList && 0 < n2.length) ? n2 : Element.prototype[o].apply(i, t2);
      };
    });
  });
}
function recoverDomMethods() {
  Object.keys(domTopObject).forEach(function(t2) {
    domMethods.forEach(function(e) {
      window[t2].prototype[e] = domTopObject[t2][e];
    });
  });
}
var _excluded = ["ref"], _excluded2 = ["key"], _excluded3 = ["hashList"], ReactMajorVersion = parseInt(reactExports.version);
function toRaws(e) {
  return e;
}
var FunctionComponentWrap = function() {
  _inherits(r2, reactExports.Component);
  var t2 = _createSuper(r2);
  function r2(e) {
    return _classCallCheck(this, r2), t2.call(this, e);
  }
  return _createClass(r2, [{ key: "render", value: function() {
    var e = this.props.component, t3 = this.props.passedProps, t3 = (t3.ref, _objectWithoutProperties(t3, _excluded));
    return reactExports.createElement(e, t3, this.props.children);
  } }]), r2;
}(), createReactContainer = function(p2, _, f2) {
  var e = function() {
    _inherits(l2, reactExports.Component);
    var r2 = _createSuper(l2);
    function l2(e2) {
      var t2;
      return _classCallCheck(this, l2), (t2 = r2.call(this, e2)).state = _objectSpread2(_objectSpread2({}, e2), _.isSlots ? { children: p2 } : {}), t2.setRef = t2.setRef.bind(_assertThisInitialized(t2)), t2.vueInReactCall = t2.vueInReactCall.bind(_assertThisInitialized(t2)), (t2.__veauryVueWrapperRef__ = f2).__veauryVueInReactCall__ = t2.vueInReactCall, t2;
    }
    return _createClass(l2, [{ key: "reactPropsLinkToVueInstance", value: function(t2) {
      Object.keys(t2).forEach(function(e2) {
        f2[e2] || (f2[e2] = t2[e2]);
      }), Object.getOwnPropertyNames(t2.__proto__).filter(function(e2) {
        return ["constructor", "render"].indexOf(e2) < 0;
      }).forEach(function(e2) {
        f2[e2] || (f2[e2] = t2[e2]);
      });
    } }, { key: "setRef", value: function(e2) {
      var t2 = this;
      e2 && (f2.__veauryReactRef__ = e2, this.reactPropsLinkToVueInstance(e2), Promise.resolve().then(function() {
        return t2.reactPropsLinkToVueInstance(e2);
      }), (this.setRef.current = e2).__veauryVueWrapperRef__ = f2);
    } }, { key: "createSlot", value: function(r3) {
      return { originVNode: r3, inheritAttrs: false, __fromReactSlot: true, render: function() {
        var e2, t2;
        return 1 === (null == (e2 = r3 = (r3 = (null == (t2 = this.$slots) || null == (e2 = t2.default) ? void 0 : e2.call(t2)) || r3) instanceof Function ? r3(this) : r3) ? void 0 : e2.length) && null != (t2 = r3[0]) && t2.data && ((e2 = this.$attrs).key, t2 = _objectWithoutProperties(e2, _excluded2), r3[0].props = _objectSpread2(_objectSpread2({}, t2), r3[0].props)), r3;
      } };
    } }, { key: "componentWillUnmount", value: function() {
      f2.__veauryReactRef__ && (f2.__veauryReactRef__.__veauryVueWrapperRef__ = null, f2.__veauryReactRef__ = null);
    } }, { key: "vueInReactCall", value: function(e2) {
      var r3 = this, n2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
      return (2 < arguments.length ? arguments[2] : void 0) && e2 && e2[0] ? e2.map(function(e3, t2) {
        return applyVueInReact(r3.createSlot(e3 instanceof Function ? e3 : [e3]), _objectSpread2(_objectSpread2(_objectSpread2({}, _), n2), {}, { isSlots: true, wrapInstance: f2 })).render({ key: (null == e3 || null == (e3 = e3.data) ? void 0 : e3.key) || t2 });
      }) : applyVueInReact(this.createSlot(e2), _objectSpread2(_objectSpread2(_objectSpread2({}, _), n2), {}, { isSlots: true, wrapInstance: f2 })).render();
    } }, { key: "render", value: function() {
      var e2, t2, r3, n2 = this, o = this.state, a = o.hashList, i = _objectWithoutProperties(o, _excluded3), u2 = {}, c = {};
      for (e2 in i)
        t2 = e2, r3 = void 0, i.hasOwnProperty(t2) && null != i[t2] && (i[t2].__slot ? (i[t2].reactSlot ? i[t2] = i[t2].reactSlot : (r3 = i[t2], _.defaultSlotsFormatter && i[t2].__trueChildren ? (i[t2].__top__ = n2.__veauryVueWrapperRef__, i[t2] = _.defaultSlotsFormatter(i[t2].__trueChildren, n2.vueInReactCall, a), i[t2] instanceof Array ? i[t2] = _toConsumableArray(i[t2]) : -1 < ["string", "number"].indexOf(_typeof(i[t2])) ? i[t2] = [i[t2]] : "object" === _typeof(i[t2]) && (i[t2] = _objectSpread2({}, i[t2]))) : i[t2] = _objectSpread2({}, applyVueInReact(n2.createSlot(i[t2]), _objectSpread2(_objectSpread2({}, _), {}, { isSlots: true, wrapInstance: f2 })).render()), i[t2].vueFunction = r3), u2[t2] = i[t2]) : i[t2].__scopedSlot && (i[t2] = i[t2](n2.createSlot), c[t2] = i[t2]));
      var s, o = {};
      return o.ref = this.setRef, _.isSlots ? this.state.children || this.props.children : (s = i, s = _objectSpread2(_objectSpread2(_objectSpread2({}, s = _.defaultPropsFormatter ? _.defaultPropsFormatter(i, this.vueInReactCall, a) : s), u2), c), Object.getPrototypeOf(p2) !== Function.prototype && ("object" !== _typeof(p2) || p2.render) || l2.catchVueRefs() ? (Object.getPrototypeOf(p2) === Function.prototype && delete o.ref, reactExports.createElement(p2, _extends({}, s, o))) : reactExports.createElement(FunctionComponentWrap, _extends({ passedProps: s, component: p2 }, o), s.children));
    } }], [{ key: "catchVueRefs", value: function() {
      if (f2.$parent) {
        for (var e2 in f2.$parent.$refs)
          if (f2.$parent.$refs[e2] === f2)
            return true;
      }
      return false;
    } }]), l2;
  }();
  return _defineProperty(e, "displayName", "applyReact_".concat(p2.displayName || p2.name || "Component")), e;
};
function applyReactInVue(m2) {
  var b = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
  return m2.__esModule && m2.default && (m2 = m2.default), b.isSlots && (m2 = m2()), b = setOptions(b, void 0, true), { originReactComponent: m2, setup: function(e, t2) {
    var r2, n2, o, a;
    if (!b.isSlots)
      return r2 = {}, n2 = reactive({}), o = getCurrentInstance(), "function" == typeof (a = b.useInjectPropsFromWrapper || m2.__veauryInjectPropsFromWrapper__) && ("function" != typeof (a = a.call(o.proxy, e)) ? (Object.assign(n2, a), r2.__veauryInjectedProps__ = n2) : o.proxy.__veauryInjectedComputed__ = a), r2;
  }, data: function() {
    return { VEAURY_Portals: [] };
  }, created: function() {
    this.__veauryPortalKeyPool__ = [], this.__veauryMaxPortalCount__ = 0;
  }, computed: { __veauryInjectedProps__: function() {
    var e;
    return null == (e = this.__veauryInjectedComputed__) ? void 0 : e.call(this);
  } }, render: function() {
    var e = h(b.react.componentWrap, _objectSpread2({ ref: "react" }, b.react.componentWrapAttrs || {}), this.VEAURY_Portals.map(function(e2) {
      var t2 = e2.Portal, e2 = e2.key;
      return t2(h, e2);
    }));
    return this.__veauryCheckReactSlot__(this.$slots), e;
  }, methods: { __veauryCheckReactSlot__: function(i) {
    var u2 = this;
    function c(e, t2, r2) {
      return t2[r2] && (e[r2] = t2[r2], 1);
    }
    Object.keys(i).forEach(function(e) {
      try {
        var t2, r2, n2, o = i[e], a = o.apply(u2, o.__reactArgs || [{}]);
        (o.__trueChildren = a).forEach(function(e2) {
          e2.children && u2.__veauryCheckReactSlot__(e2.children);
        }), 1 !== a.length || c(o, r2 = a[0], "reactSlot") || c(o, r2, "reactFunction") || r2.type !== Fragment || 1 !== (null == (t2 = r2.children) ? void 0 : t2.length) || c(o, n2 = r2.children[0], "reactSlot") || c(o, n2, "reactFunction");
      } catch (e2) {
      }
    });
  }, __veauryPushVuePortal__: function(e) {
    var t2 = this.__veauryPortalKeyPool__.shift() || this.__veauryMaxPortalCount__++;
    this.VEAURY_Portals.push({ Portal: e, key: t2 });
  }, __veauryRemoveVuePortal__: function(r2) {
    var n2, e = this.VEAURY_Portals.find(function(e2, t2) {
      if (e2.Portal === r2)
        return n2 = t2, true;
    });
    this.__veauryPortalKeyPool__.push(e.key), this.VEAURY_Portals.splice(n2, 1);
  }, __veauryGetScopeSlot__: function(i, u2, t2) {
    var c = this;
    function e(a) {
      function e2() {
        for (var e3, t3 = this, r2 = arguments.length, n2 = new Array(r2), o = 0; o < r2; o++)
          n2[o] = arguments[o];
        return i.reactFunction ? i.reactFunction.apply(this, n2) : b.defaultSlotsFormatter ? ((e3 = i.apply(this, n2)).__top__ = c, (e3 = b.defaultSlotsFormatter(e3, c.__veauryVueInReactCall__, u2)) instanceof Array || -1 < _typeof(e3).indexOf("string", "number") ? e3 = _toConsumableArray(e3) : "object" === _typeof(e3) && (e3 = _objectSpread2({}, e3)), e3) : applyVueInReact(a(function() {
          return i.apply(t3, n2);
        }), _objectSpread2(_objectSpread2({}, b), {}, { isSlots: true, wrapInstance: c })).render();
      }
      return b.pureTransformer && t2 ? e2.vueFunction = t2 : e2.vueFunction = i, e2;
    }
    return e.__scopedSlot = true, e;
  }, __veaurySyncUpdateProps__: function(e) {
    this.__veauryReactInstance__ && this.__veauryReactInstance__.setState(e);
  }, __veauryMountReactComponent__: function(e, t2) {
    var r2, n2, o = this, a = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {}, i = {}, u2 = [], c = this.$.vnode.scopeId, s = (c && (i[c] = "", u2.push(c)), {}), l2 = {};
    if (!e || null != t2 && t2.slot)
      for (var p2 in this.$slots || {})
        (function(t3) {
          var e2;
          o.$slots.hasOwnProperty(t3) && null != o.$slots[t3] && ((e2 = b.react.vueNamedSlotsKey.find(function(e3) {
            return 0 === t3.indexOf(e3);
          })) || "default" === t3 ? (e2 = t3.replace(new RegExp("^".concat(e2)), ""), s[e2] = o.$slots[t3], s[e2].__slot = true) : l2[t3] = o.__veauryGetScopeSlot__(o.$slots[t3], u2, null == (e2 = o.$.vnode) || null == (e2 = e2.children) ? void 0 : e2[t3]));
        })(p2);
    (!e || null != t2 && t2.slot) && (n2 = _objectSpread2({}, s), r2 = n2.default, delete n2.default), this.__veauryLast__ = this.__veauryLast__ || {}, this.__veauryLast__.slot = this.__veauryLast__.slot || {}, this.__veauryLast__.attrs = this.__veauryLast__.attrs || {};
    var _ = { slot: function() {
      o.__veauryLast__.slot = _objectSpread2(_objectSpread2(_objectSpread2({}, r2 ? { children: r2 } : { children: null }), n2), l2);
    }, attrs: function() {
      o.__veauryLast__.attrs = o.$attrs;
    } };
    if (t2 && Object.keys(t2).forEach(function(e2) {
      return _[e2]();
    }), e) {
      let f2 = function() {
        o.__veauryReactInstance__ && o.__veauryReactInstance__.setState(function(t3) {
          return Object.keys(t3).forEach(function(e2) {
            b.isSlots && "children" === e2 || delete t3[e2];
          }), _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, o.__veauryCache__), toRaws(o.__veauryInjectedProps__)), !b.isSlots && o.__veauryLast__.slot), toRaws(o.__veauryLast__.attrs));
        }), o.__veauryCache__ = null;
      };
      !this.microTaskUpdate || this.__veauryCache__ || this.$nextTick(function() {
        f2(), o.microTaskUpdate = false;
      }), this.macroTaskUpdate && (clearTimeout(this.updateTimer), this.updateTimer = setTimeout(function() {
        clearTimeout(o.updateTimer), f2(), o.macroTaskUpdate = false;
      })), this.__veauryCache__ = _objectSpread2(_objectSpread2({}, this.__veauryCache__ || {}), _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, a), this.$attrs.class ? { className: this.$attrs.class } : {}), _objectSpread2({}, i)), {}, { hashList: u2 }, this.$attrs.style ? { style: this.$attrs.style } : {})), this.macroTaskUpdate || this.microTaskUpdate || f2();
    } else {
      _.slot(), _.attrs();
      var c = createReactContainer(m2, b, this), d = reactExports.createElement(c, _extends({}, toRaws(this.$attrs), toRaws(this.__veauryInjectedProps__), { children: r2 }, n2, l2, this.$attrs.class ? { className: this.$attrs.class } : {}, i, { hashList: u2 }, this.$attrs.style ? { style: this.$attrs.style } : {}, { ref: function(e2) {
        return o.__veauryReactInstance__ = e2;
      } })), y2 = this.$refs.react, v2 = b.wrapInstance;
      if (v2)
        (v2 = b.wrapInstance).__veauryVueWrapperRef__ = this;
      else
        for (var h2 = this.$parent; h2; ) {
          if (h2.parentReactWrapperRef) {
            v2 = h2.parentReactWrapperRef;
            break;
          }
          if (h2.reactWrapperRef) {
            v2 = h2.reactWrapperRef;
            break;
          }
          h2 = h2.$parent;
        }
      v2 ? (this.parentReactWrapperRef = v2, this.reactPortal = function() {
        return reactDomExports.createPortal(d, y2);
      }, v2.pushReactPortal(this.reactPortal)) : 17 < ReactMajorVersion ? (void 0 !== ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && (ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = true), this.__veauryReactApp__ = ReactDOM.createRoot(y2), this.__veauryReactApp__.render(d)) : ReactDOM.render(d, y2);
    }
  } }, mounted: function() {
    var e = this;
    this.__VEAURY_IGNORE_STRANGE_UPDATE__ = true, Promise.resolve().then(function() {
      e.__VEAURY_IGNORE_STRANGE_UPDATE__ = false;
    }), clearTimeout(this.updateTimer), this.__veauryMountReactComponent__();
  }, beforeUnmount: function() {
    var e;
    clearTimeout(this.updateTimer), this.reactPortal ? (overwriteDomMethods(this.$refs.react), null != (e = this.parentReactWrapperRef) && e.removeReactPortal(this.reactPortal)) : (overwriteDomMethods(this.$refs.react), 17 < ReactMajorVersion ? this.__veauryReactApp__.unmount() : ReactDOM.unmountComponentAtNode(this.$refs.react)), recoverDomMethods();
  }, updated: function() {
    this.__VEAURY_IGNORE_STRANGE_UPDATE__ || this.__veauryMountReactComponent__(true, { slot: true });
  }, inheritAttrs: false, watch: { $attrs: { handler: function() {
    this.__veauryMountReactComponent__(true, { attrs: true });
  }, deep: true }, __veauryInjectedProps__: { handler: function() {
    this.__veauryMountReactComponent__(true, { attrs: true });
  }, deep: true } } };
}
var REACT_ALL_HANDLERS = /* @__PURE__ */ new Set(["onClick", "onContextMenu", "onDoubleClick", "onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp", "onChange", "onInput", "onInvalid", "onReset", "onSubmit", "onError", "onLoad", "onPointerDown", "onPointerMove", "onPointerUp", "onPointerCancel", "onGotPointerCapture", "onLostPointerCapture", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut", "onSelect", "onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart", "onScroll", "onWheel", "onAbort", "onCanPlay", "onCanPlayThrough", "onDurationChange", "onEmptied", "onEncrypted", "onEnded", "onError", "onLoadedData", "onLoadedMetadata", "onLoadStart", "onPause", "onPlay", "onPlaying", "onProgress", "onRateChange", "onSeeked", "onSeeking", "onStalled", "onSuspend", "onTimeUpdate", "onVolumeChange", "onWaiting", "onLoad", "onError", "onAnimationStart", "onAnimationEnd", "onAnimationIteration", "onTransitionEnd", "onToggle"]);
function lookupVueWrapperRef(e, t2) {
  for (var r2 = null == (e = t2 = (null == e ? void 0 : e._reactInternals) || (null == e ? void 0 : e._reactInternalFiber) || t2) ? void 0 : e.return; r2; ) {
    var n2 = r2.stateNode;
    if (n2 = (null == n2 ? void 0 : n2.parentVueWrapperRef) || (null == n2 ? void 0 : n2.__veauryVueWrapperRef__))
      return n2;
    r2 = r2.return;
  }
}
function createModifiers(e, t2, r2) {
  var n2 = {};
  return r2.forEach(function(e2) {
    n2[e2] = true;
  }), e[("modelValue" === t2 ? "model" : t2) + "Modifiers"] = n2;
}
function setVModel(e, t2, r2) {
  var n2 = this, o = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : "v-model", a = t2;
  if (!(a instanceof Array))
    throw Error("[error:veaury] Parameter type error from '".concat(o, "', a single v-model is an array, such as [val, setter, argumentKey, modifiers] or [val, setter, modifiers]"));
  if ("function" != typeof a[1])
    throw Error("[error:veaury] Parameter type error from '".concat(o, "', a single v-model is an array, the second element of the array must be a setter function"));
  var i = a[1], u2 = ("string" == typeof a[2] ? (r2 = a[2], a[3] instanceof Array && createModifiers(e, r2, a[3])) : a[2] instanceof Array && createModifiers(e, r2, a[2]), e["onUpdate:" + r2]);
  e["onUpdate:" + r2] = "function" == typeof u2 ? function() {
    for (var e2 = arguments.length, t3 = new Array(e2), r3 = 0; r3 < e2; r3++)
      t3[r3] = arguments[r3];
    u2.apply(n2, t3), i.apply(n2, t3);
  } : i, e[r2] = a[0];
}
function parseVModel(a) {
  var i = this, r2 = {}, u2 = _objectSpread2({}, a);
  return Object.keys(a).forEach(function(n2) {
    var o, e = n2.match(/^onUpdate-([^-]+)/);
    if (e)
      delete u2[n2], o = r2["onUpdate:".concat(e[1])], r2["onUpdate:".concat(e[1])] = "function" == typeof o ? function() {
        for (var e2 = arguments.length, t3 = new Array(e2), r3 = 0; r3 < e2; r3++)
          t3[r3] = arguments[r3];
        o.apply(i, t3), a[n2].apply(i, t3);
      } : a[n2];
    else if (e = n2.match(/^v-model($|:([^:]+)|-([^:]+))/))
      e = e[2] || e[3] || "modelValue", setVModel(r2, a[n2], e), delete u2[n2];
    else if ("v-models" === n2) {
      if ("object" !== _typeof(a[n2]) || a[n2] instanceof Array)
        throw Error("[error:veaury] The parameter 'v-models' must be an object type, such as {[argumentKey]: singleVModel}");
      var t2 = a[n2];
      Object.keys(t2).forEach(function(e2) {
        setVModel(r2, t2[e2], e2, "v-models");
      }), delete u2[n2];
    }
  }), _objectSpread2(_objectSpread2({}, u2), r2);
}
var _default = function() {
  function e() {
    _classCallCheck(this, e), _defineProperty(this, "pool", /* @__PURE__ */ new Set());
  }
  return _createClass(e, [{ key: "getRandomId", value: function(e2) {
    var t2 = e2 + (Math.random() + "").substr(2);
    return this.pool.has(t2) ? this.getRandomId(e2) : (this.pool.add(t2), t2);
  } }]), e;
}();
function RenderReactNode(e, t2) {
  var r2, e = e.node;
  if ("function" == typeof e && (e = e()), null != (r2 = t2) && r2.current || "function" == typeof t2 || null != (r2 = t2) && r2.toString().match(/^function/) || (t2 = null), -1 < ["string", "number"].indexOf(_typeof(e)))
    return e;
  if (e instanceof Array) {
    if (1 !== e.length)
      return e;
    e = e[0];
  }
  return _objectSpread2(_objectSpread2({}, e), {}, { ref: t2 });
}
var Bridge = applyReactInVue(RenderReactNode);
function WrapVue(e) {
  return h(Bridge, { node: function() {
    return e.node;
  } });
}
WrapVue.originReactComponent = reactExports.forwardRef(RenderReactNode);
var _excluded$1 = ["component", "node"], _excluded2$1 = ["component", "$slots", "children", "class", "style"], _excluded3$1 = ["className", "classname"], optionsName = "veaury-options", random = new _default();
function filterVueComponent(e, t2) {
  var r2;
  return e = "string" == typeof e && t2 ? null == (t2 = t2.$) || null == (t2 = t2.appContext) || null == (t2 = t2.app) || null == (r2 = t2.component) ? void 0 : r2.call(t2, e) : e;
}
function transferSlots(r2) {
  if (r2)
    return Object.keys(r2).forEach(function(e) {
      var t2 = r2[e];
      null != t2 && ("function" == typeof t2 ? (r2[e] = t2, r2[e].reactFunction = t2) : (r2[e] = function() {
        return t2;
      }, r2[e].reactSlot = t2), t2.vueFunction && (r2[e].vueFunction = t2.vueFunction));
    }), r2;
}
function VNodeBridge(e) {
  var t2;
  return null == (t2 = e.node) ? void 0 : t2.call(e);
}
var VueContainer = reactExports.forwardRef(function(e, t2) {
  var r2, n2 = e.component, o = e.node, e = _objectWithoutProperties(e, _excluded$1);
  if (null == n2 && null == o)
    return null;
  if (null != o) {
    if (o.$$typeof || "string" == typeof o || "number" == typeof o)
      return o;
    "function" != typeof o && (r2 = o, o = function() {
      return r2;
    });
  }
  var a, n2 = n2 || VNodeBridge, i = setOptions(e[optionsName] || {}, void 0, true), u2 = i.useInjectPropsFromWrapper || n2.__veauryInjectPropsFromWrapper__;
  return i.isSlots || "function" == typeof u2 && (a = u2(e)), reactExports.createElement(VueComponentLoader, _extends({}, _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({ component: n2 }, o ? { node: o } : {}), e), a), {}, _defineProperty({}, optionsName, i)), { ref: t2 }));
}), VueComponentLoader = function() {
  _inherits(n2, reactExports.Component);
  var r2 = _createSuper(n2);
  function n2(e) {
    var t2;
    return _classCallCheck(this, n2), (t2 = r2.call(this, e)).state = { portals: [] }, t2.__veauryPortalKeyPool__ = [], t2.__veauryMaxPortalCount__ = 0, t2.__veauryCurrentVueComponent__ = e.component, t2.__veauryCreateVueInstance__ = t2.__veauryCreateVueInstance__.bind(_assertThisInitialized(t2)), t2.__veauryVueComponentContainer__ = t2.createVueComponentContainer(), t2;
  }
  return _createClass(n2, [{ key: "pushReactPortal", value: function(e) {
    var t2 = this.state.portals, r3 = this.__veauryPortalKeyPool__.shift() || this.__veauryMaxPortalCount__++;
    t2.push({ Portal: e, key: r3 }), this.setState({ portals: t2 });
  } }, { key: "removeReactPortal", value: function(r3) {
    var n3, e = this.state.portals, t2 = e.find(function(e2, t3) {
      if (e2.Portal === r3)
        return n3 = t3, true;
    });
    this.__veauryPortalKeyPool__.push(t2.key), e.splice(n3, 1), this.__veauryVueRef__ && this.setState({ portals: e });
  } }, { key: "createVueComponentContainer", value: function() {
    var t2 = this, r3 = {}, e = this.props[optionsName];
    return e.isSlots ? (Object.keys(this.props).forEach(function(e2) {
      REACT_ALL_HANDLERS.has(e2) && "function" == typeof t2.props[e2] && (r3[e2] = t2.props[e2]);
    }), e.vue.slotWrapAttrs && (r3 = _objectSpread2(_objectSpread2({}, r3), e.vue.slotWrapAttrs))) : e.vue.componentWrapAttrs && (r3 = _objectSpread2(_objectSpread2({}, r3), e.vue.componentWrapAttrs)), e.vue.componentWrapHOC(reactExports.createElement("div", _extends({}, e.vue.componentWrapAttrs, { ref: this.__veauryCreateVueInstance__, key: null })), r3);
  } }, { key: "shouldComponentUpdate", value: function(e, t2, r3) {
    var n3, o, a, i, u2 = this;
    return e === this.props || (n3 = e.component, e[optionsName], o = void 0 === (o = e["v-slots"]) ? null : o, a = e.children, e = _objectWithoutProperties(e, ["component", optionsName, "v-slots", "children"].map(_toPropertyKey)), this.__veauryCurrentVueComponent__ !== n3 && this.updateVueComponent(n3), !!n3.__fromReactSlot || (this.__veauryVueInstance__ ? (a && (o = o || {}, "object" !== _typeof(a) || a instanceof Array || a.$$typeof ? o.default = a : o = a), (i = this.__veauryVueInstance__.$data.$slots) && Object.keys(i).forEach(function(e2) {
      delete i[e2];
    }), o && (i || (this.__veauryVueInstance__.$data.$slots = {}), Object.assign(this.__veauryVueInstance__.$data.$slots, transferSlots(o))), Object.keys(this.__veauryVueInstance__.$data).forEach(function(e2) {
      "$slots" !== e2 && delete u2.__veauryVueInstance__.$data[e2];
    }), this.__veauryVueInstance__ && Object.assign(this.__veauryVueInstance__.$data, parseVModel(e)), true) : void 0));
  } }, { key: "componentWillUnmount", value: function() {
    this.vuePortal ? this.parentVueWrapperRef.__veauryRemoveVuePortal__(this.vuePortal) : (this.__veauryVueInstance__ && this.__veauryVueInstance__.$.appContext.app.unmount(), random.pool.delete(this.__veauryVueTargetId__));
  } }, { key: "__veauryCreateVueInstance__", value: function(e) {
    var r3 = this, p2 = this, t2 = this.props, _ = (t2.component, t2[optionsName]), n3 = t2.children, o = t2["v-slots"], o = void 0 === o ? {} : o, t2 = _objectWithoutProperties(t2, ["component", optionsName, "children", "v-slots"].map(_toPropertyKey));
    function a(e2) {
      this.__veauryVueInstance__ || (this.__veauryVueInstance__ = e2);
    }
    n3 && ("object" !== _typeof(n3) || n3 instanceof Array || n3.$$typeof ? o.default = n3 : o = n3), (o = transferSlots(o)) && (t2.$slots = o), a = a.bind(this);
    var i, u2 = _objectSpread2({}, parseVModel(t2)), c = { data: function() {
      return _.isSlots ? { children: p2.__veauryCurrentVueComponent__.originVNode } : u2;
    }, created: function() {
      this.reactWrapperRef = p2, a(this);
    }, methods: { reactInVueCall: function(e2) {
      return (2 < arguments.length ? arguments[2] : void 0) && e2 && e2[0] ? e2.map(function(e3, t3) {
        return h(WrapVue, { node: e3, key: (null == e3 || null == (e3 = e3.data) ? void 0 : e3.key) || t3 });
      }) : h(WrapVue, { node: e2 });
    }, getScopedSlots: function(s, e2) {
      var t3, l2 = this, r4 = (this.getScopedSlots.__scopeSlots || (this.getScopedSlots.__scopeSlots = {}), _objectSpread2({}, e2));
      for (t3 in r4)
        (function(u3) {
          var e3, c2;
          !r4.hasOwnProperty(u3) || null == (e3 = r4[u3]) || (r4[u3] = (c2 = e3, function() {
            for (var e4, t4, r5, n4, o2 = arguments.length, a2 = new Array(o2), i2 = 0; i2 < o2; i2++)
              a2[i2] = arguments[i2];
            return c2.vueFunction ? c2.vueFunction.apply(l2, a2) : (r5 = c2.reactSlot, n4 = c2.reactFunction, r5 = r5 || (null == n4 ? void 0 : n4.apply(l2, a2)), n4 = _.defaultSlotsFormatter, null != (e4 = l2.getScopedSlots.__scopeSlots[u3]) && null != (e4 = e4.component) && null != (e4 = e4.ctx) && e4.__veauryReactInstance__ ? (t4 = l2.getScopedSlots.__scopeSlots[u3], Promise.resolve().then(function() {
              var e5;
              null != (e5 = t4) && null != (e5 = e5.component) && null != (e5 = e5.ctx) && null != (e5 = e5.__veauryReactInstance__) && e5.setState({ children: c2.apply(l2, a2) });
            })) : (t4 = n4 && r5 ? [n4(r5, l2.reactInVueCall)] : s(applyReactInVue(function() {
              return c2.apply(l2, a2);
            }, _objectSpread2(_objectSpread2({}, _), {}, { isSlots: true, wrapInstance: p2 }))), l2.getScopedSlots.__scopeSlots[u3] = t4), c2.reactFunction ? t4.reactFunction = c2.reactFunction : c2.reactSlot && (t4.reactSlot = c2.reactSlot), t4);
          }), r4[u3].reactFunction = e3);
        })(t3);
      return r4;
    } }, mounted: function() {
      e.removeAttribute("id"), p2.__veauryVueRef__ = this.$refs.use_vue_wrapper, this.$refs.use_vue_wrapper.reactWrapperRef = p2;
    }, beforeUnmount: function() {
      p2.__veauryVueRef__ = null, this.$refs.use_vue_wrapper.reactWrapperRef = null;
    }, render: function() {
      var e2 = this, t3 = this.$data, r4 = (t3.component, t3.$slots), n4 = (t3.children, t3.class), o2 = t3.style, t3 = _objectWithoutProperties(t3, _excluded2$1), a2 = this.getScopedSlots(h, _objectSpread2({}, r4)), r4 = t3.className, i2 = t3.classname, t3 = _objectWithoutProperties(t3, _excluded3$1), u3 = {};
      return Object.keys(a2).forEach(function(e3) {
        var t4 = a2[e3];
        u3[e3] = "function" == typeof t4 ? t4 : function() {
          return t4;
        };
      }), h(filterVueComponent(p2.__veauryCurrentVueComponent__, this), _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, t3), n4 || r4 || i2 ? { class: n4 || r4 || i2 } : {}), o2 ? { style: o2 } : {}), {}, { ref: "use_vue_wrapper" }), _objectSpread2({}, _.isSlots && this.children ? { default: "function" == typeof this.children ? this.children : function() {
        return e2.children;
      } } : _objectSpread2({}, u3)));
    } };
    e && (i = random.getRandomId("__vue_wrapper_container_"), e.id = i, this.__veauryVueTargetId__ = i, (n3 = _.wrapInstance) ? (n3 = _.wrapInstance).reactWrapperRef = p2 : n3 = lookupVueWrapperRef(this), n3 && document.getElementById(i) ? (this.parentVueWrapperRef = n3, this.vuePortal = function(e2, t3) {
      return e2(Teleport, { to: "#" + i, key: i }, [e2(Object.assign(c, { router: r3._router }))]);
    }, n3.__veauryPushVuePortal__(this.vuePortal)) : (o = createApp(c), "function" == typeof _.beforeVueAppMount && _.beforeVueAppMount(o), this.__veauryVueInstance__ = o.mount(e)));
  } }, { key: "updateVueComponent", value: function(e) {
    this.__veauryVueInstance__ && (e.__fromReactSlot ? this.__veauryVueInstance__.children = "function" == typeof e.originVNode ? e.originVNode : function() {
      return e.originVNode;
    } : (this.__veauryCurrentVueComponent__ = e, this.__veauryVueInstance__.$forceUpdate()));
  } }, { key: "render", value: function() {
    return reactExports.createElement(this.__veauryVueComponentContainer__, { portals: this.state.portals });
  } }]), n2;
}();
function applyVueInReact(r2) {
  var n2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, e = (r2 || console.warn("Component must be passed in applyVueInReact!"), r2.__esModule && r2.default && (r2 = r2.default), reactExports.forwardRef(function(e2, t2) {
    return reactExports.createElement(VueContainer, _extends({}, e2, { component: r2, ref: t2 }, _defineProperty({}, optionsName, n2)));
  }));
  return e.originVueComponent = r2, e;
}
new _default();
function transformer(e) {
  var t2 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t2.globalName, n2 = t2.combinedOption, o = (t2.transparentApi, applyReactInVue(e, n2 || {}));
  return o.install = function(e2) {
    var t3 = (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).globalName;
    return r2 && e2.component(t3 || r2, o), o;
  }, o;
}
function toCamelCase$1(e) {
  return e.replace(/-(\w)/g, function(e2, t2) {
    return t2.toUpperCase();
  });
}
function formatStyle(t2) {
  var r2;
  return t2 ? "string" == typeof t2 ? (t2 = t2.trim()).split(/\s*;\s*/).reduce(function(e, t3) {
    return t3 && 2 === (t3 = t3.split(/\s*:\s*/)).length && Object.assign(e, _defineProperty({}, toCamelCase$1(t3[0]), t3[1])), e;
  }, {}) : "object" === _typeof(t2) ? (r2 = {}, Object.keys(t2).forEach(function(e) {
    r2[toCamelCase$1(e)] = t2[e];
  }), r2) : {} : {};
}
function formatClass(t2) {
  return t2 ? t2 instanceof Array ? t2 : "string" == typeof t2 ? (t2 = t2.trim()).split(/\s+/) : "object" === _typeof(t2) ? Object.keys(t2).filter(function(e) {
    return !!t2[e];
  }) : [] : [];
}
var _excluded$3 = ["ref"];
function getChildInfo(r2, e, o, a, i) {
  var t2 = r2.props || {}, t2 = (t2.ref, _objectWithoutProperties(t2, _excluded$3)), u2 = {}, n2 = (Object.keys(r2.children || {}).forEach(function(t3) {
    var n3 = r2.children[t3], e2 = originOptions.react.vueNamedSlotsKey.find(function(e3) {
      return 0 === t3.indexOf(e3);
    });
    e2 || "default" === t3 ? (e2 = t3.replace(new RegExp("^".concat(e2)), "").replace(/^default$/, "children"), u2[e2] = a(n3(), o, i)) : u2[t3] = function() {
      for (var e3 = arguments.length, t4 = new Array(e3), r3 = 0; r3 < e3; r3++)
        t4[r3] = arguments[r3];
      return n3.__reactArgs = t4, a(n3.apply(this, t4), o, i);
    };
  }), {}), c = formatStyle(t2.style), s = Array.from(new Set(formatClass(t2.class))).join(" ");
  return 0 < Object.keys(c).length && (n2.style = c), "" !== s && (n2.className = s), Object.assign(t2, _objectSpread2(_objectSpread2({}, n2), u2)), delete t2.class, t2;
}
function isTextOwner(e) {
  return e.type === Text;
}
new _default();
function DirectiveHOC(e, t2) {
  var r2;
  return 0 < (null == (r2 = e.dirs) ? void 0 : r2.length) ? reactExports.createElement(FakeDirective, { vnode: e }, t2) : t2;
}
var FakeDirective = function() {
  _inherits(n2, reactExports.Component);
  var r2 = _createSuper(n2);
  function n2(e) {
    var t2;
    return _classCallCheck(this, n2), (t2 = r2.call(this, e)).state = { prevVnode: null, savedDirectives: [], ref: null, prevProps: e }, t2;
  }
  return _createClass(n2, [{ key: "findDirectiveName", value: function(e) {
    var r3 = e.dir, n3 = -1;
    return [this.state.savedDirectives.find(function(e2, t2) {
      if (e2.dir === r3)
        return n3 = t2, true;
    }), n3];
  } }, { key: "doDirective", value: function() {
    var c = this, e = this.state, s = e.savedDirectives;
    if (!(l2 = e.ref)) {
      for (var l2 = (this._reactInternals || this._reactInternalFiber).child; l2 && 5 !== l2.tag; )
        l2 = l2.child;
      if (!l2)
        return;
      l2 = l2.stateNode;
    }
    var p2 = this.props.vnode, e = p2.dirs;
    e && (e.forEach(function(e2) {
      var t2, r3, n3, o, a, i, u2;
      e2 && (u2 = (t2 = _slicedToArray(c.findDirectiveName(e2), 2))[0], t2 = t2[1], r3 = (a = e2.dir).created, n3 = a.beforeMount, o = a.mounted, i = a.beforeUpdate, a = a.updated, u2 ? (s[t2] = _objectSpread2(_objectSpread2(_objectSpread2({}, u2), e2), {}, { oldValue: u2.oldValue }), u2 = [l2, s[t2], p2, c.state.prevVnode], null != i && i.apply(null, u2), null != a && a.apply(null, u2), s[t2].oldValue = e2.value) : (s.push(e2), i = [l2, e2, p2, null], null != r3 && r3.apply(null, i), null != n3 && n3.apply(null, i), null != o && o.apply(null, i), e2.oldValue = e2.value));
    }), this.setState({ prevVnode: _objectSpread2({}, p2), savedDirectives: s, ref: l2 }));
  } }, { key: "componentDidMount", value: function() {
    this.doDirective();
  } }, { key: "componentDidUpdate", value: function(e) {
    e.vnode !== this.props.vnode && this.doDirective();
  } }, { key: "componentWillUnmount", value: function() {
    var a = this, i = this.props.vnode, e = this.state, u2 = e.savedDirectives, c = e.ref, s = e.prevVnode, e = i.dirs;
    e && (e.forEach(function(e2) {
      var t2, r3, n3, o;
      e2 && (t2 = (o = _slicedToArray(a.findDirectiveName(e2), 2))[0], o = o[1], t2 && (r3 = (n3 = e2.dir).beforeUnmount, n3 = n3.unmounted, u2[o] = _objectSpread2(_objectSpread2({}, t2), e2), o = [c, t2, i, s], null != r3 && r3.apply(null, o), null != n3 && n3.apply(null, o)));
    }), this.setState({ prevVnode: _objectSpread2({}, i), savedDirectives: u2 }));
  } }, { key: "render", value: function() {
    var e = this.props;
    e.vnode;
    return e.children;
  } }]), n2;
}();
function couldBeClass(e, t2) {
  var r2;
  return "function" == typeof e && (r2 = e.toString(), void 0 !== e.prototype && (e.prototype.constructor === e && ("class" == r2.slice(0, 5) || (2 <= Object.getOwnPropertyNames(e.prototype).length || !/^function\s+\(|^function\s+anonymous\(/.test(r2) && (!(!t2 || !/^function\s+[A-Z]/.test(r2)) || !!/\b\(this\b|\bthis[\.\[]\b/.test(r2) && (!(t2 && !/classCallCheck\(this/.test(r2)) || /^function\sdefault_\d+\s*\(/.test(r2)))))));
}
function resolveRef(o) {
  var a, e;
  return "function" != typeof (null == (e = o.type) ? void 0 : e.originReactComponent) || couldBeClass(null == (e = o.type) ? void 0 : e.originReactComponent) ? ((e = null == (e = o.ref) ? void 0 : e.r) && "string" == typeof e && (a = e, e = function(e2) {
    var t2;
    e2 && (o.ref.i.refs && ((t2 = _objectSpread2({}, o.ref.i.refs))[a] = e2, o.ref.i.refs = t2), void 0 !== (null == (t2 = o.ref.i.setupState) ? void 0 : t2[a]) && (o.ref.i.setupState[a] = e2));
  }, e = new Proxy(e, { get: function(e2, t2) {
    return e2[t2];
  }, set: function(e2, t2, r2) {
    var n2;
    return null != (n2 = o.ref.i.refs) && n2[a] && ((n2 = _objectSpread2({}, o.ref.i.refs))[t2] = r2, o.ref.i.refs = n2), r2;
  } })), e) : null;
}
function addScopeId(t2, e) {
  return !e || e instanceof Array && 0 === e.length || ("string" == typeof e && (e = [e]), (t2 = _objectSpread2({}, t2)).props = _objectSpread2({}, t2.props), e.forEach(function(e2) {
    t2.props[e2] = "";
  })), t2;
}
var _excluded$4 = ["style", "class"];
function takeVueDomInReact(e, t2, r2, n2, o, a, i) {
  var u2, c, s;
  return "all" === t2 || t2 instanceof Array || (t2 = t2 ? [t2] : []), e.type === Fragment ? o(e.children, r2, a) : "string" == typeof e.type && ("all" === t2 || -1 < t2.indexOf(e.type)) ? (t2 = resolveRef(e), s = (c = e.props || {}).style, u2 = c.class, c = _objectSpread2(_objectSpread2({}, _objectWithoutProperties(c, _excluded$4)), {}, { style: formatStyle(s), className: Array.from(new Set(formatClass(u2))).join(" ") }, t2 ? { ref: t2 } : {}), (s = e.children || c.children) && ((s = -1 < ["string", "number"].indexOf(_typeof(s)) ? [s] : _toConsumableArray(s)).__top__ = i), DirectiveHOC(e, addScopeId(React.createElement(e.type, c, o(s, r2, a)), e.scopeId))) : r2([e], null, n2);
}
function pureInterceptProps() {
  return 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
}
function setChildKey(e, t2, r2) {
  return !((e = e instanceof Array && 1 === e.length ? e[0] : e) instanceof Array) && null == e.key && 1 < t2.length && ((e = _objectSpread2({}, e)).key = "_key_".concat(r2)), e;
}
function getDistinguishReactOrVue(e) {
  var l2 = e.reactComponents, p2 = e.domTags, e = e.division, _ = void 0 === e || e;
  return function a(i, u2, c) {
    var s;
    return i && i.forEach ? (s = [], i.forEach(function(e2, t2) {
      if (e2 && e2.type !== Comment) {
        if (null == (o = e2.type) || !o.originReactComponent)
          return e2.$$typeof || "string" == typeof e2 || "number" == typeof e2 ? void s.push(e2) : isTextOwner(e2) ? void ("" !== e2.children.trim() && s.push(e2.children.trim())) : void (e2.type && (addScopeId(o = setChildKey(takeVueDomInReact(e2, p2, u2, _, a, c, i.__top__), i, t2), e2.scopeId), s.push(o)));
        var r2, n2, o = e2.type.originReactComponent;
        addScopeId(r2 = setChildKey(r2 = "all" === (l2 = "all" === l2 || l2 instanceof Array ? l2 : [l2]) || -1 < l2.indexOf(o) ? (e2.__top__ = i.__top__, r2 = getChildInfo(e2, "_key_".concat(t2), u2, a, c), n2 = resolveRef(e2), e2.children && (e2.children.__top__ = i.__top__), DirectiveHOC(e2, React.createElement(o, _objectSpread2(_objectSpread2(_objectSpread2({}, pureInterceptProps(r2, e2, o)), e2.__extraData || {}), n2 ? { ref: n2 } : {})))) : isTextOwner(e2) ? e2.text : takeVueDomInReact(e2, p2, u2, _, a, c), i, t2), e2.scopeId), s.push(r2);
      }
    }), 1 === s.length ? s[0] : s) : i;
  };
}
var NoWrapFunction = getDistinguishReactOrVue({ reactComponents: "all", domTags: "all" });
function applyPureReactInVue(e, t2) {
  return transformer(e, { combinedOption: _objectSpread2({ pureTransformer: true, defaultSlotsFormatter: NoWrapFunction, defaultPropsFormatter: function(t3, o, a) {
    var r2 = {};
    return Object.keys(t3).forEach(function(e2) {
      var n2 = t3[e2];
      n2 && (n2.vueFunction ? (r2[e2] = function() {
        for (var e3 = arguments.length, t4 = new Array(e3), r3 = 0; r3 < e3; r3++)
          t4[r3] = arguments[r3];
        return NoWrapFunction(n2.vueFunction.apply(this, t4), o, a);
      }, Object.defineProperty(r2[e2], "length", { get: function() {
        return n2.vueFunction.length;
      } })) : n2.vueSlot && (r2[e2] = NoWrapFunction(n2.vueSlot, o, a)));
    }), Object.assign(t3, r2);
  } }, t2) });
}
getDistinguishReactOrVue({ reactComponents: "all", domTags: "all" });
var _excluded$5 = ["ref", "children", "v-slots"];
function getChildInfo$1(e, t2, o, a, i) {
  var e = e.props || {}, r2 = (e.ref, e.children), n2 = e["v-slots"], u2 = void 0 === n2 ? {} : n2, n2 = _objectWithoutProperties(e, _excluded$5), c = (r2 && ("object" !== _typeof(r2) || r2 instanceof Array || r2.$$typeof ? u2.default = r2 : u2 = r2), null), e = (Object.keys(u2 || {}).forEach(function(e2) {
    var n3 = u2[e2];
    (c = c || {})[e2] = function() {
      if ("function" == typeof n3) {
        for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
          t3[r3] = arguments[r3];
        n3 = n3.apply(this, t3);
      }
      return a(n3, o, i);
    };
  }), {}), r2 = formatStyle(n2.style), s = Array.from(new Set(formatClass(n2.className))).join(" ");
  return 0 < Object.keys(r2).length && (e.style = r2), "" !== s && (e.class = s), Object.assign(n2, _objectSpread2({}, e)), delete n2.className, { props: n2 = parseVModel(n2), slots: c };
}
function resolveRef$1(t2) {
  var e = t2.ref;
  if (e)
    return "object" === _typeof(e) ? function(e2) {
      t2.ref.current = e2;
    } : "function" == typeof e ? e : void 0;
}
var _excluded$6 = ["style", "class", "children"];
function takeReactDomInVue(e, t2, r2, n2, o, a) {
  var i, u2, c, s;
  return "all" === t2 || t2 instanceof Array || (t2 = t2 ? [t2] : []), e.type === reactExports.Fragment ? o(null == (i = e.props) ? void 0 : i.children, r2) : "string" == typeof e.type && ("all" === t2 || -1 < t2.indexOf(e.type)) ? (i = resolveRef$1(e), s = (t2 = e.props || {}).style, c = t2.class, u2 = t2.children, t2 = _objectWithoutProperties(t2, _excluded$6), c = Array.from(new Set(formatClass(c))).join(" "), s = formatStyle(s), t2 = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, t2), 0 === Object.keys(s).length ? {} : { style: s }), c ? { className: c } : {}), i ? { ref: i } : {}), 0 === Object.keys(t2).length && (t2 = null), (s = u2) && ((s = -1 < ["string", "number"].indexOf(_typeof(s)) ? [s] : s instanceof Array ? _toConsumableArray(s) : _objectSpread2({}, s)).__top__ = a), h(e.type, t2, o(s, r2))) : r2([e], null, n2);
}
function getDistinguishReactOrVue$1(e) {
  var c = e.vueComponents, s = e.domTags, e = e.division, l2 = void 0 === e || e;
  return function o(a, i) {
    if (null == a)
      return a;
    a instanceof Array || (a = [a]);
    var u2 = [];
    return a.forEach(function(e2, t2) {
      if ((null == (r2 = e2.type) || !r2.originVueComponent) && e2.type !== VueContainer)
        return e2.__v_isVNode || "string" == typeof e2 || "number" == typeof e2 ? void u2.push(e2) : void (e2.type && (r2 = takeReactDomInVue(e2, s, i, l2, o, a.__top__), u2.push(r2)));
      var r2 = e2.type.originVueComponent;
      if (e2.type === VueContainer) {
        if (!e2.props.component)
          return void u2.push(e2.props.node);
        r2 = e2.props.component, e2 = _objectSpread2({}, e2);
        var n2 = _objectSpread2({}, e2.props);
        delete n2.component, e2.props = n2;
      }
      r2 = "all" === (c = "all" === c || c instanceof Array ? c : [c]) || -1 < c.indexOf(r2) ? ((e2 = _objectSpread2({}, e2)).__top__ = a.__top__, t2 = (n2 = getChildInfo$1(e2, "_key_".concat(t2), i, o)).props, n2 = n2.slots, resolveRef$1(e2), e2.children && (e2.children.__top__ = a.__top__), h(r2, _objectSpread2({}, t2), n2)) : takeReactDomInVue(e2, s, i, l2, o), u2.push(r2);
    }), 1 === (u2 = u2.flat(1 / 0)).length ? u2[0] : u2;
  };
}
getDistinguishReactOrVue$1({ vueComponents: "all", domTags: "all" });
getDistinguishReactOrVue$1({ reactComponents: "all", domTags: "all" });
var _excluded$7 = ["children"];
function createCrossingProviderForReactInVue$1(e) {
  var r2 = reactExports.createContext({});
  return [function() {
    return reactExports.useContext(r2);
  }, applyPureReactInVue(function(e2) {
    var t2 = e2.children, e2 = _objectWithoutProperties(e2, _excluded$7);
    return reactExports.createElement(r2.Provider, { value: _objectSpread2({}, e2) }, t2);
  }, { useInjectPropsFromWrapper: e }), r2];
}
new _default();
const _hoisted_1$n = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$m = /* @__PURE__ */ createBaseVNode("path", { d: "M3 12a9 9 0 1 0 18 0 9 9 0 1 0-18 0M12 17v.01" }, null, -1);
const _hoisted_4$l = /* @__PURE__ */ createBaseVNode("path", { d: "M12 13.5a1.5 1.5 0 0 1 1-1.5 2.6 2.6 0 1 0-3-4" }, null, -1);
const _hoisted_5$9 = [
  _hoisted_2$m,
  _hoisted_3$m,
  _hoisted_4$l
];
function render$e(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$n, _hoisted_5$9);
}
const HelpIcon = { render: render$e };
const _hoisted_1$m = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$l = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$l = /* @__PURE__ */ createBaseVNode("path", { d: "M5 4h4l2 5-2.5 1.5a11 11 0 0 0 5 5L15 13l5 2v4a2 2 0 0 1-2 2A16 16 0 0 1 3 6a2 2 0 0 1 2-2" }, null, -1);
const _hoisted_4$k = [
  _hoisted_2$l,
  _hoisted_3$l
];
function render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_4$k);
}
const PhoneIcon = { render: render$d };
const _hoisted_1$l = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$k = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$k = /* @__PURE__ */ createBaseVNode("path", { d: "M3 7a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z" }, null, -1);
const _hoisted_4$j = /* @__PURE__ */ createBaseVNode("path", { d: "m3 7 9 6 9-6" }, null, -1);
const _hoisted_5$8 = [
  _hoisted_2$k,
  _hoisted_3$k,
  _hoisted_4$j
];
function render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_5$8);
}
const MailIcon = { render: render$c };
const _hoisted_1$k = { class: "twc-relative" };
const _hoisted_2$j = ["title"];
const _hoisted_3$j = { class: "twc-text-xl twc-font-bold twc-text-center" };
const _hoisted_4$i = { class: "twc-py-3 twc-whitespace-normal" };
const _hoisted_5$7 = { class: "twc-flex twc-gap-2 twc-mb-1" };
const _hoisted_6$3 = ["href"];
const _hoisted_7$3 = ["href"];
const _hoisted_8$3 = { class: "twc-flex twc-gap-2 twc-underline" };
const _hoisted_9$2 = ["href"];
const _hoisted_10$1 = ["href"];
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "SupportComponent",
  props: {
    t: { type: Function },
    coreStore: {}
  },
  setup(__props) {
    const promoData = config.promo;
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$k, [
        createBaseVNode("a", {
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.coreStore.togglePopup(unref(Popup).SUPPORT)),
          title: _ctx.t("support.hint")
        }, [
          createVNode(unref(HelpIcon), { class: "twc-stroke-stone-700" })
        ], 8, _hoisted_2$j),
        createBaseVNode("div", {
          class: normalizeClass([{ "twc-hidden": !_ctx.coreStore.openedPopups[unref(Popup).SUPPORT] }, "twc-absolute twc-left-10 -twc-bottom-2 twc-bg-white twc-p-2 twc-rounded-lg twc-drop-shadow-md twc-w-80 twc-text-stone-700"])
        }, [
          createBaseVNode("h1", _hoisted_3$j, toDisplayString$1(_ctx.t("support.title")), 1),
          createBaseVNode("p", _hoisted_4$i, toDisplayString$1(_ctx.t("support.text")), 1),
          createBaseVNode("div", _hoisted_5$7, [
            createBaseVNode("a", {
              href: `tel:${unref(promoData).tel.data}`
            }, [
              createVNode(unref(PhoneIcon), { class: "twc-stroke-stone-700" })
            ], 8, _hoisted_6$3),
            createBaseVNode("a", {
              href: `tel:${unref(promoData).tel.data}`
            }, toDisplayString$1(unref(promoData).tel.title), 9, _hoisted_7$3)
          ]),
          createBaseVNode("div", _hoisted_8$3, [
            createBaseVNode("a", {
              href: `mailto:${unref(promoData).mail}`
            }, [
              createVNode(unref(MailIcon), { class: "twc-stroke-stone-700" })
            ], 8, _hoisted_9$2),
            createBaseVNode("a", {
              href: `mailto:${unref(promoData).mail}`
            }, toDisplayString$1(unref(promoData).mail), 9, _hoisted_10$1)
          ])
        ], 2)
      ]);
    };
  }
});
const _hoisted_1$j = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$i = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$i = /* @__PURE__ */ createBaseVNode("path", { d: "M3 10a7 7 0 1 0 14 0 7 7 0 1 0-14 0M21 21l-6-6" }, null, -1);
const _hoisted_4$h = [
  _hoisted_2$i,
  _hoisted_3$i
];
function render$b(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$j, _hoisted_4$h);
}
const SearchIcon = { render: render$b };
const _hoisted_1$i = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("path", { d: "M4 11a8.1 8.1 0 0 1 15.5-2m.5-4v4h-4M20 13a8.1 8.1 0 0 1-15.5 2M4 19v-4h4" }, null, -1);
const _hoisted_3$h = [
  _hoisted_2$h
];
function render$a(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$i, _hoisted_3$h);
}
const RefreshIcon = { render: render$a };
const _hoisted_1$h = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  class: "icon icon-tabler icon-tabler-square-rounded-x"
};
const _hoisted_2$g = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$g = /* @__PURE__ */ createBaseVNode("path", { d: "m10 10 4 4m0-4-4 4M12 3c7.2 0 9 1.8 9 9s-1.8 9-9 9-9-1.8-9-9 1.8-9 9-9z" }, null, -1);
const _hoisted_4$g = [
  _hoisted_2$g,
  _hoisted_3$g
];
function render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$h, _hoisted_4$g);
}
const RoundedCloseIcon = { render: render$9 };
const _hoisted_1$g = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "15",
  height: "15",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  viewBox: "0 0 24 24"
};
const _hoisted_2$f = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$f = /* @__PURE__ */ createBaseVNode("path", { d: "M3 21h18M5 21V7l8-4v18M19 21V11l-6-4M9 9v.01M9 12v.01M9 15v.01M9 18v.01" }, null, -1);
const _hoisted_4$f = [
  _hoisted_2$f,
  _hoisted_3$f
];
function render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$g, _hoisted_4$f);
}
const OfficePriceSvg = { render: render$8 };
const _hoisted_1$f = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "15",
  height: "15",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  viewBox: "0 0 24 24"
};
const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$e = /* @__PURE__ */ createBaseVNode("path", { d: "M13 12v.01M3 21h18M5 21V5a2 2 0 0 1 2-2h6m4 10.5V21M21 7h-7m3-3-3 3 3 3" }, null, -1);
const _hoisted_4$e = [
  _hoisted_2$e,
  _hoisted_3$e
];
function render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$f, _hoisted_4$e);
}
const DeliveryPriceSvg = { render: render$7 };
const _hoisted_1$e = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "15",
  height: "15",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  viewBox: "0 0 24 24"
};
const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$d = /* @__PURE__ */ createBaseVNode("path", { d: "M12 18.5 9 17l-6 3V7l6-3 6 3 6-3v7.5M9 4v13M15 7v5.5M21.121 20.121a3 3 0 1 0-4.242 0c.418.419 1.125 1.045 2.121 1.879 1.051-.89 1.759-1.516 2.121-1.879zM19 18v.01" }, null, -1);
const _hoisted_4$d = [
  _hoisted_2$d,
  _hoisted_3$d
];
function render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$e, _hoisted_4$d);
}
const GeoMapIcon = { render: render$6 };
const _hoisted_1$d = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$c = /* @__PURE__ */ createBaseVNode("path", { d: "M9 11a3 3 0 1 0 6 0 3 3 0 0 0-6 0" }, null, -1);
const _hoisted_4$c = /* @__PURE__ */ createBaseVNode("path", { d: "M17.657 16.657 13.414 20.9a2 2 0 0 1-2.827 0l-4.244-4.243a8 8 0 1 1 11.314 0z" }, null, -1);
const _hoisted_5$6 = [
  _hoisted_2$c,
  _hoisted_3$c,
  _hoisted_4$c
];
function render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_5$6);
}
const MapPinIcon = { render: render$5 };
const _hoisted_1$c = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$b = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$b = /* @__PURE__ */ createBaseVNode("path", { d: "M3 12a9 9 0 1 0 18 0 9 9 0 0 0-18 0" }, null, -1);
const _hoisted_4$b = /* @__PURE__ */ createBaseVNode("path", { d: "M12 7v5l3 3" }, null, -1);
const _hoisted_5$5 = [
  _hoisted_2$b,
  _hoisted_3$b,
  _hoisted_4$b
];
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_5$5);
}
const ClockIcon = { render: render$4 };
/*!
* perfect-scrollbar v1.5.3
* Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
* Licensed under MIT
*/
function get(element) {
  return getComputedStyle(element);
}
function set(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === "number") {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches(element, query) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element, query);
}
function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(
    element.children,
    function(child) {
      return matches(child, selector);
    }
  );
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(x2) {
      return "ps__thumb-" + x2;
    },
    rail: function(x2) {
      return "ps__rail-" + x2;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(x2) {
      return "ps--active-" + x2;
    },
    scrolling: function(x2) {
      return "ps--scrolling-" + x2;
    }
  }
};
var scrollingClassTimeout = { x: null, y: null };
function addScrollingClass(i, x2) {
  var classList = i.element.classList;
  var className = cls.state.scrolling(x2);
  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x2]);
  } else {
    classList.add(className);
  }
}
function removeScrollingClass(i, x2) {
  scrollingClassTimeout[x2] = setTimeout(
    function() {
      return i.isAlive && i.element.classList.remove(cls.state.scrolling(x2));
    },
    i.settings.scrollingThreshold
  );
}
function setScrollingClassInstantly(i, x2) {
  addScrollingClass(i, x2);
  removeScrollingClass(i, x2);
}
var EventElement = function EventElement2(element) {
  this.element = element;
  this.handlers = {};
};
var prototypeAccessors = { isEmpty: { configurable: true } };
EventElement.prototype.bind = function bind(eventName, handler) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler);
  this.element.addEventListener(eventName, handler, false);
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
    if (target && handler !== target) {
      return true;
    }
    this$1$1.element.removeEventListener(eventName, handler, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name in this.handlers) {
    this.unbind(name);
  }
};
prototypeAccessors.isEmpty.get = function() {
  var this$1$1 = this;
  return Object.keys(this.handlers).every(
    function(key) {
      return this$1$1.handlers[key].length === 0;
    }
  );
};
Object.defineProperties(EventElement.prototype, prototypeAccessors);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element) {
  var ee2 = this.eventElements.filter(function(ee3) {
    return ee3.element === element;
  })[0];
  if (!ee2) {
    ee2 = new EventElement(element);
    this.eventElements.push(ee2);
  }
  return ee2;
};
EventManager.prototype.bind = function bind2(element, eventName, handler) {
  this.eventElement(element).bind(eventName, handler);
};
EventManager.prototype.unbind = function unbind2(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  ee2.unbind(eventName, handler);
  if (ee2.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee2), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e) {
    return e.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once(element, eventName, handler) {
  var ee2 = this.eventElement(element);
  var onceHandler = function(evt) {
    ee2.unbind(eventName, onceHandler);
    handler(evt);
  };
  ee2.bind(eventName, onceHandler);
};
function createEvent(name) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i, axis, diff, useScrollingClass, forceFireReachEvent) {
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  } else if (axis === "left") {
    fields = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i, diff, fields, useScrollingClass, forceFireReachEvent);
}
function processScrollDiff$1(i, diff, ref2, useScrollingClass, forceFireReachEvent) {
  var contentHeight = ref2[0];
  var containerHeight = ref2[1];
  var scrollTop = ref2[2];
  var y2 = ref2[3];
  var up = ref2[4];
  var down = ref2[5];
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var element = i.element;
  i.reach[y2] = null;
  if (element[scrollTop] < 1) {
    i.reach[y2] = "start";
  }
  if (element[scrollTop] > i[contentHeight] - i[containerHeight] - 1) {
    i.reach[y2] = "end";
  }
  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-" + y2));
    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i, y2);
    }
  }
  if (i.reach[y2] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-" + y2 + "-reach-" + i.reach[y2]));
  }
}
function toInt(x2) {
  return parseInt(x2, 10) || 0;
}
function isEditable(el2) {
  return matches(el2, "input,[contenteditable]") || matches(el2, "select,[contenteditable]") || matches(el2, "textarea,[contenteditable]") || matches(el2, "button,[contenteditable]");
}
function outerWidth(element) {
  var styles = get(element);
  return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
};
function updateGeometry(i) {
  var element = i.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i.containerWidth = Math.round(rect.width);
  i.containerHeight = Math.round(rect.height);
  i.contentWidth = element.scrollWidth;
  i.contentHeight = element.scrollHeight;
  if (!element.contains(i.scrollbarXRail)) {
    queryChildren(element, cls.element.rail("x")).forEach(
      function(el2) {
        return remove(el2);
      }
    );
    element.appendChild(i.scrollbarXRail);
  }
  if (!element.contains(i.scrollbarYRail)) {
    queryChildren(element, cls.element.rail("y")).forEach(
      function(el2) {
        return remove(el2);
      }
    );
    element.appendChild(i.scrollbarYRail);
  }
  if (!i.settings.suppressScrollX && i.containerWidth + i.settings.scrollXMarginOffset < i.contentWidth) {
    i.scrollbarXActive = true;
    i.railXWidth = i.containerWidth - i.railXMarginWidth;
    i.railXRatio = i.containerWidth / i.railXWidth;
    i.scrollbarXWidth = getThumbSize(
      i,
      toInt(i.railXWidth * i.containerWidth / i.contentWidth)
    );
    i.scrollbarXLeft = toInt(
      (i.negativeScrollAdjustment + element.scrollLeft) * (i.railXWidth - i.scrollbarXWidth) / (i.contentWidth - i.containerWidth)
    );
  } else {
    i.scrollbarXActive = false;
  }
  if (!i.settings.suppressScrollY && i.containerHeight + i.settings.scrollYMarginOffset < i.contentHeight) {
    i.scrollbarYActive = true;
    i.railYHeight = i.containerHeight - i.railYMarginHeight;
    i.railYRatio = i.containerHeight / i.railYHeight;
    i.scrollbarYHeight = getThumbSize(
      i,
      toInt(i.railYHeight * i.containerHeight / i.contentHeight)
    );
    i.scrollbarYTop = toInt(
      roundedScrollTop * (i.railYHeight - i.scrollbarYHeight) / (i.contentHeight - i.containerHeight)
    );
  } else {
    i.scrollbarYActive = false;
  }
  if (i.scrollbarXLeft >= i.railXWidth - i.scrollbarXWidth) {
    i.scrollbarXLeft = i.railXWidth - i.scrollbarXWidth;
  }
  if (i.scrollbarYTop >= i.railYHeight - i.scrollbarYHeight) {
    i.scrollbarYTop = i.railYHeight - i.scrollbarYHeight;
  }
  updateCss(element, i);
  if (i.scrollbarXActive) {
    element.classList.add(cls.state.active("x"));
  } else {
    element.classList.remove(cls.state.active("x"));
    i.scrollbarXWidth = 0;
    i.scrollbarXLeft = 0;
    element.scrollLeft = i.isRtl === true ? i.contentWidth : 0;
  }
  if (i.scrollbarYActive) {
    element.classList.add(cls.state.active("y"));
  } else {
    element.classList.remove(cls.state.active("y"));
    i.scrollbarYHeight = 0;
    i.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}
function getThumbSize(i, thumbSize) {
  if (i.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i.settings.minScrollbarLength);
  }
  if (i.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element, i) {
  var xRailOffset = { width: i.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);
  if (i.isRtl) {
    xRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth - i.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i.scrollbarXTop + roundedScrollTop;
  }
  set(i.scrollbarXRail, xRailOffset);
  var yRailOffset = { top: roundedScrollTop, height: i.railYHeight };
  if (i.isScrollbarYUsingRight) {
    if (i.isRtl) {
      yRailOffset.right = i.contentWidth - (i.negativeScrollAdjustment + element.scrollLeft) - i.scrollbarYRight - i.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i.isRtl) {
      yRailOffset.left = i.negativeScrollAdjustment + element.scrollLeft + i.containerWidth * 2 - i.contentWidth - i.scrollbarYLeft - i.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i.scrollbarYLeft + element.scrollLeft;
    }
  }
  set(i.scrollbarYRail, yRailOffset);
  set(i.scrollbarX, {
    left: i.scrollbarXLeft,
    width: i.scrollbarXWidth - i.railBorderXWidth
  });
  set(i.scrollbarY, {
    top: i.scrollbarYTop,
    height: i.scrollbarYHeight - i.railBorderYWidth
  });
}
function clickRail(i) {
  i.element;
  i.event.bind(i.scrollbarY, "mousedown", function(e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarYRail, "mousedown", function(e) {
    var positionTop = e.pageY - window.pageYOffset - i.scrollbarYRail.getBoundingClientRect().top;
    var direction = positionTop > i.scrollbarYTop ? 1 : -1;
    i.element.scrollTop += direction * i.containerHeight;
    updateGeometry(i);
    e.stopPropagation();
  });
  i.event.bind(i.scrollbarX, "mousedown", function(e) {
    return e.stopPropagation();
  });
  i.event.bind(i.scrollbarXRail, "mousedown", function(e) {
    var positionLeft = e.pageX - window.pageXOffset - i.scrollbarXRail.getBoundingClientRect().left;
    var direction = positionLeft > i.scrollbarXLeft ? 1 : -1;
    i.element.scrollLeft += direction * i.containerWidth;
    updateGeometry(i);
    e.stopPropagation();
  });
}
function dragThumb(i) {
  bindMouseScrollHandler(i, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
  bindMouseScrollHandler(i, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function bindMouseScrollHandler(i, ref2) {
  var containerHeight = ref2[0];
  var contentHeight = ref2[1];
  var pageY = ref2[2];
  var railYHeight = ref2[3];
  var scrollbarY = ref2[4];
  var scrollbarYHeight = ref2[5];
  var scrollTop = ref2[6];
  var y2 = ref2[7];
  var scrollbarYRail = ref2[8];
  var element = i.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy = null;
  function mouseMoveHandler(e) {
    if (e.touches && e.touches[0]) {
      e[pageY] = e.touches[0].pageY;
    }
    element[scrollTop] = startingScrollTop + scrollBy * (e[pageY] - startingMousePageY);
    addScrollingClass(i, y2);
    updateGeometry(i);
    e.stopPropagation();
    if (e.type.startsWith("touch") && e.changedTouches.length > 1) {
      e.preventDefault();
    }
  }
  function mouseUpHandler() {
    removeScrollingClass(i, y2);
    i[scrollbarYRail].classList.remove(cls.state.clicking);
    i.event.unbind(i.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e, touchMode) {
    startingScrollTop = element[scrollTop];
    if (touchMode && e.touches) {
      e[pageY] = e.touches[0].pageY;
    }
    startingMousePageY = e[pageY];
    scrollBy = (i[contentHeight] - i[containerHeight]) / (i[railYHeight] - i[scrollbarYHeight]);
    if (!touchMode) {
      i.event.bind(i.ownerDocument, "mousemove", mouseMoveHandler);
      i.event.once(i.ownerDocument, "mouseup", mouseUpHandler);
      e.preventDefault();
    } else {
      i.event.bind(i.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i[scrollbarYRail].classList.add(cls.state.clicking);
    e.stopPropagation();
  }
  i.event.bind(i[scrollbarY], "mousedown", function(e) {
    bindMoves(e);
  });
  i.event.bind(i[scrollbarY], "touchstart", function(e) {
    bindMoves(e, true);
  });
}
function keyboard(i) {
  var element = i.element;
  var elementHovered = function() {
    return matches(element, ":hover");
  };
  var scrollbarFocused = function() {
    return matches(i.scrollbarX, ":focus") || matches(i.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i.contentHeight - i.containerHeight && deltaY < 0) {
        return !i.settings.wheelPropagation;
      }
    }
    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i.contentWidth - i.containerWidth && deltaX > 0) {
        return !i.settings.wheelPropagation;
      }
    }
    return true;
  }
  i.event.bind(i.ownerDocument, "keydown", function(e) {
    if (e.isDefaultPrevented && e.isDefaultPrevented() || e.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e.which) {
      case 37:
        if (e.metaKey) {
          deltaX = -i.contentWidth;
        } else if (e.altKey) {
          deltaX = -i.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e.metaKey) {
          deltaY = i.contentHeight;
        } else if (e.altKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e.metaKey) {
          deltaX = i.contentWidth;
        } else if (e.altKey) {
          deltaX = i.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e.metaKey) {
          deltaY = -i.contentHeight;
        } else if (e.altKey) {
          deltaY = -i.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e.shiftKey) {
          deltaY = i.containerHeight;
        } else {
          deltaY = -i.containerHeight;
        }
        break;
      case 33:
        deltaY = i.containerHeight;
        break;
      case 34:
        deltaY = -i.containerHeight;
        break;
      case 36:
        deltaY = i.contentHeight;
        break;
      case 35:
        deltaY = -i.contentHeight;
        break;
      default:
        return;
    }
    if (i.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e.preventDefault();
    }
  });
}
function wheel(i) {
  var element = i.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e) {
    var deltaX = e.deltaX;
    var deltaY = -1 * e.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e.wheelDeltaX / 6;
      deltaY = e.wheelDeltaY / 6;
    }
    if (e.deltaMode && e.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e.wheelDelta;
    }
    if (e.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element.querySelector("select:focus")) {
      return true;
    }
    if (!element.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style2 = get(cursor);
      if (deltaY && style2.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style2.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e) {
    var ref2 = getDeltaFromEvent(e);
    var deltaX = ref2[0];
    var deltaY = ref2[1];
    if (shouldBeConsumedByChild(e.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i.settings.useBothWheelAxes) {
      element.scrollTop -= deltaY * i.settings.wheelSpeed;
      element.scrollLeft += deltaX * i.settings.wheelSpeed;
    } else if (i.scrollbarYActive && !i.scrollbarXActive) {
      if (deltaY) {
        element.scrollTop -= deltaY * i.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i.scrollbarXActive && !i.scrollbarYActive) {
      if (deltaX) {
        element.scrollLeft += deltaX * i.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e.ctrlKey) {
      e.stopPropagation();
      e.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i.event.bind(element, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i.event.bind(element, "mousewheel", mousewheelHandler);
  }
}
function touch(i) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element = i.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (magnitudeY > magnitudeX) {
      if (deltaY < 0 && scrollTop === i.contentHeight - i.containerHeight || deltaY > 0 && scrollTop === 0) {
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      if (deltaX < 0 && scrollLeft === i.contentWidth - i.containerWidth || deltaX > 0 && scrollLeft === 0) {
        return true;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i);
  }
  var startOffset = {};
  var startTime = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e) {
    if (e.targetTouches) {
      return e.targetTouches[0];
    } else {
      return e;
    }
  }
  function shouldHandle(e) {
    if (e.pointerType && e.pointerType === "pen" && e.buttons === 0) {
      return false;
    }
    if (e.targetTouches && e.targetTouches.length === 1) {
      return true;
    }
    if (e.pointerType && e.pointerType !== "mouse" && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e) {
    if (!shouldHandle(e)) {
      return;
    }
    var touch2 = getTouch(e);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime = (/* @__PURE__ */ new Date()).getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style2 = get(cursor);
      if (deltaY && style2.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style2.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function touchMove(e) {
    if (shouldHandle(e)) {
      var touch2 = getTouch(e);
      var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      var timeGap = currentTime - startTime;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime = currentTime;
      }
      if (shouldPrevent(differenceX, differenceY)) {
        e.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        if (!i.element) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i.event.bind(element, "touchstart", touchStart);
    i.event.bind(element, "touchmove", touchMove);
    i.event.bind(element, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i.event.bind(element, "pointerdown", touchStart);
      i.event.bind(element, "pointermove", touchMove);
      i.event.bind(element, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i.event.bind(element, "MSPointerDown", touchStart);
      i.event.bind(element, "MSPointerMove", touchMove);
      i.event.bind(element, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch
};
var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
  var this$1$1 = this;
  if (userSettings === void 0)
    userSettings = {};
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if (!element || !element.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element;
  element.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key in userSettings) {
    this.settings[key] = userSettings[key];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function() {
    return element.classList.add(cls.state.focus);
  };
  var blur = function() {
    return element.classList.remove(cls.state.focus);
  };
  this.isRtl = get(element).direction === "rtl";
  if (this.isRtl === true) {
    element.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  set(this.scrollbarXRail, { display: "block" });
  this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set(this.scrollbarXRail, { display: "" });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set(this.scrollbarYRail, { display: "block" });
  this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set(this.scrollbarYRail, { display: "" });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1$1);
  });
  this.lastScrollTop = Math.floor(element.scrollTop);
  this.lastScrollLeft = element.scrollLeft;
  this.event.bind(this.element, "scroll", function(e) {
    return this$1$1.onScroll(e);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update() {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set(this.scrollbarXRail, { display: "block" });
  set(this.scrollbarYRail, { display: "block" });
  this.railXMarginWidth = toInt(get(this.scrollbarXRail).marginLeft) + toInt(get(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt(get(this.scrollbarYRail).marginTop) + toInt(get(this.scrollbarYRail).marginBottom);
  set(this.scrollbarXRail, { display: "none" });
  set(this.scrollbarYRail, { display: "none" });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true);
  processScrollDiff(this, "left", 0, false, true);
  set(this.scrollbarXRail, { display: "" });
  set(this.scrollbarYRail, { display: "" });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  );
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name) {
    return !name.match(/^ps([-_].+|)$/);
  }).join(" ");
};
var YandexGeocoderKind = /* @__PURE__ */ ((YandexGeocoderKind2) => {
  YandexGeocoderKind2["OTHER"] = "other";
  YandexGeocoderKind2["ENTRANCE"] = "entrance";
  YandexGeocoderKind2["AIRPORT"] = "airport";
  YandexGeocoderKind2["VEGETATION"] = "vegetation";
  YandexGeocoderKind2["ROUTE"] = "route";
  YandexGeocoderKind2["STATION"] = "station";
  YandexGeocoderKind2["RAILWAY"] = "railway_station";
  YandexGeocoderKind2["HYDRO"] = "hydro";
  YandexGeocoderKind2["REGION"] = "region";
  YandexGeocoderKind2["COUNTRY"] = "country";
  YandexGeocoderKind2["PROVINCE"] = "province";
  YandexGeocoderKind2["AREA"] = "area";
  YandexGeocoderKind2["LOCALITY"] = "locality";
  YandexGeocoderKind2["DISTRICT"] = "district";
  YandexGeocoderKind2["METRO"] = "metro";
  YandexGeocoderKind2["STREET"] = "street";
  YandexGeocoderKind2["HOUSE"] = "house";
  return YandexGeocoderKind2;
})(YandexGeocoderKind || {});
var YandexGeocoderPrecision = /* @__PURE__ */ ((YandexGeocoderPrecision2) => {
  YandexGeocoderPrecision2["OTHER"] = "other";
  YandexGeocoderPrecision2["STREET"] = "street";
  YandexGeocoderPrecision2["RANGE"] = "range";
  YandexGeocoderPrecision2["NEAR"] = "near";
  YandexGeocoderPrecision2["NUMBER"] = "number";
  YandexGeocoderPrecision2["EXACT"] = "exact";
  return YandexGeocoderPrecision2;
})(YandexGeocoderPrecision || {});
const _hoisted_1$b = { key: 0 };
const _hoisted_2$a = { class: "twc-text-xs twc-text-stone-500" };
const _hoisted_3$a = { key: 0 };
const _hoisted_4$a = { class: "twc-w-36" };
const _hoisted_5$4 = { class: "twc-text-xs twc-flex twc-gap-2 twc-text-stone-700" };
const _hoisted_6$2 = { class: "twc-w-24" };
const _hoisted_7$2 = {
  key: 1,
  class: "twc-flex twc-justify-center"
};
const _hoisted_8$2 = {
  key: 2,
  class: "twc-text-center twc-text-red-600"
};
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "TariffInfo",
  props: {
    tariffs: {},
    searchStore: {},
    t: { type: Function },
    coreStore: {}
  },
  setup(__props) {
    const { tariffs, searchStore, t: t2, coreStore } = __props;
    const scrollable = ref();
    const showTariffs = computed(
      () => Array.isArray(coreStore.params.goods) && coreStore.params.goods.length && coreStore.params.from !== null
    );
    onMounted(() => {
      nextTick(() => {
        if (showTariffs.value) {
          if (coreStore.debug)
            console.debug("[CDEK] Initializing Tariffs Prefect Scrollbar");
          new PerfectScrollbar(scrollable.value);
        }
      });
    });
    const selectTariff = (tariff) => {
      coreStore.$patch((state) => {
        state.selectedTariff = tariff;
        state.hasChanged = true;
      });
    };
    const selectPoint = () => {
      coreStore.$patch((state) => {
        state.selected = true;
        state.hasChanged = true;
      });
    };
    return (_ctx, _cache) => {
      return _ctx.coreStore.params.sender || _ctx.coreStore.params.canChoose && !showTariffs.value ? (openBlock(), createElementBlock("div", _hoisted_1$b, [
        createVNode(unref(Do), {
          small: true,
          theme: _ctx.coreStore.selected ? "secondary" : "primary",
          onClick: selectPoint
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString$1(_ctx.t(_ctx.coreStore.selected ? "tariffs.selected" : "tariffs.select")), 1)
          ]),
          _: 1
        }, 8, ["theme"])
      ])) : showTariffs.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", _hoisted_2$a, toDisplayString$1(_ctx.t("tariffs.title")), 1),
        createBaseVNode("div", {
          ref_key: "scrollable",
          ref: scrollable,
          class: "twc-overflow-hidden twc-max-h-60 twc-relative twc-whitespace-normal"
        }, [
          _ctx.tariffs.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$a, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.tariffs, (tariff) => {
              return openBlock(), createElementBlock("div", {
                key: tariff.tariff_code,
                class: "twc-text-sm twc-flex twc-gap-1 twc-items-center twc-mb-3"
              }, [
                createBaseVNode("div", _hoisted_4$a, [
                  createBaseVNode("p", null, toDisplayString$1(tariff.tariff_name), 1),
                  createBaseVNode("div", _hoisted_5$4, [
                    createBaseVNode("div", null, [
                      tariff.period_min !== tariff.period_max ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        createTextVNode(toDisplayString$1(tariff.period_min) + " - ", 1)
                      ], 64)) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString$1(tariff.period_max) + " " + toDisplayString$1(_ctx.t("tariffs.days", tariff.period_max)), 1)
                    ]),
                    createBaseVNode("div", null, toDisplayString$1(tariff.delivery_sum) + " " + toDisplayString$1(_ctx.coreStore.params.currency), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_6$2, [
                  _ctx.coreStore.params.canChoose ? (openBlock(), createBlock(unref(Do), {
                    key: 0,
                    small: true,
                    theme: _ctx.coreStore.selectedTariff !== null && _ctx.coreStore.selectedTariff.tariff_code === tariff.tariff_code ? "secondary" : "primary",
                    onClick: ($event) => selectTariff(tariff)
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString$1(_ctx.t(
                        _ctx.coreStore.selectedTariff !== null && _ctx.coreStore.selectedTariff.tariff_code === tariff.tariff_code ? "tariffs.selected" : "tariffs.select"
                      )), 1)
                    ]),
                    _: 2
                  }, 1032, ["theme", "onClick"])) : createCommentVNode("", true)
                ])
              ]);
            }), 128))
          ])) : _ctx.searchStore.loading ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
            createBaseVNode("div", null, [
              createVNode(unref(RefreshIcon), { class: "twc-animate-spin twc-stroke-stone-700" })
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_8$2, toDisplayString$1(_ctx.t("office.priceError")), 1))
        ], 512)
      ], 64)) : createCommentVNode("", true);
    };
  }
});
var OfficeType = /* @__PURE__ */ ((OfficeType2) => {
  OfficeType2["ALL"] = "ALL";
  OfficeType2["OFFICE"] = "PVZ";
  OfficeType2["PICKUP"] = "POSTAMAT";
  return OfficeType2;
})(OfficeType || {});
var Lang = /* @__PURE__ */ ((Lang2) => {
  Lang2["RUS"] = "rus";
  Lang2["ENG"] = "eng";
  return Lang2;
})(Lang || {});
const Currency = {
  RUB: 1,
  KZT: 2,
  USD: 3,
  EUR: 4,
  GBP: 5,
  CNY: 6,
  BYN: 7,
  UAH: 8,
  KGS: 9,
  AMD: 10,
  TRY: 11,
  THB: 12,
  KRW: 13,
  AED: 14,
  UZS: 15,
  MNT: 16,
  PLN: 17,
  AZN: 18,
  GEL: 19,
  JPY: 55
};
var CdekDeliveryType = /* @__PURE__ */ ((CdekDeliveryType2) => {
  CdekDeliveryType2[CdekDeliveryType2["DOOR_DOOR"] = 1] = "DOOR_DOOR";
  CdekDeliveryType2[CdekDeliveryType2["DOOR_OFFICE"] = 2] = "DOOR_OFFICE";
  CdekDeliveryType2[CdekDeliveryType2["OFFICE_DOOR"] = 3] = "OFFICE_DOOR";
  CdekDeliveryType2[CdekDeliveryType2["OFFICE_OFFICE"] = 4] = "OFFICE_OFFICE";
  CdekDeliveryType2[CdekDeliveryType2["DOOR_PICKUP"] = 6] = "DOOR_PICKUP";
  CdekDeliveryType2[CdekDeliveryType2["OFFICE_PICKUP"] = 7] = "OFFICE_PICKUP";
  CdekDeliveryType2[CdekDeliveryType2["PICKUP_DOOR"] = 8] = "PICKUP_DOOR";
  CdekDeliveryType2[CdekDeliveryType2["PICKUP_OFFICE"] = 9] = "PICKUP_OFFICE";
  CdekDeliveryType2[CdekDeliveryType2["PICKUP_PICKUP"] = 10] = "PICKUP_PICKUP";
  return CdekDeliveryType2;
})(CdekDeliveryType || {});
const _hoisted_1$a = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$9 = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$9 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zM9 4v16" }, null, -1);
const _hoisted_4$9 = /* @__PURE__ */ createBaseVNode("path", { d: "m15 10-2 2 2 2" }, null, -1);
const _hoisted_5$3 = [
  _hoisted_2$9,
  _hoisted_3$9,
  _hoisted_4$9
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_5$3);
}
const CollapseIcon = { render: render$3 };
const _hoisted_1$9 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$8 = /* @__PURE__ */ createBaseVNode("path", { d: "M4 6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zM9 4v16" }, null, -1);
const _hoisted_4$8 = /* @__PURE__ */ createBaseVNode("path", { d: "m14 10 2 2-2 2" }, null, -1);
const _hoisted_5$2 = [
  _hoisted_2$8,
  _hoisted_3$8,
  _hoisted_4$8
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_5$2);
}
const ExpandIcon = { render: render$2 };
const _hoisted_1$8 = { class: "twc-absolute twc-left-0 twc-top-12" };
const _hoisted_2$7 = {
  key: 0,
  class: "twc-bg-white twc-p-2 twc-rounded-lg twc-drop-shadow-md twc-w-70 twc-text-sm twc-z-15 twc-whitespace-normal twc-w-30"
};
const _hoisted_3$7 = { class: "twc-text-xl twc-font-bold twc-text-center twc-mx-6 twc-mb-2 twc-w-52" };
const _hoisted_4$7 = { class: "twc-mb-1" };
const _hoisted_5$1 = { class: "twc-text-xs twc-text-stone-500" };
const _hoisted_6$1 = { class: "twc-mb-1" };
const _hoisted_7$1 = { class: "twc-text-xs twc-text-stone-500" };
const _hoisted_8$1 = { class: "twc-mb-1" };
const _hoisted_9$1 = { class: "twc-text-xs twc-text-stone-500" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "OfficeExtendedInfo",
  props: {
    t: { type: Function },
    mapStore: {},
    coreStore: {},
    searchStore: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$8, [
        _ctx.coreStore.openedPopups[unref(Popup).INFO] ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
          createBaseVNode("h1", _hoisted_3$7, toDisplayString$1(_ctx.mapStore.exactOffice.name), 1),
          createBaseVNode("div", _hoisted_4$7, [
            createBaseVNode("div", _hoisted_5$1, toDisplayString$1(_ctx.t("office.code")), 1),
            createBaseVNode("span", null, toDisplayString$1(_ctx.mapStore.exactOffice.code), 1)
          ]),
          createBaseVNode("div", _hoisted_6$1, [
            createBaseVNode("div", _hoisted_7$1, toDisplayString$1(_ctx.t("office.address")), 1),
            createBaseVNode("span", null, toDisplayString$1(_ctx.mapStore.exactOffice.address), 1)
          ]),
          createBaseVNode("div", _hoisted_8$1, [
            createBaseVNode("div", _hoisted_9$1, toDisplayString$1(_ctx.t("office.workingTime")), 1),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.mapStore.exactOffice.work_time.split(", "), (time, index) => {
              return openBlock(), createElementBlock("div", { key: index }, toDisplayString$1(time), 1);
            }), 128))
          ]),
          createVNode(_sfc_main$8, {
            "core-store": _ctx.coreStore,
            "search-store": _ctx.searchStore,
            t: _ctx.t,
            tariffs: _ctx.mapStore.exactOffice.type === unref(OfficeType).OFFICE ? _ctx.coreStore.tariffs.office : _ctx.coreStore.tariffs.pickup
          }, null, 8, ["core-store", "search-store", "t", "tariffs"])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["twc-bg-white twc-absolute twc-top-0 twc-drop-shadow-md twc-rounded-lg twc-p-2 twc-cursor-pointer", { "-twc-right-12": _ctx.coreStore.openedPopups[unref(Popup).INFO] }]),
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.coreStore.togglePopup(unref(Popup).INFO))
        }, [
          _ctx.coreStore.openedPopups[unref(Popup).INFO] ? (openBlock(), createBlock(unref(CollapseIcon), {
            key: 0,
            class: "twc-stroke-stone-700"
          })) : (openBlock(), createBlock(unref(ExpandIcon), {
            key: 1,
            class: "twc-stroke-stone-700"
          }))
        ], 2)
      ]);
    };
  }
});
const _hoisted_1$7 = { class: "twc-absolute twc-left-0 twc-top-12" };
const _hoisted_2$6 = {
  key: 0,
  class: "twc-bg-white twc-p-2 twc-rounded-lg twc-drop-shadow-md twc-w-70 twc-text-sm twc-z-15 twc-whitespace-normal twc-w-30"
};
const _hoisted_3$6 = { class: "twc-text-xl twc-font-bold twc-text-center twc-mb-2 twc-w-52" };
const _hoisted_4$6 = {
  key: 1,
  class: "twc-text-red-600 twc-text-center"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "DoorExtendedInfo",
  props: {
    t: { type: Function },
    mapStore: {},
    coreStore: {},
    searchStore: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        _ctx.coreStore.openedPopups[unref(Popup).INFO] ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
          createBaseVNode("h1", _hoisted_3$6, toDisplayString$1(_ctx.mapStore.pointInfo.formatted), 1),
          _ctx.mapStore.pointInfo.precision === unref(YandexGeocoderPrecision).EXACT || _ctx.mapStore.pointInfo.precision === unref(YandexGeocoderPrecision).NUMBER ? (openBlock(), createBlock(_sfc_main$8, {
            key: 0,
            "core-store": _ctx.coreStore,
            "search-store": _ctx.searchStore,
            t: _ctx.t,
            tariffs: _ctx.coreStore.tariffs.door
          }, null, 8, ["core-store", "search-store", "t", "tariffs"])) : (openBlock(), createElementBlock("div", _hoisted_4$6, toDisplayString$1(_ctx.t("tariffs.needExactAddress")), 1))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["twc-bg-white twc-absolute twc-top-0 twc-drop-shadow-md twc-rounded-lg twc-p-2 twc-cursor-pointer", { "-twc-right-12": _ctx.coreStore.openedPopups[unref(Popup).INFO] }]),
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.coreStore.togglePopup(unref(Popup).INFO))
        }, [
          _ctx.coreStore.openedPopups[unref(Popup).INFO] ? (openBlock(), createBlock(unref(CollapseIcon), {
            key: 0,
            class: "twc-stroke-stone-700"
          })) : (openBlock(), createBlock(unref(ExpandIcon), {
            key: 1,
            class: "twc-stroke-stone-700"
          }))
        ], 2)
      ]);
    };
  }
});
const _hoisted_1$6 = { class: "twc-w-64 twc-text-stone-700 twc-flex twc-gap-2 twc-relative" };
const _hoisted_2$5 = { class: "twc-w-full" };
const _hoisted_3$5 = ["placeholder", "title", "value"];
const _hoisted_4$5 = { key: 0 };
const _hoisted_5 = ["title"];
const _hoisted_6 = { key: 0 };
const _hoisted_7 = { key: 1 };
const _hoisted_8 = ["onClick"];
const _hoisted_9 = {
  key: 0,
  class: "twc-flex twc-gap-1 twc-items-center twc-text-stone-500 twc-py-1"
};
const _hoisted_10 = {
  key: 1,
  class: "twc-flex twc-gap-1 twc-items-center twc-text-stone-500 twc-py-1"
};
const _hoisted_11 = ["onClick"];
const _hoisted_12 = { class: "twc-flex twc-gap-1 twc-items-center twc-text-stone-500 twc-py-1" };
const _hoisted_13 = { class: "twc-text-xl twc-font-bold twc-text-center" };
const _hoisted_14 = ["onClick"];
const _hoisted_15 = { class: "twc-ml-7" };
const _hoisted_16 = { class: "twc-font-bold" };
const _hoisted_17 = { class: "twc-flex twc-gap-1" };
const _hoisted_18 = { class: "twc-mb-1" };
const _hoisted_19 = { class: "twc-flex twc-gap-1" };
const _hoisted_20 = { class: "twc-mb-1" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "SearchComponent",
  props: {
    searchStore: {},
    t: { type: Function },
    mapStore: {},
    coreStore: {}
  },
  setup(__props) {
    const { searchStore, mapStore, coreStore, t: t2 } = __props;
    const scrollableSearch = ref();
    const scrollableMenu = ref();
    onMounted(() => {
      nextTick(() => {
        if (coreStore.debug)
          console.debug("[CDEK] Initializing Prefect Scrollbar");
        new PerfectScrollbar(scrollableSearch.value);
        new PerfectScrollbar(scrollableMenu.value);
      });
    });
    const changeLocation = (location) => {
      searchStore.$patch({ value: "" });
      mapStore.$patch({ location });
    };
    const selectSearchPoint = (point) => {
      let zoom = YandexMapZoomVariants.GENERAL;
      switch (point.kind) {
        case YandexGeocoderKind.ENTRANCE:
        case YandexGeocoderKind.HOUSE:
          zoom = YandexMapZoomVariants.HOME;
          break;
        case YandexGeocoderKind.STREET:
          zoom = YandexMapZoomVariants.STREET;
          break;
      }
      changeLocation({ center: point.position, zoom });
      if (coreStore.debug)
        console.debug("[CDEK] Selected geopoint from search", point);
      if (point.kind === YandexGeocoderKind.ENTRANCE || point.kind === YandexGeocoderKind.HOUSE) {
        if (coreStore.debug)
          console.debug("[CDEK] Switching delivery mode to door");
        coreStore.$patch({ mode: DeliveryMode.DOOR, selectedTariff: null, selected: false });
        mapStore.$patch({ pointInfo: point, exactPoint: point.position });
        coreStore.togglePopup(Popup.INFO);
      }
    };
    const selectOffice = (point) => {
      if (coreStore.debug)
        console.debug("[CDEK] Selected office from search", point);
      if (coreStore.debug)
        console.debug("[CDEK] Switching delivery mode to office");
      changeLocation({ center: point.location, zoom: YandexMapZoomVariants.HOME });
      coreStore.$patch({ mode: DeliveryMode.OFFICE, selectedTariff: null, selected: false });
      coreStore.closePopups();
      mapStore.$patch({ exactOffice: point });
      coreStore.togglePopup(Popup.INFO);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$6, [
          createBaseVNode("div", null, [
            _ctx.searchStore.loading ? (openBlock(), createBlock(unref(RefreshIcon), {
              key: 0,
              class: "twc-animate-spin twc-stroke-stone-700"
            })) : (openBlock(), createBlock(unref(SearchIcon), {
              key: 1,
              class: "twc-stroke-stone-700"
            }))
          ]),
          createBaseVNode("div", _hoisted_2$5, [
            createBaseVNode("input", {
              placeholder: _ctx.t("search.title"),
              title: _ctx.t("search.title"),
              value: _ctx.searchStore.value,
              class: "twc-w-full twc-outline-none twc-border-0 twc-shadow-none twc-leading-6 twc-min-h-min",
              type: "text",
              onInput: _cache[0] || (_cache[0] = ($event) => _ctx.searchStore.$patch({ value: $event.target.value }))
            }, null, 40, _hoisted_3$5)
          ]),
          _ctx.searchStore.value ? (openBlock(), createElementBlock("div", _hoisted_4$5, [
            createBaseVNode("a", {
              title: _ctx.t("search.clear"),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.searchStore.$patch({ value: "" }))
            }, [
              createVNode(unref(RoundedCloseIcon), { class: "twc-stroke-stone-700" })
            ], 8, _hoisted_5)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", {
          ref_key: "scrollableSearch",
          ref: scrollableSearch,
          class: normalizeClass([{ "twc-hidden": !_ctx.searchStore.value }, "twc-w-full twc-overflow-hidden twc-max-h-72 twc-bg-white twc-absolute twc-left-0 twc-top-12 twc-p-2 twc-rounded-md twc-shadow-md twc-text-xs twc-whitespace-normal twc-z-20"])
        }, [
          _ctx.searchStore.loading ? (openBlock(), createElementBlock("div", _hoisted_6, toDisplayString$1(_ctx.t("search.loading")), 1)) : _ctx.searchStore.searchResults.length === 0 && _ctx.mapStore.searchedOffices.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_7, toDisplayString$1(_ctx.t("search.notFound")), 1)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.searchStore.searchResults, (result, key) => {
            return openBlock(), createElementBlock("div", {
              key,
              class: "twc-border-t-2 first:twc-border-t-0 twc-mt-1 first:twc-mt-0",
              onClick: ($event) => selectSearchPoint(result)
            }, [
              [unref(YandexGeocoderKind).HOUSE, unref(YandexGeocoderKind).ENTRANCE].indexOf(result.kind) !== -1 ? (openBlock(), createElementBlock("span", _hoisted_9, [
                createVNode(unref(DeliveryPriceSvg)),
                createBaseVNode("span", null, toDisplayString$1(_ctx.t("search.door")), 1)
              ])) : (openBlock(), createElementBlock("span", _hoisted_10, [
                createVNode(unref(GeoMapIcon)),
                createBaseVNode("span", null, toDisplayString$1(_ctx.t("search.region")), 1)
              ])),
              createBaseVNode("span", null, toDisplayString$1(result.formatted), 1)
            ], 8, _hoisted_8);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.mapStore.searchedOffices, (office) => {
            return openBlock(), createElementBlock("div", {
              key: office.code,
              class: "twc-border-t-2 first:twc-border-t-0 twc-mt-1 first:twc-mt-0",
              onClick: ($event) => selectOffice(office)
            }, [
              createBaseVNode("span", _hoisted_12, [
                createVNode(unref(OfficePriceSvg)),
                createBaseVNode("span", null, toDisplayString$1(_ctx.t("search.office")), 1)
              ]),
              createBaseVNode("span", null, toDisplayString$1(office.code) + " - " + toDisplayString$1(office.name), 1)
            ], 8, _hoisted_11);
          }), 128))
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass([{ "twc-hidden": !_ctx.coreStore.openedPopups[unref(Popup).MENU] }, "twc-absolute twc-left-0 twc-top-12 twc-bg-white twc-p-2 twc-rounded-lg twc-drop-shadow-md twc-w-80 twc-text-sm twc-z-10"])
        }, [
          createBaseVNode("h1", _hoisted_13, toDisplayString$1(_ctx.t("menu.title")), 1),
          createBaseVNode("div", {
            ref_key: "scrollableMenu",
            ref: scrollableMenu,
            class: "twc-h-96 twc-mt-2 twc-break-words twc-overflow-hidden twc-relative twc-whitespace-normal"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.mapStore.filteredOffices, (office) => {
              return openBlock(), createElementBlock("div", {
                key: office.code,
                class: "twc-border-b-2 twc-border-stone-200 twc-pb-1",
                onClick: ($event) => selectOffice(office)
              }, [
                createBaseVNode("h5", _hoisted_15, [
                  createTextVNode(" [" + toDisplayString$1(office.code) + "] ", 1),
                  createBaseVNode("a", _hoisted_16, toDisplayString$1(office.name), 1)
                ]),
                createBaseVNode("div", _hoisted_17, [
                  createVNode(unref(MapPinIcon), { class: "twc-stroke-stone-700 twc-relative twc-top-[2px]" }),
                  createBaseVNode("p", _hoisted_18, toDisplayString$1(office.address), 1)
                ]),
                createBaseVNode("div", _hoisted_19, [
                  createVNode(unref(ClockIcon), { class: "twc-stroke-stone-700 twc-relative twc-top-[2px]" }),
                  createBaseVNode("div", _hoisted_20, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(office.work_time.split(", "), (time, index) => {
                      return openBlock(), createElementBlock("p", { key: index }, toDisplayString$1(time), 1);
                    }), 128))
                  ])
                ])
              ], 8, _hoisted_14);
            }), 128))
          ], 512)
        ], 2),
        _ctx.mapStore.exactOffice !== null && _ctx.coreStore.mode === unref(DeliveryMode).OFFICE ? (openBlock(), createBlock(_sfc_main$7, {
          key: 0,
          "core-store": _ctx.coreStore,
          t: _ctx.t,
          "map-store": _ctx.mapStore,
          "search-store": _ctx.searchStore
        }, null, 8, ["core-store", "t", "map-store", "search-store"])) : createCommentVNode("", true),
        _ctx.mapStore.pointInfo !== null && _ctx.coreStore.mode === unref(DeliveryMode).DOOR ? (openBlock(), createBlock(_sfc_main$6, {
          key: 1,
          "core-store": _ctx.coreStore,
          t: _ctx.t,
          "map-store": _ctx.mapStore,
          "search-store": _ctx.searchStore
        }, null, 8, ["core-store", "t", "map-store", "search-store"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const perfectScrollbar_css_vue_type_style_index_0_src_true_lang = "";
/*!
* shared v9.3.0-beta.14
* (c) 2023 kazuya kawaguchi
* Released under the MIT License.
*/
const inBrowser = typeof window !== "undefined";
const makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$1 = (val) => typeof val === "number" && isFinite(val);
const isDate$2 = (val) => toTypeString(val) === "[object Date]";
const isRegExp$1 = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject = (val) => isPlainObject$1(val) && Object.keys(val).length === 0;
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const assign = Object.assign;
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty$1.call(obj, key);
}
const isArray$1 = Array.isArray;
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isBoolean$1 = (val) => typeof val === "boolean";
const isObject$2 = (val) => val !== null && typeof val === "object";
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const toDisplayString = (val) => {
  return val == null ? "" : isArray$1(val) || isPlainObject$1(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
/*!
* message-compiler v9.3.0-beta.14
* (c) 2023 kazuya kawaguchi
* Released under the MIT License.
*/
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 15
};
function createCompileError(code2, loc, options = {}) {
  const { domain, messages, args } = options;
  const msg = code2;
  const error = new SyntaxError(String(msg));
  error.code = code2;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index2) => _buf[index2] === CHAR_CR && _buf[index2 + 1] === CHAR_LF;
  const isLF = (index2) => _buf[index2] === CHAR_LF;
  const isPS = (index2) => _buf[index2] === CHAR_PS;
  const isLS = (index2) => _buf[index2] === CHAR_LS;
  const isLineEnd = (index2) => isCRLF(index2) || isLF(index2) || isPS(index2) || isLS(index2);
  const index = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$1 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code2, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = createLocation(ctx.startLoc, pos);
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN$1,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch2) {
    if (scnr.currentChar() === ch2) {
      scnr.next();
      return ch2;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch2) {
    if (ch2 === EOF) {
      return false;
    }
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 === 95;
  }
  function isNumberStart(ch2) {
    if (ch2 === EOF) {
      return false;
    }
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch2 = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch2);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn = () => {
      const ch2 = scnr.currentPeek();
      if (ch2 === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch2 === "@" || ch2 === "%" || ch2 === "|" || ch2 === ":" || ch2 === "." || ch2 === CHAR_SP || !ch2) {
        return false;
      } else if (ch2 === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isIdentifierStart(ch2);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch2 = scnr.currentPeek();
      if (ch2 === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch2 === "@" || !ch2) {
        return prev === "%" ? true : hasSpace;
      } else if (ch2 === "%") {
        scnr.peek();
        return fn(hasSpace, "%", true);
      } else if (ch2 === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch2 === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP, detectModulo);
      } else if (ch2 === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch2 = scnr.currentChar();
    if (ch2 === EOF) {
      return EOF;
    }
    if (fn(ch2)) {
      scnr.next();
      return ch2;
    }
    return null;
  }
  function takeIdentifierChar(scnr) {
    const closure = (ch2) => {
      const cc2 = ch2.charCodeAt(0);
      return cc2 >= 97 && cc2 <= 122 || // a-z
      cc2 >= 65 && cc2 <= 90 || // A-Z
      cc2 >= 48 && cc2 <= 57 || // 0-9
      cc2 === 95 || // _
      cc2 === 36;
    };
    return takeChar(scnr, closure);
  }
  function takeDigit(scnr) {
    const closure = (ch2) => {
      const cc2 = ch2.charCodeAt(0);
      return cc2 >= 48 && cc2 <= 57;
    };
    return takeChar(scnr, closure);
  }
  function takeHexDigit(scnr) {
    const closure = (ch2) => {
      const cc2 = ch2.charCodeAt(0);
      return cc2 >= 48 && cc2 <= 57 || // 0-9
      cc2 >= 65 && cc2 <= 70 || // A-F
      cc2 >= 97 && cc2 <= 102;
    };
    return takeChar(scnr, closure);
  }
  function getDigits(scnr) {
    let ch2 = "";
    let num = "";
    while (ch2 = takeDigit(scnr)) {
      num += ch2;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch2 = scnr.currentChar();
    if (ch2 !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch2 = scnr.currentChar();
      if (ch2 === "{" || ch2 === "}" || ch2 === "@" || ch2 === "|" || !ch2) {
        break;
      } else if (ch2 === "%") {
        if (isTextStart(scnr)) {
          buf += ch2;
          scnr.next();
        } else {
          break;
        }
      } else if (ch2 === CHAR_SP || ch2 === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch2;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch2;
          scnr.next();
        }
      } else {
        buf += ch2;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch2 = "";
    let name = "";
    while (ch2 = takeIdentifierChar(scnr)) {
      name += ch2;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch2 = "";
    let literal = "";
    const fn = (x2) => x2 !== LITERAL_DELIMITER && x2 !== CHAR_LF;
    while (ch2 = takeChar(scnr, fn)) {
      if (ch2 === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch2;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch2}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch2, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch2, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch2);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch2 = takeHexDigit(scnr);
      if (!ch2) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch2;
    }
    return `\\${unicode}${sequence}`;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch2 = "";
    let identifiers = "";
    const closure = (ch3) => ch3 !== "{" && ch3 !== "}" && ch3 !== CHAR_SP && ch3 !== CHAR_LF;
    while (ch2 = takeChar(scnr, closure)) {
      identifiers += ch2;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch2 = "";
    let name = "";
    while (ch2 = takeIdentifierChar(scnr)) {
      name += ch2;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn = (detect = false, buf) => {
      const ch2 = scnr.currentChar();
      if (ch2 === "{" || ch2 === "%" || ch2 === "@" || ch2 === "|" || !ch2) {
        return buf;
      } else if (ch2 === CHAR_SP) {
        return buf;
      } else if (ch2 === CHAR_LF) {
        buf += ch2;
        scnr.next();
        return fn(detect, buf);
      } else {
        buf += ch2;
        scnr.next();
        return fn(true, buf);
      }
    };
    return fn(false, "");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default:
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch2 = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch2 === CHAR_LF || ch2 === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch2) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch2 === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location = options.location !== false;
  const { onError } = options;
  function emitError(tokenzer, code2, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = createLocation(start, end);
      const err = createCompileError(code2, loc, {
        domain: ERROR_DOMAIN,
        args
      });
      onError(err);
    }
  }
  function startNode(type, offset, loc) {
    const node = {
      type,
      start: offset,
      end: offset
    };
    if (location) {
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type) {
    node.end = offset;
    if (type) {
      node.type = type;
    }
    if (location && node.loc) {
      node.loc.end = pos;
    }
  }
  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default:
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || ""));
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8:
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer2) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer2);
  }
}
function traverseNode(node, transformer2) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer2);
      transformer2.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer2);
      break;
    case 6:
      const linked = node;
      traverseNode(linked.key, transformer2);
      transformer2.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer2.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    case 5:
      transformer2.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer2.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer2.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer2.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer2 = createTransformer(ast);
  transformer2.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer2);
  const context = transformer2.context();
  ast.helpers = Array.from(context.helpers);
}
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const _context = {
    source: ast.loc.source,
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  const context = () => _context;
  function push(code2, node) {
    _context.code += code2;
  }
  function _newline(n2, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n2) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
  }
}
const generate = (ast, options = {}) => {
  const mode = isString$1(options.mode) ? options.mode : "normal";
  const filename = isString$1(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${helpers.map((s) => `${s}: _${s}`).join(", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  const { code: code2, map: map2 } = generator.context();
  return {
    ast,
    code: code2,
    map: map2 ? map2.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile(source, options = {}) {
  const assignedOptions = assign({}, options);
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  transform(ast, assignedOptions);
  return generate(ast, assignedOptions);
}
/*!
 * devtools-if v9.3.0-beta.14
 * (c) 2023 kazuya kawaguchi
 * Released under the MIT License.
 */
const IntlifyDevToolsHooks = {
  I18nInit: "i18n:init",
  FunctionTranslate: "function:translate"
};
/*!
* core-base v9.3.0-beta.14
* (c) 2023 kazuya kawaguchi
* Released under the MIT License.
*/
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch2) {
  if (ch2 === void 0 || ch2 === null) {
    return "o";
  }
  const code2 = ch2.charCodeAt(0);
  switch (code2) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch2;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index++;
    c = path[index];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$2(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$2(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : values.join("");
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index = isNumber$1(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber$1(options.named.count) || isNumber$1(options.named.n)) ? isNumber$1(options.named.count) ? options.named.count : isNumber$1(options.named.n) ? options.named.n : index : index;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$2(options.pluralRules) && isString$1(locale) && isFunction$1(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$2(options.pluralRules) && isString$1(locale) && isFunction$1(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index) => _list[index];
  const _named = options.named || {};
  isNumber$1(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction$1(options.messages) ? options.messages(key) : isObject$2(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject$1(options.processor) && isFunction$1(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject$1(options.processor) && isFunction$1(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject$1(options.processor) && isString$1(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$2(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString$1(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString$1(arg2)) {
        type2 = arg2 || type2;
      }
    }
    let msg = message(key)(ctx);
    if (type2 === "vnode" && isArray$1(msg) && modifier) {
      msg = msg[0];
    }
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize
  };
  return ctx;
}
let devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n2, version2, meta) {
  devtools && devtools.emit(IntlifyDevToolsHooks.I18nInit, {
    timestamp: Date.now(),
    i18n: i18n2,
    version: version2,
    meta
  });
}
const translateDevTools = /* @__PURE__ */ createDevToolsHook(IntlifyDevToolsHooks.FunctionTranslate);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray$1(fallback) ? fallback : isObject$2(fallback) ? Object.keys(fallback) : isString$1(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString$1(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray$1(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults2 = isArray$1(fallback) || !isPlainObject$1(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString$1(defaults2) ? [defaults2] : defaults2;
    if (isArray$1(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean$1(follow); i++) {
    const locale = block[i];
    if (isString$1(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray$1(blocks) || isPlainObject$1(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const VERSION$3 = "9.3.0-beta.14";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString$1(val) ? val.toUpperCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString$1(val) ? val.toLowerCase() : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString$1(val) ? capitalize(val) : type === "vnode" && isObject$2(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
let _additionalMeta = null;
const setAdditionalMeta = (meta) => {
  _additionalMeta = meta;
};
const getAdditionalMeta = () => _additionalMeta;
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const version2 = isString$1(options.version) ? options.version : VERSION$3;
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || isString$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const messages = isPlainObject$1(options.messages) ? options.messages : { [locale]: {} };
  const datetimeFormats = isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [locale]: {} };
  const numberFormats = isPlainObject$1(options.numberFormats) ? options.numberFormats : { [locale]: {} };
  const modifiers = assign({}, options.modifiers || {}, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || {};
  const missing = isFunction$1(options.missing) ? options.missing : null;
  const missingWarn = isBoolean$1(options.missingWarn) || isRegExp$1(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean$1(options.fallbackWarn) || isRegExp$1(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject$1(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean$1(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction$1(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction$1(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction$1(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$2(options.fallbackContext) ? options.fallbackContext : void 0;
  const onWarn = isFunction$1(options.onWarn) ? options.onWarn : warn;
  const internalOptions = options;
  const __datetimeFormatters = isObject$2(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$2(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$2(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (__INTLIFY_PROD_DEVTOOLS__) {
    initI18nDevTools(context, version2, __meta);
  }
  return context;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString$1(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
const defaultOnCacheKey = (source) => source;
let compileCache = /* @__PURE__ */ Object.create(null);
function compileToFunction(source, options = {}) {
  {
    const onCacheKey = options.onCacheKey || defaultOnCacheKey;
    const key = onCacheKey(source);
    const cached = compileCache[key];
    if (cached) {
      return cached;
    }
    let occurred = false;
    const onError = options.onError || defaultOnError;
    options.onError = (err) => {
      occurred = true;
      onError(err);
    };
    const { code: code2 } = baseCompile(source, options);
    const msg = new Function(`return ${code2}`)();
    return !occurred ? compileCache[key] = msg : msg;
  }
}
let code$1 = CompileErrorCodes.__EXTEND_POINT__;
const inc$1 = () => ++code$1;
const CoreErrorCodes = {
  INVALID_ARGUMENT: code$1,
  INVALID_DATE_ARGUMENT: inc$1(),
  INVALID_ISO_DATE_ARGUMENT: inc$1(),
  __EXTEND_POINT__: inc$1()
  // 18
};
function createCoreError(code2) {
  return createCompileError(code2, null, void 0);
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction$1(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean$1(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean$1(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean$1(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString$1(options.default) || isBoolean$1(options.default) ? !isBoolean$1(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || {}
  ];
  let format = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString$1(format) || isMessageFunction(format))) {
    if (enableDefaultMsg) {
      format = defaultMsgOrKey;
      cacheBaseKey = format;
    }
  }
  if (!resolvedMessage && (!(isString$1(format) || isMessageFunction(format)) || !isString$1(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const errorDetector = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format) ? compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) : format;
  if (occurred) {
    return format;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const payloads = {
      timestamp: Date.now(),
      key: isString$1(key) ? key : isMessageFunction(format) ? format.key : "",
      locale: targetLocale || (isMessageFunction(format) ? format.locale : ""),
      format: isString$1(format) ? format : isMessageFunction(format) ? format.source : "",
      message: ret
    };
    payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray$1(options.list)) {
    options.list = options.list.map((item) => isString$1(item) ? escapeHtml(item) : item);
  } else if (isObject$2(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString$1(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = {};
  let targetLocale;
  let format = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages[targetLocale] || {};
    if ((format = resolveValue2(message, key)) === null) {
      format = message[key];
    }
    if (isString$1(format) || isFunction$1(format))
      break;
    const missingRet = handleMissing(
      context,
      // eslint-disable-line @typescript-eslint/no-explicit-any
      key,
      targetLocale,
      missingWarn,
      type
    );
    if (missingRet !== key) {
      format = missingRet;
    }
  }
  return [format, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format, cacheBaseKey, errorDetector) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format)) {
    const msg2 = format;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format, getCompileOptions(context, targetLocale, cacheBaseKey, format, warnHtmlMessage, errorDetector));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = {};
  if (!isString$1(arg1) && !isNumber$1(arg1) && !isMessageFunction(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$1(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$1(arg2)) {
    options.plural = arg2;
  } else if (isString$1(arg2)) {
    options.default = arg2;
  } else if (isPlainObject$1(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray$1(arg2)) {
    options.list = arg2;
  }
  if (isNumber$1(arg3)) {
    options.plural = arg3;
  } else if (isString$1(arg3)) {
    options.default = arg3;
  } else if (isPlainObject$1(arg3)) {
    assign(options, arg3);
  }
  return [key, options];
}
function getCompileOptions(context, locale, key, source, warnHtmlMessage, errorDetector) {
  return {
    warnHtmlMessage,
    onError: (err) => {
      errorDetector && errorDetector(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString$1(val)) {
      let occurred = false;
      const errorDetector = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, errorDetector);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber$1(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean$1(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean$1(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format = datetimeFormat[key];
    if (isPlainObject$1(format))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  let value;
  if (isString$1(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate$2(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber$1(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format) {
  const context = ctx;
  for (const key in format) {
    const id2 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number$1(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean$1(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean$1(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = isString$1(options.locale) ? options.locale : context.locale;
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString$1(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format = numberFormat[key];
    if (isPlainObject$1(format))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject$1(format) || !isString$1(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign({}, format, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = {};
  let overrides = {};
  if (!isNumber$1(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString$1(arg2)) {
    options.key = arg2;
  } else if (isPlainObject$1(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString$1(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject$1(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject$1(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format) {
  const context = ctx;
  for (const key in format) {
    const id2 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
{
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
/*!
 * vue-i18n v9.3.0-beta.14
 * (c) 2023 kazuya kawaguchi
 * Released under the MIT License.
 */
const VERSION$2 = "9.3.0-beta.14";
function initFeatureFlags() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
let code = CompileErrorCodes.__EXTEND_POINT__;
const inc = () => ++code;
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code,
  // legacy module errors
  INVALID_ARGUMENT: inc(),
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc(),
  NOT_INSLALLED: inc(),
  NOT_AVAILABLE_IN_LEGACY_MODE: inc(),
  // directive module errors
  REQUIRED_VALUE: inc(),
  INVALID_VALUE: inc(),
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc(),
  NOT_INSLALLED_WITH_PROVIDE: inc(),
  // unexpected error
  UNEXPECTED_ERROR: inc(),
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc(),
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc(),
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc(),
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc(),
  // for enhancement
  __EXTEND_POINT__: inc()
  // 29
};
function createI18nError(code2, ...args) {
  return createCompileError(code2, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOption = /* @__PURE__ */ makeSymbol("__injectWithOption");
function handleFlatJson(obj) {
  if (!isObject$2(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$2(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = {};
        }
        currentObj = currentObj[subKeys[i]];
      }
      currentObj[subKeys[lastIndex]] = obj[key];
      delete obj[key];
      if (isObject$2(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject$1(messages) ? messages : isArray$1(__i18n) ? {} : { [locale]: {} };
  if (isArray$1(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || {};
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString$1(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
const isNotObjectOrIsArray = (val) => !isObject$2(val) || isArray$1(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
  for (const key in src) {
    if (hasOwn(src, key)) {
      if (isNotObjectOrIsArray(src[key]) || isNotObjectOrIsArray(des[key])) {
        des[key] = src[key];
      } else {
        deepCopy(src[key], des[key]);
      }
    }
  }
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(global2, options, componentOptions) {
  let messages = isObject$2(options.messages) ? options.messages : {};
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(global2.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      global2.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$2(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          global2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$2(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          global2.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
const DEVTOOLS_META = "__INTLIFY_META__";
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
const getMetaInfo = () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root } = options;
  const _isGlobal = __root === void 0;
  let _inheritLocale = isBoolean$1(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean$1(options.missingWarn) || isRegExp$1(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean$1(options.fallbackWarn) || isRegExp$1(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean$1(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction$1(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction$1(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean$1(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION$2,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject$1(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject$1(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction$1(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    if (__INTLIFY_PROD_DEVTOOLS__) {
      try {
        setAdditionalMeta(getMetaInfo());
        if (!_isGlobal) {
          _context.fallbackContext = __root ? getFallbackContext() : void 0;
        }
        ret = fn(_context);
      } finally {
        setAdditionalMeta(null);
        if (!_isGlobal) {
          _context.fallbackContext = void 0;
        }
      }
    } else {
      ret = fn(_context);
    }
    if (isNumber$1(ret) && ret === NOT_REOSLVED) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t2(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root2) => Reflect.apply(root2.t, root2, [...args]), (key) => key, (val) => isString$1(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$2(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t2(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root2) => Reflect.apply(root2.d, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function n2(...args) {
    return wrapWithDeps((context) => Reflect.apply(number$1, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root2) => Reflect.apply(root2.n, root2, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString$1(val));
  }
  function normalize(values) {
    return values.map((val) => isString$1(val) || isNumber$1(val) || isBoolean$1(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root2) => root2[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray$1(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number$1, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root2) => root2[NumberPartsSymbol](...args),
      () => [],
      (val) => isString$1(val) || isArray$1(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root2) => root2[DatetimePartsSymbol](...args),
      () => [],
      (val) => isString$1(val) || isArray$1(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te2(key, locale2) {
    const targetLocale = isString$1(locale2) ? locale2 : _locale.value;
    const message = getLocaleMessage(targetLocale);
    return _context.messageResolver(message, key) !== null;
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format) {
    _datetimeFormats.value[locale2] = format;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format);
  }
  function mergeDateTimeFormat(locale2, format) {
    _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format) {
    _numberFormats.value[locale2] = format;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format);
  }
  function mergeNumberFormat(locale2, format) {
    _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te2;
    composer.tm = tm;
    composer.d = d;
    composer.n = n2;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOption] = options.__injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString$1(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString$1(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction$1(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean$1(options.silentTranslationWarn) || isRegExp$1(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean$1(options.silentFallbackWarn) || isRegExp$1(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean$1(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject$1(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString$1(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean$1(options.sync) ? options.sync : true;
  let messages = options.messages;
  if (isPlainObject$1(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean$1(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean$1(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean$1(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean$1(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        return true;
      },
      set preserveDirectiveContent(val) {
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isArray$1(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isArray$1(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString$1(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString$1(arg2)) {
          options2.locale = arg2;
        } else if (isNumber$1(arg2)) {
          options2.plural = arg2;
        } else if (isArray$1(arg2)) {
          list = arg2;
        } else if (isPlainObject$1(arg2)) {
          named = arg2;
        }
        if (isString$1(arg3)) {
          options2.locale = arg3;
        } else if (isArray$1(arg3)) {
          list = arg3;
        } else if (isPlainObject$1(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format) {
        composer.setDateTimeFormat(locale, format);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format) {
        composer.mergeDateTimeFormat(locale, format);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format) {
        composer.setNumberFormat(locale, format);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format) {
        composer.mergeNumberFormat(locale, format);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        return -1;
      },
      // for internal
      __onComponentInstanceCreated(target) {
        const { componentInstanceCreatedListener } = options;
        if (componentInstanceCreatedListener) {
          componentInstanceCreatedListener(target, vueI18n);
        }
      }
    };
    return vueI18n;
  }
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponetI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, {});
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
const Translation = (
  /* defineComponent */
  {
    /* eslint-disable */
    name: "i18n-t",
    props: assign({
      keypath: {
        type: String,
        required: true
      },
      plural: {
        type: [Number, String],
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        validator: (val) => isNumber$1(val) || !isNaN(val)
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
      const { slots, attrs } = context;
      const i18n2 = props.i18n || useI18n({
        useScope: props.scope,
        __useComponent: true
      });
      return () => {
        const keys = Object.keys(slots).filter((key) => key !== "_");
        const options = {};
        if (props.locale) {
          options.locale = props.locale;
        }
        if (props.plural !== void 0) {
          options.plural = isString$1(props.plural) ? +props.plural : props.plural;
        }
        const arg = getInterpolateArg(context, keys);
        const children = i18n2[TranslateVNodeSymbol](props.keypath, arg, options);
        const assignedAttrs = assign({}, attrs);
        const tag = isString$1(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
        return h(tag, assignedAttrs, children);
      };
    }
  }
);
function isVNode(target) {
  return isArray$1(target) && !isString$1(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = {};
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString$1(props.format)) {
      options.key = props.format;
    } else if (isObject$2(props.format)) {
      if (isString$1(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign({}, options2, { [prop]: props.format[prop] }) : options2;
      }, {});
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray$1(parts)) {
      children = parts.map((part, index) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index}`;
        }
        return node;
      });
    } else if (isString$1(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign({}, attrs);
    const tag = isString$1(props.tag) || isObject$2(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormat = (
  /* defineComponent */
  {
    /* eslint-disable */
    name: "i18n-n",
    props: assign({
      value: {
        type: Number,
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: "parent",
        __useComponent: true
      });
      return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[NumberPartsSymbol](...args)
      ));
    }
  }
);
const DatetimeFormat = (
  /*defineComponent */
  {
    /* eslint-disable */
    name: "i18n-d",
    props: assign({
      value: {
        type: [Number, Date],
        required: true
      },
      format: {
        type: [String, Object]
      }
    }, baseFormatProps),
    /* eslint-enable */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    setup(props, context) {
      const i18n2 = props.i18n || useI18n({
        useScope: "parent",
        __useComponent: true
      });
      return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        i18n2[DatetimePartsSymbol](...args)
      ));
    }
  }
);
function getComposer$2(i18n2, instance) {
  const i18nInternal = i18n2;
  if (i18n2.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n2.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n2.global.__composer;
  }
}
function vTDirective(i18n2) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n2, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el2, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n2.global === composer) {
      el2.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el2.__composer = composer;
    el2.textContent = textContent;
  };
  const unregister = (el2) => {
    if (inBrowser && el2.__i18nWatcher) {
      el2.__i18nWatcher();
      el2.__i18nWatcher = void 0;
      delete el2.__i18nWatcher;
    }
    if (el2.__composer) {
      el2.__composer = void 0;
      delete el2.__composer;
    }
  };
  const update2 = (el2, { value }) => {
    if (el2.__composer) {
      const composer = el2.__composer;
      const parsedValue = parseValue(value);
      el2.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update2,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString$1(value)) {
    return { path: value };
  } else if (isPlainObject$1(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString$1(locale)) {
    options.locale = locale;
  }
  if (isNumber$1(choice)) {
    options.plural = choice;
  }
  if (isNumber$1(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app2, i18n2, ...options) {
  const pluginOptions = isPlainObject$1(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean$1(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    app2.component(!useI18nComponentName ? Translation.name : "i18n", Translation);
    app2.component(NumberFormat.name, NumberFormat);
    app2.component(DatetimeFormat.name, DatetimeFormat);
  }
  {
    app2.directive("t", vTDirective(i18n2));
  }
}
function defineMixin(vuei18n, composer, i18n2) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          this.$i18n = createVueI18n(optionsI18n);
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToRoot(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __root: composer
          });
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      vuei18n.__onComponentInstanceCreated(this.$i18n);
      i18n2.__setInstance(instance, this.$i18n);
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      if (this !== this.$root && !this.$i18n.__extended__ && i18n2.__vueI18nExtend) {
        i18n2.__vueI18nExtend(this.$i18n);
        this.$i18n.__extended__ = true;
      }
    },
    mounted() {
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      i18n2.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToRoot(root2, options) {
  root2.locale = options.locale || root2.locale;
  root2.fallbackLocale = options.fallbackLocale || root2.fallbackLocale;
  root2.missing = options.missing || root2.missing;
  root2.silentTranslationWarn = options.silentTranslationWarn || root2.silentFallbackWarn;
  root2.silentFallbackWarn = options.silentFallbackWarn || root2.silentFallbackWarn;
  root2.formatFallbackMessages = options.formatFallbackMessages || root2.formatFallbackMessages;
  root2.postTranslation = options.postTranslation || root2.postTranslation;
  root2.warnHtmlInMessage = options.warnHtmlInMessage || root2.warnHtmlInMessage;
  root2.escapeParameterHtml = options.escapeParameterHtml || root2.escapeParameterHtml;
  root2.sync = options.sync || root2.sync;
  root2.__composer[SetPluralRulesSymbol](options.pluralizationRules || root2.pluralizationRules);
  const messages = getLocaleMessages(root2.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => root2.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => root2.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => root2.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return root2;
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean$1(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean$1(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  {
    const i18n2 = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app2, ...options2) {
        app2.__VUE_I18N_SYMBOL__ = symbol;
        app2.provide(app2.__VUE_I18N_SYMBOL__, i18n2);
        if (isPlainObject$1(options2[0])) {
          const opts = options2[0];
          i18n2.__composerExtend = opts.__composerExtend;
          i18n2.__vueI18nExtend = opts.__vueI18nExtend;
        }
        if (!__legacyMode && __globalInjection) {
          injectGlobalFields(app2, i18n2.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app2, i18n2, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app2.mixin(defineMixin(__global, __global.__composer, i18n2));
        }
        const unmountApp = app2.unmount;
        app2.unmount = () => {
          i18n2.dispose();
          unmountApp();
        };
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n2;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSLALLED);
  }
  const i18n2 = getI18nInstance(instance);
  const global2 = getGlobalComposer(i18n2);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n2.mode === "legacy" && !options.__useComponent) {
      if (!i18n2.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, global2, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(global2, options, componentOptions);
    return global2;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n2, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = global2;
    }
    return composer2;
  }
  const i18nInternal = i18n2;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (global2) {
      composerOptions.__root = global2;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n2 = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n2) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSLALLED_WITH_PROVIDE);
    }
    return i18n2;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n2) {
  return i18n2.mode === "composition" ? i18n2.global : i18n2.global.__composer;
}
function getComposer(i18n2, target, useComponent = false) {
  let composer = null;
  const root2 = target.root;
  let current = target.parent;
  while (current != null) {
    const i18nInternal = i18n2;
    if (i18n2.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOption]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root2 === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function setupLifeCycle(i18n2, target, composer) {
  {
    onMounted(() => {
    }, target);
    onUnmounted(() => {
      i18n2.__deleteInstance(target);
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root2, options = {}) {
  const isLocale = scope === "local";
  const _composer = shallowRef(null);
  if (isLocale && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean$1(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = ref(
    // prettier-ignore
    isLocale && _inheritLocale ? root2.locale.value : isString$1(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    isLocale && _inheritLocale ? root2.fallbackLocale.value : isString$1(options.fallbackLocale) || isArray$1(options.fallbackLocale) || isPlainObject$1(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject$1(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject$1(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocale ? root2.missingWarn : isBoolean$1(options.missingWarn) || isRegExp$1(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocale ? root2.fallbackWarn : isBoolean$1(options.fallbackWarn) || isRegExp$1(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocale ? root2.fallbackRoot : isBoolean$1(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction$1(options.missing) ? options.missing : null;
  const _postTranslation = isFunction$1(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocale ? root2.warnHtmlMessage : isBoolean$1(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocale ? root2.modifiers : isPlainObject$1(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocale && root2.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn) {
    trackReactivityValues();
    return fn();
  }
  function t2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n2(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te2(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format);
      _datetimeFormats.value[locale2] = format;
    }
  }
  function mergeDateTimeFormat(locale2, format) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format);
      _numberFormats.value[locale2] = format;
    }
  }
  function mergeNumberFormat(locale2, format) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t: t2,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n: n2,
    tm,
    te: te2,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocale) {
      sync(composer);
    }
  });
  return wrapper;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app2, composer) {
  const i18n2 = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n2, prop, wrap);
  });
  app2.config.globalProperties.$i18n = i18n2;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app2.config.globalProperties, `$${method}`, desc);
  });
}
registerMessageCompiler(compileToFunction);
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
{
  initFeatureFlags();
}
if (__INTLIFY_PROD_DEVTOOLS__) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var f = reactExports, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
function q(c, a, g) {
  var b, d = {}, e = null, h2 = null;
  void 0 !== g && (e = "" + g);
  void 0 !== a.key && (e = "" + a.key);
  void 0 !== a.ref && (h2 = a.ref);
  for (b in a)
    m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
  if (c && c.defaultProps)
    for (b in a = c.defaultProps, a)
      void 0 === d[b] && (d[b] = a[b]);
  return { $$typeof: k, type: c, key: e, ref: h2, props: d, _owner: n.current };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
const LogoIcon = '<svg width="55" height="15" viewBox="0 0 145 41" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path fill-rule="evenodd" clip-rule="evenodd" d="M22.7199 30.4706H16.4674C6.71351 30.4706 13.7997 9.75397 22.0113 9.75397H31.8903C33.4742 9.75397 36.267 10.0458 37.6426 6.12752L39.7684 0.041748H26.2213C18.8851 0.041748 13.1744 2.62612 9.04778 6.96119C1.91992 14.3808 -0.49771 25.9688 1.21131 31.5127C2.83696 36.6397 7.2554 40.0161 14.1748 40.0995L19.552 40.1411H26.1796L27.8053 35.2642C29.0141 31.8045 26.3047 30.4706 22.7199 30.4706ZM98.8338 21.8838L100.876 15.2562H79.0758C75.4494 15.2562 73.8237 16.2566 73.1985 18.3407L71.156 24.9684H92.9564C96.5828 24.9684 98.2085 23.968 98.8338 21.8838ZM67.9047 33.5552L65.8622 40.1828H87.6626C91.2474 40.1828 92.9147 39.1824 93.54 37.0983L95.5825 30.4706H73.7821C70.1973 30.4706 68.5716 31.471 67.9047 33.5552ZM103.919 6.71109L105.962 0.0834308H84.1612C80.5348 0.0834308 78.9091 1.08383 78.2839 3.168L76.2414 9.79566H98.0418C101.627 9.79566 103.252 8.79526 103.919 6.71109ZM70.9893 8.04496C70.0722 1.87582 66.7792 0.0834308 58.776 0.0834308H44.1869L35.6835 24.9684H41.0606C44.2702 24.9684 45.8959 25.0101 47.6049 20.4249L51.148 9.75397H56.5668C61.1937 9.75397 60.1516 15.548 57.8173 21.1752C55.7332 26.1355 52.1067 30.5123 47.7299 30.5123H38.6847C35.0582 30.5123 33.3909 31.5127 32.7239 33.5969L30.473 40.2245H37.1007L43.6033 40.1828C49.3556 40.1411 54.0658 39.7243 59.568 34.764C65.4037 29.4702 72.1564 15.8814 70.9893 8.04496ZM144.269 0.041748H131.639L119.759 12.6718C118.383 14.1307 116.966 15.5896 115.59 17.2987H115.465L121.384 0.041748H111.089L97.2081 40.1828H107.504L111.922 27.5528L116.507 23.6762L120.134 35.0975C121.259 38.6405 122.427 40.1828 124.928 40.1828H132.806L124.719 17.7572L144.269 0.041748Z" fill="#00B33C"/>\n</svg>\n';
const FilterIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">\n  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>\n  <path d="M4 4h16v2.172a2 2 0 0 1 -.586 1.414l-4.414 4.414v7l-6 2v-8.5l-4.48 -4.928a2 2 0 0 1 -.52 -1.345v-2.227z" />\n</svg>\n';
const OfficeSVG = '<svg width="28" height="36" viewBox="0 0 28 36" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M28 14.3438C28 17.1324 27.2233 19.7353 25.8793 21.9375C20.1992 31.2453 14 36 14 36C14 36 7.80082 31.2453 2.12068 21.9375C0.776749 19.7353 0 17.1324 0 14.3438C0 6.42192 6.26801 0 14 0C21.732 0 28 6.42192 28 14.3438Z" fill="#1AB248"/>\n<rect x="3" y="3" width="22" height="22" rx="11" fill="white"/>\n<path fill-rule="evenodd" clip-rule="evenodd" d="M20.794 17.6239L19.9795 17.6238C20.1644 17.9281 20.2719 18.2802 20.2719 18.6566C20.2719 19.795 19.3031 20.7217 18.1124 20.7217C16.9217 20.7217 15.9528 19.795 15.9528 18.6566C15.9528 18.2802 16.0604 17.9281 16.2452 17.6238H13.6811C13.8659 17.9281 13.9732 18.2802 13.9732 18.6566C13.9732 19.795 13.0049 20.7217 11.8142 20.7217C10.6232 20.7217 9.6544 19.795 9.6544 18.6566C9.6544 18.2802 9.76196 17.9281 9.94654 17.6238L9.12351 17.6239C8.82677 17.6239 8.58382 17.3914 8.58382 17.1075L8.57447 9.98375L6.82488 8.30977C6.61436 8.10904 6.61436 7.78045 6.82488 7.57973C7.0346 7.379 7.37808 7.379 7.58834 7.57973L9.5152 9.42291C9.5225 9.42989 9.52466 9.43945 9.53142 9.44668C9.55358 9.47251 9.57304 9.50041 9.58952 9.53038C9.65573 9.6381 9.67681 9.759 9.65438 9.87887L9.66373 16.5911H20.794C21.0907 16.5911 21.3337 16.8236 21.3337 17.1075C21.3337 17.3914 21.0907 17.6239 20.794 17.6239ZM11.8142 17.6238C11.2186 17.6238 10.734 18.087 10.734 18.6566C10.734 19.2259 11.2186 19.6891 11.8142 19.6891C12.4093 19.6891 12.8936 19.2259 12.8936 18.6566C12.8936 18.087 12.4093 17.6238 11.8142 17.6238ZM17.0325 18.6566C17.0325 19.2259 17.517 19.6891 18.1124 19.6891C18.708 19.6891 19.192 19.2259 19.192 18.6566C19.192 18.087 18.708 17.6238 18.1124 17.6238C17.517 17.6238 17.0325 18.087 17.0325 18.6566ZM19.7141 15.5585H11.2382C10.9398 15.5585 10.698 15.3273 10.698 15.0421L10.698 7.79337C10.698 7.50843 10.9399 7.27722 11.2382 7.27722H14.9632H16.0428L19.7141 7.29711C20.0124 7.29711 20.254 7.52832 20.254 7.81326V15.0421C20.254 15.3273 20.0124 15.5585 19.7141 15.5585ZM19.1741 8.32966L16.0428 8.30977V9.85897C16.0428 10.1442 15.8012 10.3751 15.5031 10.3751C15.2048 10.3751 14.9632 10.1442 14.9632 9.85897V8.30977H11.7779L11.7779 14.526H19.1741V8.32966Z" fill="#1AB248"/>\n<rect x="3" y="3" width="22" height="22" rx="11" fill="white"/>\n<rect x="3" y="3" width="22" height="22" rx="11" fill="white"/>\n<path d="M8 19H20M9.33333 19V9.66667L14.6667 7V19M18.6667 19V12.3333L14.6667 9.66667M12 11V11.0067M12 13V13.0067M12 15V15.0067M12 17V17.0067" stroke="#1AB248" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>\n</svg>\n';
const PickupSVG = '<svg width="28" height="36" viewBox="0 0 28 36" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path d="M28 14.3438C28 17.1324 27.2233 19.7353 25.8793 21.9375C20.1992 31.2453 14 36 14 36C14 36 7.80082 31.2453 2.12068 21.9375C0.776749 19.7353 0 17.1324 0 14.3438C0 6.42192 6.26801 0 14 0C21.732 0 28 6.42192 28 14.3438Z" fill="#4B3C87"/>\n<rect x="3" y="3" width="22" height="22" rx="11" fill="white"/>\n<rect x="3" y="3" width="22" height="22" rx="11" fill="white"/>\n<path d="M8.66699 15.3333H19.3337M12.667 8.66663V19.3333M8.66699 12H12.667M10.0003 8.66663H18.0003C18.7367 8.66663 19.3337 9.26358 19.3337 9.99996V18C19.3337 18.7363 18.7367 19.3333 18.0003 19.3333H10.0003C9.26395 19.3333 8.66699 18.7363 8.66699 18V9.99996C8.66699 9.26358 9.26395 8.66663 10.0003 8.66663ZM14.667 10.6666H17.3337V13.3333H14.667V10.6666Z" stroke="#4B3C87" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>\n</svg>\n';
const MenuIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round">\n  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>\n  <path d="M4 6l16 0" />\n  <path d="M4 12l16 0" />\n  <path d="M4 18l16 0" />\n</svg>\n';
const PlaceIcon = '<svg width="28" height="36" viewBox="0 0 28 36" fill="none" xmlns="http://www.w3.org/2000/svg">\n    <path d="M28 14.3438C28 17.1324 27.2233 19.7353 25.8793 21.9375C20.1992 31.2453 14 36 14 36C14 36 7.80082 31.2453 2.12068 21.9375C0.776749 19.7353 0 17.1324 0 14.3438C0 6.42192 6.26801 0 14 0C21.732 0 28 6.42192 28 14.3438Z" fill="#EB5440"/>\n    <rect x="3" y="3" width="22" height="22" rx="11" fill="white"/>\n    <path d="M14.6667 14V14.0067M8 20H20M9.33333 20V9.33333C9.33333 8.97971 9.47381 8.64057 9.72386 8.39052C9.97391 8.14048 10.313 8 10.6667 8H14.6667M17.3333 15V20M20 10.6667H15.3333M15.3333 10.6667L17.3333 8.66667M15.3333 10.6667L17.3333 12.6667" stroke="#EB5440" stroke-width="1.4" stroke-linecap="round" stroke-linejoin="round"/>\n</svg>\n';
const [useVueHooksInReact, VueProviderForReact] = createCrossingProviderForReactInVue$1(function() {
  return {
    map: map(),
    core: core()
  };
});
var __read$1 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var styleToObject = function(input) {
  var attributes = input.split(/ ?; ?/);
  return attributes.reduce(function(acc, d) {
    var _a = __read$1(d.split(/ ?: ?/), 2), key = _a[0], value = _a[1];
    if (key && value) {
      acc[key.replace(/-(\w)/g, function(_$0, $12) {
        return $12.toUpperCase();
      })] = Number.isNaN(Number(value)) ? value : Number(value);
    }
    return acc;
  }, {});
};
function randomString$1(length) {
  if (length === void 0) {
    length = 6;
  }
  var characters = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var result = "";
  for (var index = length; index > 0; --index) {
    result += characters[Math.round(Math.random() * (characters.length - 1))];
  }
  return result;
}
var noTextChildNodes = [
  "br",
  "col",
  "colgroup",
  "dl",
  "hr",
  "iframe",
  "img",
  "input",
  "link",
  "menuitem",
  "meta",
  "ol",
  "param",
  "select",
  "table",
  "tbody",
  "tfoot",
  "thead",
  "tr",
  "ul",
  "wbr"
];
var possibleStandardNames = {
  // HTML
  "accept-charset": "acceptCharset",
  acceptcharset: "acceptCharset",
  accesskey: "accessKey",
  allowfullscreen: "allowFullScreen",
  autocapitalize: "autoCapitalize",
  autocomplete: "autoComplete",
  autocorrect: "autoCorrect",
  autofocus: "autoFocus",
  autoplay: "autoPlay",
  autosave: "autoSave",
  cellpadding: "cellPadding",
  cellspacing: "cellSpacing",
  charset: "charSet",
  class: "className",
  classid: "classID",
  classname: "className",
  colspan: "colSpan",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  controlslist: "controlsList",
  crossorigin: "crossOrigin",
  dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
  datetime: "dateTime",
  defaultchecked: "defaultChecked",
  defaultvalue: "defaultValue",
  enctype: "encType",
  for: "htmlFor",
  formmethod: "formMethod",
  formaction: "formAction",
  formenctype: "formEncType",
  formnovalidate: "formNoValidate",
  formtarget: "formTarget",
  frameborder: "frameBorder",
  hreflang: "hrefLang",
  htmlfor: "htmlFor",
  httpequiv: "httpEquiv",
  "http-equiv": "httpEquiv",
  icon: "icon",
  innerhtml: "innerHTML",
  inputmode: "inputMode",
  itemid: "itemID",
  itemprop: "itemProp",
  itemref: "itemRef",
  itemscope: "itemScope",
  itemtype: "itemType",
  keyparams: "keyParams",
  keytype: "keyType",
  marginwidth: "marginWidth",
  marginheight: "marginHeight",
  maxlength: "maxLength",
  mediagroup: "mediaGroup",
  minlength: "minLength",
  nomodule: "noModule",
  novalidate: "noValidate",
  playsinline: "playsInline",
  radiogroup: "radioGroup",
  readonly: "readOnly",
  referrerpolicy: "referrerPolicy",
  rowspan: "rowSpan",
  spellcheck: "spellCheck",
  srcdoc: "srcDoc",
  srclang: "srcLang",
  srcset: "srcSet",
  tabindex: "tabIndex",
  typemustmatch: "typeMustMatch",
  usemap: "useMap",
  // SVG
  accentheight: "accentHeight",
  "accent-height": "accentHeight",
  alignmentbaseline: "alignmentBaseline",
  "alignment-baseline": "alignmentBaseline",
  allowreorder: "allowReorder",
  arabicform: "arabicForm",
  "arabic-form": "arabicForm",
  attributename: "attributeName",
  attributetype: "attributeType",
  autoreverse: "autoReverse",
  basefrequency: "baseFrequency",
  baselineshift: "baselineShift",
  "baseline-shift": "baselineShift",
  baseprofile: "baseProfile",
  calcmode: "calcMode",
  capheight: "capHeight",
  "cap-height": "capHeight",
  clippath: "clipPath",
  "clip-path": "clipPath",
  clippathunits: "clipPathUnits",
  cliprule: "clipRule",
  "clip-rule": "clipRule",
  colorinterpolation: "colorInterpolation",
  "color-interpolation": "colorInterpolation",
  colorinterpolationfilters: "colorInterpolationFilters",
  "color-interpolation-filters": "colorInterpolationFilters",
  colorprofile: "colorProfile",
  "color-profile": "colorProfile",
  colorrendering: "colorRendering",
  "color-rendering": "colorRendering",
  contentscripttype: "contentScriptType",
  contentstyletype: "contentStyleType",
  diffuseconstant: "diffuseConstant",
  dominantbaseline: "dominantBaseline",
  "dominant-baseline": "dominantBaseline",
  edgemode: "edgeMode",
  enablebackground: "enableBackground",
  "enable-background": "enableBackground",
  externalresourcesrequired: "externalResourcesRequired",
  fillopacity: "fillOpacity",
  "fill-opacity": "fillOpacity",
  fillrule: "fillRule",
  "fill-rule": "fillRule",
  filterres: "filterRes",
  filterunits: "filterUnits",
  floodopacity: "floodOpacity",
  "flood-opacity": "floodOpacity",
  floodcolor: "floodColor",
  "flood-color": "floodColor",
  fontfamily: "fontFamily",
  "font-family": "fontFamily",
  fontsize: "fontSize",
  "font-size": "fontSize",
  fontsizeadjust: "fontSizeAdjust",
  "font-size-adjust": "fontSizeAdjust",
  fontstretch: "fontStretch",
  "font-stretch": "fontStretch",
  fontstyle: "fontStyle",
  "font-style": "fontStyle",
  fontvariant: "fontVariant",
  "font-variant": "fontVariant",
  fontweight: "fontWeight",
  "font-weight": "fontWeight",
  glyphname: "glyphName",
  "glyph-name": "glyphName",
  glyphorientationhorizontal: "glyphOrientationHorizontal",
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphorientationvertical: "glyphOrientationVertical",
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphref: "glyphRef",
  gradienttransform: "gradientTransform",
  gradientunits: "gradientUnits",
  horizadvx: "horizAdvX",
  "horiz-adv-x": "horizAdvX",
  horizoriginx: "horizOriginX",
  "horiz-origin-x": "horizOriginX",
  imagerendering: "imageRendering",
  "image-rendering": "imageRendering",
  kernelmatrix: "kernelMatrix",
  kernelunitlength: "kernelUnitLength",
  keypoints: "keyPoints",
  keysplines: "keySplines",
  keytimes: "keyTimes",
  lengthadjust: "lengthAdjust",
  letterspacing: "letterSpacing",
  "letter-spacing": "letterSpacing",
  lightingcolor: "lightingColor",
  "lighting-color": "lightingColor",
  limitingconeangle: "limitingConeAngle",
  markerend: "markerEnd",
  "marker-end": "markerEnd",
  markerheight: "markerHeight",
  markermid: "markerMid",
  "marker-mid": "markerMid",
  markerstart: "markerStart",
  "marker-start": "markerStart",
  markerunits: "markerUnits",
  markerwidth: "markerWidth",
  maskcontentunits: "maskContentUnits",
  maskunits: "maskUnits",
  numoctaves: "numOctaves",
  overlineposition: "overlinePosition",
  "overline-position": "overlinePosition",
  overlinethickness: "overlineThickness",
  "overline-thickness": "overlineThickness",
  paintorder: "paintOrder",
  "paint-order": "paintOrder",
  "panose-1": "panose1",
  pathlength: "pathLength",
  patterncontentunits: "patternContentUnits",
  patterntransform: "patternTransform",
  patternunits: "patternUnits",
  pointerevents: "pointerEvents",
  "pointer-events": "pointerEvents",
  pointsatx: "pointsAtX",
  pointsaty: "pointsAtY",
  pointsatz: "pointsAtZ",
  preservealpha: "preserveAlpha",
  preserveaspectratio: "preserveAspectRatio",
  primitiveunits: "primitiveUnits",
  refx: "refX",
  refy: "refY",
  renderingintent: "renderingIntent",
  "rendering-intent": "renderingIntent",
  repeatcount: "repeatCount",
  repeatdur: "repeatDur",
  requiredextensions: "requiredExtensions",
  requiredfeatures: "requiredFeatures",
  shaperendering: "shapeRendering",
  "shape-rendering": "shapeRendering",
  specularconstant: "specularConstant",
  specularexponent: "specularExponent",
  spreadmethod: "spreadMethod",
  startoffset: "startOffset",
  stddeviation: "stdDeviation",
  stitchtiles: "stitchTiles",
  stopcolor: "stopColor",
  "stop-color": "stopColor",
  stopopacity: "stopOpacity",
  "stop-opacity": "stopOpacity",
  strikethroughposition: "strikethroughPosition",
  "strikethrough-position": "strikethroughPosition",
  strikethroughthickness: "strikethroughThickness",
  "strikethrough-thickness": "strikethroughThickness",
  strokedasharray: "strokeDasharray",
  "stroke-dasharray": "strokeDasharray",
  strokedashoffset: "strokeDashoffset",
  "stroke-dashoffset": "strokeDashoffset",
  strokelinecap: "strokeLinecap",
  "stroke-linecap": "strokeLinecap",
  strokelinejoin: "strokeLinejoin",
  "stroke-linejoin": "strokeLinejoin",
  strokemiterlimit: "strokeMiterlimit",
  "stroke-miterlimit": "strokeMiterlimit",
  strokewidth: "strokeWidth",
  "stroke-width": "strokeWidth",
  strokeopacity: "strokeOpacity",
  "stroke-opacity": "strokeOpacity",
  suppresscontenteditablewarning: "suppressContentEditableWarning",
  suppresshydrationwarning: "suppressHydrationWarning",
  surfacescale: "surfaceScale",
  systemlanguage: "systemLanguage",
  tablevalues: "tableValues",
  targetx: "targetX",
  targety: "targetY",
  textanchor: "textAnchor",
  "text-anchor": "textAnchor",
  textdecoration: "textDecoration",
  "text-decoration": "textDecoration",
  textlength: "textLength",
  textrendering: "textRendering",
  "text-rendering": "textRendering",
  underlineposition: "underlinePosition",
  "underline-position": "underlinePosition",
  underlinethickness: "underlineThickness",
  "underline-thickness": "underlineThickness",
  unicodebidi: "unicodeBidi",
  "unicode-bidi": "unicodeBidi",
  unicoderange: "unicodeRange",
  "unicode-range": "unicodeRange",
  unitsperem: "unitsPerEm",
  "units-per-em": "unitsPerEm",
  unselectable: "unselectable",
  valphabetic: "vAlphabetic",
  "v-alphabetic": "vAlphabetic",
  vectoreffect: "vectorEffect",
  "vector-effect": "vectorEffect",
  vertadvy: "vertAdvY",
  "vert-adv-y": "vertAdvY",
  vertoriginx: "vertOriginX",
  "vert-origin-x": "vertOriginX",
  vertoriginy: "vertOriginY",
  "vert-origin-y": "vertOriginY",
  vhanging: "vHanging",
  "v-hanging": "vHanging",
  videographic: "vIdeographic",
  "v-ideographic": "vIdeographic",
  viewbox: "viewBox",
  viewtarget: "viewTarget",
  vmathematical: "vMathematical",
  "v-mathematical": "vMathematical",
  wordspacing: "wordSpacing",
  "word-spacing": "wordSpacing",
  writingmode: "writingMode",
  "writing-mode": "writingMode",
  xchannelselector: "xChannelSelector",
  xheight: "xHeight",
  "x-height": "xHeight",
  xlinkactuate: "xlinkActuate",
  "xlink:actuate": "xlinkActuate",
  xlinkarcrole: "xlinkArcrole",
  "xlink:arcrole": "xlinkArcrole",
  xlinkhref: "xlinkHref",
  "xlink:href": "xlinkHref",
  xlinkrole: "xlinkRole",
  "xlink:role": "xlinkRole",
  xlinkshow: "xlinkShow",
  "xlink:show": "xlinkShow",
  xlinktitle: "xlinkTitle",
  "xlink:title": "xlinkTitle",
  xlinktype: "xlinkType",
  "xlink:type": "xlinkType",
  xmlbase: "xmlBase",
  "xml:base": "xmlBase",
  xmllang: "xmlLang",
  "xml:lang": "xmlLang",
  "xml:space": "xmlSpace",
  xmlnsxlink: "xmlnsXlink",
  "xmlns:xlink": "xmlnsXlink",
  xmlspace: "xmlSpace",
  ychannelselector: "yChannelSelector",
  zoomandpan: "zoomAndPan",
  // event handlers
  onblur: "onBlur",
  onchange: "onChange",
  onclick: "onClick",
  oncontextmenu: "onContextMenu",
  ondoubleclick: "onDoubleClick",
  ondrag: "onDrag",
  ondragend: "onDragEnd",
  ondragenter: "onDragEnter",
  ondragexit: "onDragExit",
  ondragleave: "onDragLeave",
  ondragover: "onDragOver",
  ondragstart: "onDragStart",
  ondrop: "onDrop",
  onerror: "onError",
  onfocus: "onFocus",
  oninput: "onInput",
  oninvalid: "onInvalid",
  onkeydown: "onKeyDown",
  onkeypress: "onKeyPress",
  onkeyup: "onKeyUp",
  onload: "onLoad",
  onmousedown: "onMouseDown",
  onmouseenter: "onMouseEnter",
  onmouseleave: "onMouseLeave",
  onmousemove: "onMouseMove",
  onmouseout: "onMouseOut",
  onmouseover: "onMouseOver",
  onmouseup: "onMouseUp",
  onscroll: "onScroll",
  onsubmit: "onSubmit",
  ontouchcancel: "onTouchCancel",
  ontouchend: "onTouchEnd",
  ontouchmove: "onTouchMove",
  ontouchstart: "onTouchStart",
  onwheel: "onWheel"
};
var __assign = globalThis && globalThis.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __read = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function parseAttributes(node, reactKey) {
  var attributes = {
    key: reactKey
  };
  if (node instanceof Element) {
    var nodeClassNames = node.getAttribute("class");
    if (nodeClassNames) {
      attributes.className = nodeClassNames;
    }
    __spreadArray([], __read(node.attributes), false).forEach(function(d) {
      switch (d.name) {
        case "class":
          break;
        case "style":
          attributes[d.name] = styleToObject(d.value);
          break;
        case "allowfullscreen":
        case "allowpaymentrequest":
        case "async":
        case "autofocus":
        case "autoplay":
        case "checked":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "formnovalidate":
        case "hidden":
        case "ismap":
        case "itemscope":
        case "loop":
        case "multiple":
        case "muted":
        case "nomodule":
        case "novalidate":
        case "open":
        case "readonly":
        case "required":
        case "reversed":
        case "selected":
        case "typemustmatch":
          attributes[possibleStandardNames[d.name] || d.name] = true;
          break;
        default:
          attributes[possibleStandardNames[d.name] || d.name] = d.value;
      }
    });
  }
  return attributes;
}
function parseChildren(childNodeList, level, options) {
  var children = __spreadArray([], __read(childNodeList), false).map(function(node, index) {
    return convertFromNode(node, __assign(__assign({}, options), { index, level: level + 1 }));
  }).filter(Boolean);
  if (!children.length) {
    return null;
  }
  return children;
}
function parseName(nodeName) {
  if (/[a-z]+[A-Z]+[a-z]+/.test(nodeName)) {
    return nodeName;
  }
  return nodeName.toLowerCase();
}
function convertFromNode(input, options) {
  var _a;
  if (options === void 0) {
    options = {};
  }
  if (!input || !(input instanceof Node)) {
    return null;
  }
  var _b = options.actions, actions = _b === void 0 ? [] : _b, _c = options.index, index = _c === void 0 ? 0 : _c, _d = options.level, level = _d === void 0 ? 0 : _d, randomKey = options.randomKey;
  var node = input;
  var key = "".concat(level, "-").concat(index);
  var result = [];
  if (randomKey && level === 0) {
    key = "".concat(randomString$1(), "-").concat(key);
  }
  if (Array.isArray(actions)) {
    actions.forEach(function(action) {
      if (action.condition(node, key, level)) {
        if (typeof action.pre === "function") {
          node = action.pre(node, key, level);
          if (!(node instanceof Node)) {
            node = input;
          }
        }
        if (typeof action.post === "function") {
          result.push(action.post(node, key, level));
        }
      }
    });
  }
  if (result.length) {
    return result;
  }
  switch (node.nodeType) {
    case 1: {
      return reactExports.createElement(parseName(node.nodeName), parseAttributes(node, key), parseChildren(node.childNodes, level, options));
    }
    case 3: {
      var nodeText = ((_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.toString()) || "";
      if (/^\s+$/.test(nodeText) && !/[\u00A0\u202F]/.test(nodeText)) {
        return null;
      }
      if (!node.parentNode) {
        return nodeText;
      }
      var parentNodeName = node.parentNode.nodeName.toLowerCase();
      if (noTextChildNodes.includes(parentNodeName)) {
        if (/\S/.test(nodeText)) {
          console.warn("A textNode is not allowed inside '".concat(parentNodeName, `'. Your text "`).concat(nodeText, '" will be ignored'));
        }
        return null;
      }
      return nodeText;
    }
    case 8: {
      return null;
    }
    default: {
      return null;
    }
  }
}
function convertFromString(input, options) {
  if (options === void 0) {
    options = {};
  }
  if (!input || typeof input !== "string") {
    return null;
  }
  var _a = options.nodeOnly, nodeOnly = _a === void 0 ? false : _a, _b = options.selector, selector = _b === void 0 ? "body > *" : _b, _c = options.type, type = _c === void 0 ? "text/html" : _c;
  try {
    var parser = new DOMParser();
    var document_1 = parser.parseFromString(input, type);
    var node = document_1.querySelector(selector);
    if (!(node instanceof Node)) {
      throw new TypeError("Error parsing input");
    }
    if (nodeOnly) {
      return node;
    }
    return convertFromNode(node, options);
  } catch (error) {
  }
  return null;
}
function convert(input, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof input === "string") {
    return convertFromString(input, options);
  }
  if (input instanceof Node) {
    return convertFromNode(input, options);
  }
  return null;
}
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var CACHE_NAME = "react-inlinesvg";
var CACHE_MAX_RETRIES = 10;
var STATUS = {
  IDLE: "idle",
  LOADING: "loading",
  LOADED: "loaded",
  FAILED: "failed",
  READY: "ready",
  UNSUPPORTED: "unsupported"
};
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function isSupportedEnvironment() {
  return supportsInlineSVG() && typeof window !== "undefined" && window !== null;
}
async function request(url, options) {
  const response = await fetch(url, options);
  const contentType = response.headers.get("content-type");
  const [fileType] = (contentType || "").split(/ ?; ?/);
  if (response.status > 299) {
    throw new Error("Not found");
  }
  if (!["image/svg+xml", "text/plain"].some((d) => fileType.includes(d))) {
    throw new Error(`Content type isn't valid: ${fileType}`);
  }
  return response.text();
}
function sleep(seconds = 1) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, seconds * 1e3);
  });
}
function supportsInlineSVG() {
  if (!document) {
    return false;
  }
  const div2 = document.createElement("div");
  div2.innerHTML = "<svg />";
  const svg = div2.firstChild;
  return !!svg && svg.namespaceURI === "http://www.w3.org/2000/svg";
}
function randomCharacter(character) {
  return character[Math.floor(Math.random() * character.length)];
}
function randomString(length) {
  const letters = "abcdefghijklmnopqrstuvwxyz";
  const numbers = "1234567890";
  const charset = `${letters}${letters.toUpperCase()}${numbers}`;
  let R2 = "";
  for (let index = 0; index < length; index++) {
    R2 += randomCharacter(charset);
  }
  return R2;
}
function omit(input, ...filter2) {
  const output = {};
  for (const key in input) {
    if ({}.hasOwnProperty.call(input, key)) {
      if (!filter2.includes(key)) {
        output[key] = input[key];
      }
    }
  }
  return output;
}
var CacheStore = class {
  constructor() {
    __publicField2(this, "cacheApi");
    __publicField2(this, "cacheStore");
    __publicField2(this, "subscribers", []);
    __publicField2(this, "isReady", false);
    this.cacheStore = /* @__PURE__ */ new Map();
    let cacheName = CACHE_NAME;
    let usePersistentCache = false;
    if (canUseDOM()) {
      cacheName = window.REACT_INLINESVG_CACHE_NAME ?? CACHE_NAME;
      usePersistentCache = !!window.REACT_INLINESVG_PERSISTENT_CACHE;
    }
    if (usePersistentCache) {
      caches.open(cacheName).then((cache2) => {
        this.cacheApi = cache2;
        this.isReady = true;
        this.subscribers.forEach((callback) => callback());
      });
    } else {
      this.isReady = true;
    }
  }
  onReady(callback) {
    if (this.isReady) {
      callback();
    } else {
      this.subscribers.push(callback);
    }
  }
  async get(url, fetchOptions) {
    var _a;
    await (this.cacheApi ? this.fetchAndAddToPersistentCache(url, fetchOptions) : this.fetchAndAddToInternalCache(url, fetchOptions));
    return ((_a = this.cacheStore.get(url)) == null ? void 0 : _a.content) ?? "";
  }
  set(url, data) {
    this.cacheStore.set(url, data);
  }
  isCached(url) {
    var _a;
    return ((_a = this.cacheStore.get(url)) == null ? void 0 : _a.status) === STATUS.LOADED;
  }
  async fetchAndAddToInternalCache(url, fetchOptions) {
    const cache2 = this.cacheStore.get(url);
    if ((cache2 == null ? void 0 : cache2.status) === STATUS.LOADING) {
      await this.handleLoading(url, async () => {
        this.cacheStore.set(url, { content: "", status: STATUS.IDLE });
        await this.fetchAndAddToInternalCache(url, fetchOptions);
      });
      return;
    }
    if (!(cache2 == null ? void 0 : cache2.content)) {
      this.cacheStore.set(url, { content: "", status: STATUS.LOADING });
      try {
        const content = await request(url, fetchOptions);
        this.cacheStore.set(url, { content, status: STATUS.LOADED });
      } catch (error) {
        this.cacheStore.set(url, { content: "", status: STATUS.FAILED });
        throw error;
      }
    }
  }
  async fetchAndAddToPersistentCache(url, fetchOptions) {
    var _a, _b, _c;
    const cache2 = this.cacheStore.get(url);
    if ((cache2 == null ? void 0 : cache2.status) === STATUS.LOADED) {
      return;
    }
    if ((cache2 == null ? void 0 : cache2.status) === STATUS.LOADING) {
      await this.handleLoading(url, async () => {
        this.cacheStore.set(url, { content: "", status: STATUS.IDLE });
        await this.fetchAndAddToPersistentCache(url, fetchOptions);
      });
      return;
    }
    this.cacheStore.set(url, { content: "", status: STATUS.LOADING });
    const data = await ((_a = this.cacheApi) == null ? void 0 : _a.match(url));
    if (data) {
      const content = await data.text();
      this.cacheStore.set(url, { content, status: STATUS.LOADED });
      return;
    }
    try {
      await ((_b = this.cacheApi) == null ? void 0 : _b.add(new Request(url, fetchOptions)));
      const response = await ((_c = this.cacheApi) == null ? void 0 : _c.match(url));
      const content = await (response == null ? void 0 : response.text()) ?? "";
      this.cacheStore.set(url, { content, status: STATUS.LOADED });
    } catch (error) {
      this.cacheStore.set(url, { content: "", status: STATUS.FAILED });
      throw error;
    }
  }
  async handleLoading(url, callback) {
    var _a;
    let retryCount = 0;
    while (((_a = this.cacheStore.get(url)) == null ? void 0 : _a.status) === STATUS.LOADING && retryCount < CACHE_MAX_RETRIES) {
      await sleep(0.1);
      retryCount += 1;
    }
    if (retryCount >= CACHE_MAX_RETRIES) {
      await callback();
    }
  }
  keys() {
    return [...this.cacheStore.keys()];
  }
  data() {
    return [...this.cacheStore.entries()].map(([key, value]) => ({ [key]: value }));
  }
  async delete(url) {
    if (this.cacheApi) {
      await this.cacheApi.delete(url);
    }
    this.cacheStore.delete(url);
  }
  async clear() {
    if (this.cacheApi) {
      const keys = await this.cacheApi.keys();
      for (const key of keys) {
        await this.cacheApi.delete(key);
      }
    }
    this.cacheStore.clear();
  }
};
var cacheStore;
var ReactInlineSVG = class extends reactExports.PureComponent {
  constructor(props) {
    super(props);
    __publicField2(this, "hash");
    __publicField2(this, "isActive", false);
    __publicField2(this, "isInitialized", false);
    __publicField2(this, "fetchContent", async () => {
      const { fetchOptions, src } = this.props;
      const content = await request(src, fetchOptions);
      this.handleLoad(content);
    });
    __publicField2(this, "handleError", (error) => {
      const { onError } = this.props;
      const status = error.message === "Browser does not support SVG" ? STATUS.UNSUPPORTED : STATUS.FAILED;
      if (this.isActive) {
        this.setState({ status }, () => {
          if (typeof onError === "function") {
            onError(error);
          }
        });
      }
    });
    __publicField2(this, "handleLoad", (content, hasCache = false) => {
      if (this.isActive) {
        this.setState(
          {
            content,
            isCached: hasCache,
            status: STATUS.LOADED
          },
          this.getElement
        );
      }
    });
    this.state = {
      content: "",
      element: null,
      isCached: !!props.cacheRequests && cacheStore.isCached(props.src),
      status: STATUS.IDLE
    };
    this.hash = props.uniqueHash || randomString(8);
  }
  componentDidMount() {
    this.isActive = true;
    if (!canUseDOM() || this.isInitialized) {
      return;
    }
    const { status } = this.state;
    const { src } = this.props;
    try {
      if (status === STATUS.IDLE) {
        if (!isSupportedEnvironment()) {
          throw new Error("Browser does not support SVG");
        }
        if (!src) {
          throw new Error("Missing src");
        }
        this.load();
      }
    } catch (error) {
      this.handleError(error);
    }
    this.isInitialized = true;
  }
  componentDidUpdate(previousProps, previousState) {
    if (!canUseDOM()) {
      return;
    }
    const { isCached, status } = this.state;
    const { onLoad, src } = this.props;
    if (previousState.status !== STATUS.READY && status === STATUS.READY) {
      if (onLoad) {
        onLoad(src, isCached);
      }
    }
    if (previousProps.src !== src) {
      if (!src) {
        this.handleError(new Error("Missing src"));
        return;
      }
      this.load();
    }
  }
  componentWillUnmount() {
    this.isActive = false;
  }
  getElement() {
    try {
      const node = this.getNode();
      const element = convert(node);
      if (!element || !reactExports.isValidElement(element)) {
        throw new Error("Could not convert the src to a React element");
      }
      this.setState({
        element,
        status: STATUS.READY
      });
    } catch (error) {
      this.handleError(new Error(error.message));
    }
  }
  getNode() {
    const { description, title } = this.props;
    try {
      const svgText = this.processSVG();
      const node = convert(svgText, { nodeOnly: true });
      if (!node || !(node instanceof SVGSVGElement)) {
        throw new Error("Could not convert the src to a DOM Node");
      }
      const svg = this.updateSVGAttributes(node);
      if (description) {
        const originalDesc = svg.querySelector("desc");
        if (originalDesc && originalDesc.parentNode) {
          originalDesc.parentNode.removeChild(originalDesc);
        }
        const descElement = document.createElementNS("http://www.w3.org/2000/svg", "desc");
        descElement.innerHTML = description;
        svg.prepend(descElement);
      }
      if (typeof title !== "undefined") {
        const originalTitle = svg.querySelector("title");
        if (originalTitle && originalTitle.parentNode) {
          originalTitle.parentNode.removeChild(originalTitle);
        }
        if (title) {
          const titleElement = document.createElementNS("http://www.w3.org/2000/svg", "title");
          titleElement.innerHTML = title;
          svg.prepend(titleElement);
        }
      }
      return svg;
    } catch (error) {
      return this.handleError(error);
    }
  }
  load() {
    if (this.isActive) {
      this.setState(
        {
          content: "",
          element: null,
          isCached: false,
          status: STATUS.LOADING
        },
        async () => {
          const { cacheRequests, fetchOptions, src } = this.props;
          const dataURI = src.match(/^data:image\/svg[^,]*?(;base64)?,(.*)/u);
          let inlineSrc;
          if (dataURI) {
            inlineSrc = dataURI[1] ? window.atob(dataURI[2]) : decodeURIComponent(dataURI[2]);
          } else if (src.includes("<svg")) {
            inlineSrc = src;
          }
          if (inlineSrc) {
            this.handleLoad(inlineSrc);
            return;
          }
          try {
            if (cacheRequests) {
              const content = await cacheStore.get(src, fetchOptions);
              this.handleLoad(content, true);
            } else {
              await this.fetchContent();
            }
          } catch (error) {
            this.handleError(error);
          }
        }
      );
    }
  }
  processSVG() {
    const { content } = this.state;
    const { preProcessor } = this.props;
    if (preProcessor) {
      return preProcessor(content);
    }
    return content;
  }
  updateSVGAttributes(node) {
    const { baseURL = "", uniquifyIDs } = this.props;
    const replaceableAttributes = ["id", "href", "xlink:href", "xlink:role", "xlink:arcrole"];
    const linkAttributes = ["href", "xlink:href"];
    const isDataValue = (name, value) => linkAttributes.includes(name) && (value ? !value.includes("#") : false);
    if (!uniquifyIDs) {
      return node;
    }
    [...node.children].forEach((d) => {
      if (d.attributes && d.attributes.length) {
        const attributes = Object.values(d.attributes).map((a) => {
          const attribute = a;
          const match = a.value.match(/url\((.*?)\)/);
          if (match && match[1]) {
            attribute.value = a.value.replace(match[0], `url(${baseURL}${match[1]}__${this.hash})`);
          }
          return attribute;
        });
        replaceableAttributes.forEach((r2) => {
          const attribute = attributes.find((a) => a.name === r2);
          if (attribute && !isDataValue(r2, attribute.value)) {
            attribute.value = `${attribute.value}__${this.hash}`;
          }
        });
      }
      if (d.children.length) {
        return this.updateSVGAttributes(d);
      }
      return d;
    });
    return node;
  }
  render() {
    const { element, status } = this.state;
    const { children = null, innerRef, loader = null } = this.props;
    const elementProps = omit(
      this.props,
      "baseURL",
      "cacheRequests",
      "children",
      "description",
      "fetchOptions",
      "innerRef",
      "loader",
      "onError",
      "onLoad",
      "preProcessor",
      "src",
      "title",
      "uniqueHash",
      "uniquifyIDs"
    );
    if (!canUseDOM()) {
      return loader;
    }
    if (element) {
      return reactExports.cloneElement(element, { ref: innerRef, ...elementProps });
    }
    if ([STATUS.UNSUPPORTED, STATUS.FAILED].includes(status)) {
      return children;
    }
    return loader;
  }
};
__publicField2(ReactInlineSVG, "defaultProps", {
  cacheRequests: true,
  uniquifyIDs: false
});
function InlineSVG(props) {
  if (!cacheStore) {
    cacheStore = new CacheStore();
  }
  const { loader } = props;
  const hasCallback = reactExports.useRef(false);
  const [isReady, setReady] = reactExports.useState(cacheStore.isReady);
  reactExports.useEffect(() => {
    if (!hasCallback.current) {
      cacheStore.onReady(() => {
        setReady(true);
      });
      hasCallback.current = true;
    }
  }, []);
  if (!isReady) {
    return loader;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactInlineSVG, { ...props });
}
const Map$1 = (YMap, YMapDefaultSchemeLayer, YMapDefaultFeaturesLayer, YMapControls, YMapControlButton, YMapControlCommonButton, YMapZoomControl, YMapGeolocationControl, YMapListener, YMapMarker, YMapClusterer, clusterByGrid) => (props) => {
  const { map: map2, core: core2 } = useVueHooksInReact();
  const gridSizedMethod = reactExports.useMemo(() => clusterByGrid({ gridSize: 64 }), [clusterByGrid]);
  const selectOffice = (exactOffice) => {
    if (core2.debug)
      console.debug("[CDEK] Switching delivery mode to office");
    core2.$patch({
      mode: DeliveryMode.OFFICE,
      selectedTariff: null,
      selected: false
    });
    if (core2.debug) {
      console.debug("[CDEK] Selected office from map", toRaw(exactOffice));
    }
    map2.$patch({
      exactOffice,
      location: {
        ...map2.location,
        center: exactOffice.location,
        zoom: 17
      }
    });
    if (!core2.openedPopups[Popup.INFO])
      core2.togglePopup(Popup.INFO);
  };
  const marker = reactExports.useCallback(
    (feature) => /* @__PURE__ */ jsxRuntimeExports.jsx(YMapMarker, { coordinates: feature.geometry.coordinates, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      InlineSVG,
      {
        style: {
          transform: "translate(-50%, calc(-50% - 13px))",
          scale: map2.exactOffice !== null && map2.exactOffice.code === feature.properties.code ? "1.2" : "1"
        },
        src: feature.properties.type === OfficeType.OFFICE ? OfficeSVG : PickupSVG,
        className: "twc-cursor-pointer",
        onClick: (e) => {
          e.stopPropagation();
          e.preventDefault();
          selectOffice(feature.properties);
        }
      }
    ) }),
    [map2.exactOffice]
  );
  const cluster = reactExports.useCallback(
    (coordinates, features) => /* @__PURE__ */ jsxRuntimeExports.jsx(YMapMarker, { coordinates, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "twc-bg-white twc-border-2 twc-rounded-full twc-border-green-600 twc-relative twc-text-stone-700 " + (features.length > 999 && features.length < 1e4 ? "twc-py-3 twc-px-2" : "") + " " + (features.length > 99 && features.length < 1e3 ? "twc-py-2 twc-px-2" : "") + " " + (features.length > 9 && features.length < 100 ? "twc-py-1 twc-px-2" : "") + " " + (features.length < 10 ? "twc-py-1 twc-px-3" : ""),
        children: features.length
      }
    ) }),
    []
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    YMap,
    {
      location: props.location,
      onClick: (e) => {
        e.stopPropagation();
        e.preventDefault();
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(YMapListener, { onUpdate: map2.update, onMouseDown: core2.closePopups, onClick: map2.customClick }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(YMapDefaultSchemeLayer, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(YMapDefaultFeaturesLayer, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(YMapControls, { position: "right", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(YMapZoomControl, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(YMapGeolocationControl, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(YMapControls, { position: "bottom left", orientation: "vertical", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            YMapControlButton,
            {
              onClick: (e) => {
                e.stopPropagation();
                e.preventDefault();
              },
              children: props.support()
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(YMapControlCommonButton, { background: "rgba(0,0,0,0)", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            "a",
            {
              href: config.promo.url,
              target: "_blank",
              className: "twc-absolute twc-z-50 twc-bottom-2 twc-left-2",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(InlineSVG, { src: LogoIcon })
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(YMapControls, { position: "top right", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            YMapControlButton,
            {
              onClick: (e) => {
                e.stopPropagation();
                e.preventDefault();
              },
              children: props.delivery()
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            YMapControlButton,
            {
              onClick: (e) => {
                e.stopPropagation();
                e.preventDefault();
                core2.togglePopup(Popup.MENU);
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(InlineSVG, { src: MenuIcon, className: "twc-stroke-stone-700" })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(YMapControls, { position: "top left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            YMapControlButton,
            {
              onClick: (e) => {
                e.stopPropagation();
                e.preventDefault();
              },
              children: props.search()
            }
          ),
          !core2.params.hideFilters.have_cashless || !core2.params.hideFilters.have_cash || !core2.params.hideFilters.is_dressing_room || !core2.params.hideFilters.type ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            YMapControlButton,
            {
              onClick: (e) => {
                e.stopPropagation();
                e.preventDefault();
                core2.togglePopup(Popup.FILTERS);
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(InlineSVG, { src: FilterIcon, className: "twc-stroke-stone-700" })
            }
          ) : "",
          core2.openedPopups[Popup.FILTERS] ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            YMapControlButton,
            {
              onClick: (e) => {
                e.stopPropagation();
                e.preventDefault();
              },
              children: props.filter()
            }
          ) : ""
        ] }),
        core2.mode === DeliveryMode.OFFICE ? /* @__PURE__ */ jsxRuntimeExports.jsx(YMapClusterer, { marker, cluster, method: gridSizedMethod, features: props.points }) : "",
        map2.exactPoint !== null && core2.mode === DeliveryMode.DOOR ? /* @__PURE__ */ jsxRuntimeExports.jsx(YMapMarker, { coordinates: map2.exactPoint, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          InlineSVG,
          {
            src: PlaceIcon,
            className: "twc-cursor-pointer",
            style: { transform: "translate(-50%, calc(-50% - 13px))" }
          }
        ) }) : ""
      ]
    }
  );
};
const _hoisted_1$5 = { class: "cdek-segmented" };
const _hoisted_2$4 = ["onClick"];
const _hoisted_3$4 = ["checked", "value", "onInput"];
const _hoisted_4$4 = { class: "cdek-segmented_button_label" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "SegmentedControl",
  props: {
    modelValue: {},
    items: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const selectedIndex = ref(0);
    props.items.forEach((e, i) => e.value === props.modelValue ? selectedIndex.value = i : "");
    watch(
      () => props.modelValue,
      () => {
        props.items.forEach((e, i) => e.value === props.modelValue ? selectedIndex.value = i : "");
      }
    );
    const selectSegment = (e, key) => {
      e.preventDefault();
      e.stopPropagation();
      if (unref(selectedIndex) === key) {
        return;
      }
      selectedIndex.value = key;
      emit2("update:modelValue", props.items[key].value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$5, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.items, (segment, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            class: normalizeClass([{ "cdek-segmented_button_checked": index === selectedIndex.value }, "cdek-segmented_button"]),
            onClick: ($event) => selectSegment($event, index)
          }, [
            createBaseVNode("input", {
              checked: index === selectedIndex.value,
              value: segment.value,
              class: "cdek-segmented_radio",
              type: "radio",
              onInput: ($event) => selectSegment($event, index)
            }, null, 40, _hoisted_3$4),
            createBaseVNode("div", _hoisted_4$4, [
              (openBlock(), createBlock(resolveDynamicComponent(segment.icon))),
              createBaseVNode("label", null, toDisplayString$1(segment.label), 1)
            ])
          ], 10, _hoisted_2$4);
        }), 128))
      ]);
    };
  }
});
const SegmentedControl_vue_vue_type_style_index_0_scoped_8747f95e_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const SegmentedControl = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-8747f95e"]]);
const _hoisted_1$4 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "11",
  height: "11",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  viewBox: "0 0 24 24"
};
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3$3 = /* @__PURE__ */ createBaseVNode("path", { d: "m5 12 5 5L20 7" }, null, -1);
const _hoisted_4$3 = [
  _hoisted_2$3,
  _hoisted_3$3
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4, _hoisted_4$3);
}
const CheckIcon = { render: render$1 };
const _hoisted_1$3 = ["checked"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "CheckboxItem",
  props: {
    label: {},
    disabled: { type: Boolean, default: false },
    modelValue: { type: [Boolean, null] }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const check = () => {
      if (props.disabled)
        return;
      emit2("update:modelValue", !props.modelValue);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "cdek-checkbox-item_checked": props.modelValue, disabled: props.disabled }, "cdek-checkbox-item"]),
        onClick: check
      }, [
        createBaseVNode("input", {
          checked: props.modelValue || false,
          type: "checkbox",
          onInput: check
        }, null, 40, _hoisted_1$3),
        createBaseVNode("span", null, [
          createVNode(unref(CheckIcon))
        ]),
        createBaseVNode("label", null, toDisplayString$1(props.label), 1)
      ], 2);
    };
  }
});
const CheckboxItem_vue_vue_type_style_index_0_scoped_7bc5a995_lang = "";
const CheckboxItem = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-7bc5a995"]]);
const _withScopeId = (n2) => (pushScopeId("data-v-bf2fa578"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$2 = { class: "cdek-radio" };
const _hoisted_2$2 = ["onClick"];
const _hoisted_3$2 = ["checked", "value", "onInput"];
const _hoisted_4$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", null, null, -1));
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "RadioButton",
  props: {
    modelValue: {},
    disabled: { type: Boolean, default: false },
    items: {}
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: emit2 }) {
    const props = __props;
    const selectedIndex = ref(0);
    props.items.forEach((e, i) => e.value === props.modelValue ? selectedIndex.value = i : "");
    watch(
      () => props.modelValue,
      () => {
        props.items.forEach((e, i) => e.value === props.modelValue ? selectedIndex.value = i : "");
      }
    );
    const selectSegment = (key) => {
      if (props.disabled || unref(selectedIndex) === key) {
        return;
      }
      selectedIndex.value = key;
      emit2("update:modelValue", props.items[key].value);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(props.items, (segment, index) => {
          return openBlock(), createElementBlock("div", {
            key: index,
            onClick: ($event) => selectSegment(index)
          }, [
            createBaseVNode("input", {
              checked: index === selectedIndex.value,
              value: segment.value,
              type: "radio",
              onInput: ($event) => selectSegment(index)
            }, null, 40, _hoisted_3$2),
            createBaseVNode("div", {
              class: normalizeClass([{
                "cdek-radio_label_checked": index === selectedIndex.value,
                disabled: props.disabled
              }, "cdek-radio_label"])
            }, [
              _hoisted_4$2,
              createBaseVNode("label", null, toDisplayString$1(segment.label), 1)
            ], 2)
          ], 8, _hoisted_2$2);
        }), 128))
      ]);
    };
  }
});
const RadioButton_vue_vue_type_style_index_0_scoped_bf2fa578_lang = "";
const RadioButton = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-bf2fa578"]]);
const _hoisted_1$1 = { class: "twc-text-stone-700 twc-w-44" };
const _hoisted_2$1 = { class: "twc-text-lg twc-font-bold twc-text-center" };
const _hoisted_3$1 = { class: "twc-text-sm" };
const _hoisted_4$1 = {
  key: 3,
  class: "twc-w-full twc-border-t-2 twc-mt-1"
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "FilterComponent",
  props: {
    searchStore: {},
    coreStore: {},
    t: { type: Function }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("h1", _hoisted_2$1, toDisplayString$1(_ctx.t("filters.title")), 1),
        createBaseVNode("div", _hoisted_3$1, [
          !_ctx.searchStore.hideFilters.have_cash ? (openBlock(), createBlock(CheckboxItem, {
            key: 0,
            label: _ctx.t("filters.cash"),
            "model-value": _ctx.searchStore.filters.have_cash,
            disabled: _ctx.coreStore.params.forceFilters.have_cash !== null,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchStore.$patch({ filters: { ..._ctx.searchStore.filters, have_cash: $event ? true : null } }))
          }, null, 8, ["label", "model-value", "disabled"])) : createCommentVNode("", true),
          !_ctx.searchStore.hideFilters.have_cashless ? (openBlock(), createBlock(CheckboxItem, {
            key: 1,
            label: _ctx.t("filters.cashless"),
            "model-value": _ctx.searchStore.filters.have_cashless,
            disabled: _ctx.coreStore.params.forceFilters.have_cashless !== null,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.searchStore.$patch({ filters: { ..._ctx.searchStore.filters, have_cashless: $event ? true : null } }))
          }, null, 8, ["label", "model-value", "disabled"])) : createCommentVNode("", true),
          !_ctx.searchStore.hideFilters.is_dressing_room ? (openBlock(), createBlock(CheckboxItem, {
            key: 2,
            label: _ctx.t("filters.dress"),
            "model-value": _ctx.searchStore.filters.is_dressing_room,
            disabled: _ctx.coreStore.params.forceFilters.is_dressing_room !== null,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.searchStore.$patch({ filters: { ..._ctx.searchStore.filters, is_dressing_room: $event ? true : null } }))
          }, null, 8, ["label", "model-value", "disabled"])) : createCommentVNode("", true),
          !_ctx.searchStore.hideFilters.type ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
            createVNode(RadioButton, {
              items: [
                { label: _ctx.t("filters.type.all"), value: unref(OfficeType).ALL },
                { label: _ctx.t("filters.type.pickup"), value: unref(OfficeType).PICKUP },
                { label: _ctx.t("filters.type.office"), value: unref(OfficeType).OFFICE }
              ],
              "model-value": _ctx.searchStore.filters.type,
              disabled: _ctx.coreStore.params.forceFilters.type !== null,
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.searchStore.$patch({ filters: { ..._ctx.searchStore.filters, type: $event } }))
            }, null, 8, ["items", "model-value", "disabled"])
          ])) : createCommentVNode("", true)
        ])
      ]);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "MapComponent",
  async setup(__props) {
    let __temp, __restore;
    const mapStorage = map();
    const searchStorage = search();
    const coreStorage = core();
    const reactify = ([__temp, __restore] = withAsyncContext(() => mapStorage.waitForMap()), __temp = await __temp, __restore(), __temp).reactify.bindTo(React, ReactDOM);
    const {
      YMap,
      YMapDefaultSchemeLayer,
      YMapDefaultFeaturesLayer,
      YMapControls,
      YMapControlButton,
      YMapControlCommonButton,
      YMapMarker,
      YMapListener
    } = reactify.module(ymaps3);
    const { YMapZoomControl, YMapGeolocationControl } = reactify.module(
      ([__temp, __restore] = withAsyncContext(() => ymaps3.import("@yandex/ymaps3-controls@0.0.1")), __temp = await __temp, __restore(), __temp)
    );
    const { YMapClusterer, clusterByGrid } = reactify.module(([__temp, __restore] = withAsyncContext(() => ymaps3.import("@yandex/ymaps3-clusterer@0.0.1")), __temp = await __temp, __restore(), __temp));
    const CDEKMap = applyPureReactInVue(
      Map$1(
        YMap,
        YMapDefaultSchemeLayer,
        YMapDefaultFeaturesLayer,
        YMapControls,
        YMapControlButton,
        YMapControlCommonButton,
        YMapZoomControl,
        YMapGeolocationControl,
        YMapListener,
        YMapMarker,
        YMapClusterer,
        clusterByGrid
      )
    );
    const { t: t2 } = useI18n({ useScope: "global" });
    const location = ref(mapStorage.location);
    const points = computed(
      () => mapStorage.offices.map((e, i) => ({
        type: "Feature",
        id: i,
        geometry: { coordinates: e.location },
        properties: e
      }))
    );
    watch(mapStorage.location, () => {
      location.value = { ...mapStorage.location };
    });
    const updateMode = (mode) => {
      if (coreStorage.debug)
        console.debug("[CDEK] changed delivery mode via selector");
      coreStorage.$patch({ mode, selectedTariff: null, selected: false });
    };
    const availableModels = computed(
      () => [
        {
          label: t2(coreStorage.params.sender ? "filters.mode.sender.office" : "filters.mode.receiver.office"),
          value: DeliveryMode.OFFICE,
          icon: OfficePriceSvg
        },
        {
          label: t2(coreStorage.params.sender ? "filters.mode.sender.door" : "filters.mode.receiver.door"),
          value: DeliveryMode.DOOR,
          icon: DeliveryPriceSvg
        }
      ].filter(
        (e) => !coreStorage.params.hideDeliveryOptions[e.value]
      )
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VueProviderForReact), null, {
        default: withCtx(() => [
          createVNode(unref(CDEKMap), {
            location: location.value,
            points: points.value
          }, {
            support: withCtx(() => [
              createVNode(_sfc_main$9, {
                "core-store": unref(coreStorage),
                t: unref(t2)
              }, null, 8, ["core-store", "t"])
            ]),
            search: withCtx(() => [
              createVNode(_sfc_main$5, {
                "core-store": unref(coreStorage),
                "map-store": unref(mapStorage),
                "search-store": unref(searchStorage),
                t: unref(t2)
              }, null, 8, ["core-store", "map-store", "search-store", "t"])
            ]),
            delivery: withCtx(() => [
              createVNode(SegmentedControl, {
                items: availableModels.value,
                "model-value": unref(coreStorage).mode,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => updateMode($event))
              }, null, 8, ["items", "model-value"])
            ]),
            filter: withCtx(() => [
              createVNode(_sfc_main$1, {
                t: unref(t2),
                "search-store": unref(searchStorage),
                "core-store": unref(coreStorage)
              }, null, 8, ["t", "search-store", "core-store"])
            ]),
            _: 1
          }, 8, ["location", "points"])
        ]),
        _: 1
      });
    };
  }
});
const app = /* @__PURE__ */ defineComponent(() => {
  const coreStorage = core();
  const mapStorage = storeToRefs(map());
  return () => createVNode("div", {
    "class": "twc-w-full twc-h-full twc-relative"
  }, [coreStorage.uiLoadLocksCounter > 0 ? createVNode(LoaderComponent, null, null) : "", mapStorage.mapLoadError.value === null ? createVNode(Suspense, null, {
    default: () => [createVNode(_sfc_main, null, null)]
  }) : createVNode(ErrorMessageComponent, null, null)]);
});
const _hoisted_1 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "none",
  stroke: "currentColor",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2"
};
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("path", {
  stroke: "none",
  d: "M0 0h24v24H0z"
}, null, -1);
const _hoisted_3 = /* @__PURE__ */ createBaseVNode("path", { d: "M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5zM9 9l6 6m0-6-6 6" }, null, -1);
const _hoisted_4 = [
  _hoisted_2,
  _hoisted_3
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1, _hoisted_4);
}
const SquareClose = { render };
const popup = /* @__PURE__ */ defineComponent(() => {
  const coreStorage = core();
  return () => coreStorage.globalPopup ? createVNode("div", {
    "class": "twc-fixed twc-z-[99999] twc-bg-black/50 twc-top-0 twc-bottom-0 twc-left-0 twc-right-0 twc-grid twc-items-center twc-justify-items-center"
  }, [createVNode("div", {
    "class": "twc-bg-white twc-p-5 twc-rounded-md twc-relative"
  }, [createVNode("a", {
    "class": "twc-absolute twc-right-2 twc-top-2 twc-z-[99999] twc-cursor-pointer",
    "onClick": () => coreStorage.closeWidget()
  }, [createVNode(SquareClose, null, null)]), createVNode("div", {
    "class": "twc-w-[800px] twc-h-[600px]"
  }, [createVNode(app, null, null)])])]) : "";
});
const pinia = createPinia();
function tap(value, interceptor) {
  interceptor(value);
  return value;
}
const rus = {
  support: {
    hint: "",
    title: " ",
    text: "    ,     "
  },
  search: {
    title: "",
    clear: "",
    notFound: "  ",
    loading: " ...",
    office: " ",
    region: "  ",
    door: " "
  },
  menu: {
    title: " "
  },
  filters: {
    hint: " ",
    title: "",
    cashless: " ",
    cash: " ",
    dress: " ",
    type: {
      all: "",
      office: " ",
      pickup: " "
    },
    mode: {
      sender: {
        door: " ",
        office: " "
      },
      receiver: {
        door: " ",
        office: " "
      }
    }
  },
  office: {
    address: "   ",
    workingTime: " ",
    code: " ",
    priceError: "   "
  },
  tariffs: {
    title: "",
    days: " |  |  | ",
    select: "",
    selected: "",
    needExactAddress: "  "
  },
  error: "     "
};
const eng = {
  support: {
    hint: "Support",
    title: "Support service",
    text: "If you have any questions, you can ask them to our specialists"
  },
  search: {
    title: "Search",
    clear: "Clear",
    notFound: "Nothing found",
    loading: "Searching...",
    office: "CDEK Office",
    region: "Region at the map",
    door: "Delivery address"
  },
  menu: {
    title: "CDEK Offices"
  },
  filters: {
    hint: "Open filters",
    title: "Filters",
    cashless: "Card payment",
    cash: "Cash payment",
    dress: "Have dressing room",
    type: {
      all: "ALL",
      office: "Offices only",
      pickup: "Pickup points only"
    },
    mode: {
      sender: {
        door: "From Door",
        office: "From Office"
      },
      receiver: {
        door: "To Door",
        office: "To Office"
      }
    }
  },
  office: {
    address: "Office address",
    workingTime: "Office working time",
    code: "Office code",
    priceError: "There was a problem during cost calculation"
  },
  tariffs: {
    title: "Tariffs",
    days: "days | day | days",
    select: "Select",
    selected: "Selected",
    needExactAddress: "Please, select exact address"
  },
  error: "Can't load map due to critical error"
};
const ruPluralization = (choice, choicesLength, _orgRule) => {
  if (choice === 0) {
    return 0;
  }
  const teen = choice > 10 && choice < 20;
  const endsWithOne = choice % 10 === 1;
  if (!teen && endsWithOne) {
    return 1;
  }
  if (!teen && choice % 10 >= 2 && choice % 10 <= 4) {
    return 2;
  }
  return choicesLength < 4 ? 2 : 3;
};
const i18n = (locale = Lang.RUS) => createI18n({
  locale: locale.toString(),
  legacy: false,
  globalInjection: true,
  messages: { rus, eng },
  pluralizationRules: {
    rus: ruPluralization
  }
});
function Cache(maxSize) {
  this._maxSize = maxSize;
  this.clear();
}
Cache.prototype.clear = function() {
  this._size = 0;
  this._values = /* @__PURE__ */ Object.create(null);
};
Cache.prototype.get = function(key) {
  return this._values[key];
};
Cache.prototype.set = function(key, value) {
  this._size >= this._maxSize && this.clear();
  if (!(key in this._values))
    this._size++;
  return this._values[key] = value;
};
var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
var propertyExpr = {
  Cache,
  split,
  normalizePath,
  setter: function(path) {
    var parts = normalizePath(path);
    return setCache.get(path) || setCache.set(path, function setter(obj, value) {
      var index = 0;
      var len = parts.length;
      var data = obj;
      while (index < len - 1) {
        var part = parts[index];
        if (part === "__proto__" || part === "constructor" || part === "prototype") {
          return obj;
        }
        data = data[parts[index++]];
      }
      data[parts[index]] = value;
    });
  },
  getter: function(path, safe) {
    var parts = normalizePath(path);
    return getCache.get(path) || getCache.set(path, function getter(data) {
      var index = 0, len = parts.length;
      while (index < len) {
        if (data != null || !safe)
          data = data[parts[index++]];
        else
          return;
      }
      return data;
    });
  },
  join: function(segments) {
    return segments.reduce(function(path, part) {
      return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
    }, "");
  },
  forEach: function(path, cb2, thisArg) {
    forEach$1(Array.isArray(path) ? path : split(path), cb2, thisArg);
  }
};
function normalizePath(path) {
  return pathCache.get(path) || pathCache.set(
    path,
    split(path).map(function(part) {
      return part.replace(CLEAN_QUOTES_REGEX, "$2");
    })
  );
}
function split(path) {
  return path.match(SPLIT_REGEX) || [""];
}
function forEach$1(parts, iter, thisArg) {
  var len = parts.length, part, idx, isArray2, isBracket;
  for (idx = 0; idx < len; idx++) {
    part = parts[idx];
    if (part) {
      if (shouldBeQuoted(part)) {
        part = '"' + part + '"';
      }
      isBracket = isQuoted(part);
      isArray2 = !isBracket && /^\d+$/.test(part);
      iter.call(thisArg, part, isBracket, isArray2, idx, parts);
    }
  }
}
function isQuoted(str) {
  return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
}
function hasLeadingNumber(part) {
  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
}
function hasSpecialChars(part) {
  return SPEC_CHAR_REGEX.test(part);
}
function shouldBeQuoted(part) {
  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
}
const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
const words = (str) => str.match(reWords) || [];
const upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
const join = (str, d) => words(str).join(d).toLowerCase();
const camelCase = (str) => words(str).reduce(
  (acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`,
  ""
);
const pascalCase = (str) => upperFirst(camelCase(str));
const snakeCase = (str) => join(str, "_");
const kebabCase = (str) => join(str, "-");
const sentenceCase = (str) => upperFirst(join(str, " "));
const titleCase = (str) => words(str).map(upperFirst).join(" ");
var tinyCase = {
  words,
  upperFirst,
  camelCase,
  pascalCase,
  snakeCase,
  kebabCase,
  sentenceCase,
  titleCase
};
var toposort$2 = { exports: {} };
toposort$2.exports = function(edges) {
  return toposort(uniqueNodes(edges), edges);
};
toposort$2.exports.array = toposort;
function toposort(nodes, edges) {
  var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
  edges.forEach(function(edge) {
    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
      throw new Error("Unknown node. There is an unknown node in the supplied edges.");
    }
  });
  while (i--) {
    if (!visited[i])
      visit(nodes[i], i, /* @__PURE__ */ new Set());
  }
  return sorted;
  function visit(node, i2, predecessors) {
    if (predecessors.has(node)) {
      var nodeRep;
      try {
        nodeRep = ", node was:" + JSON.stringify(node);
      } catch (e) {
        nodeRep = "";
      }
      throw new Error("Cyclic dependency" + nodeRep);
    }
    if (!nodesHash.has(node)) {
      throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
    }
    if (visited[i2])
      return;
    visited[i2] = true;
    var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
    outgoing = Array.from(outgoing);
    if (i2 = outgoing.length) {
      predecessors.add(node);
      do {
        var child = outgoing[--i2];
        visit(child, nodesHash.get(child), predecessors);
      } while (i2);
      predecessors.delete(node);
    }
    sorted[--cursor] = node;
  }
}
function uniqueNodes(arr) {
  var res = /* @__PURE__ */ new Set();
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    res.add(edge[0]);
    res.add(edge[1]);
  }
  return Array.from(res);
}
function makeOutgoingEdges(arr) {
  var edges = /* @__PURE__ */ new Map();
  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    if (!edges.has(edge[0]))
      edges.set(edge[0], /* @__PURE__ */ new Set());
    if (!edges.has(edge[1]))
      edges.set(edge[1], /* @__PURE__ */ new Set());
    edges.get(edge[0]).add(edge[1]);
  }
  return edges;
}
function makeNodesHash(arr) {
  var res = /* @__PURE__ */ new Map();
  for (var i = 0, len = arr.length; i < len; i++) {
    res.set(arr[i], i);
  }
  return res;
}
var toposortExports = toposort$2.exports;
const toposort$1 = /* @__PURE__ */ getDefaultExportFromCjs(toposortExports);
const toString$1 = Object.prototype.toString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val)
    return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false)
    return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "string")
    return quoteStrings ? `"${val}"` : val;
  if (typeOf === "function")
    return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol")
    return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString$1.call(val).slice(8, -1);
  if (tag === "Date")
    return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error)
    return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp")
    return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null)
      return result2;
    return value2;
  }, 2);
}
function toArray$1(value) {
  return value == null ? [] : [].concat(value);
}
let strReg = /\$\{\s*(\w+)\s*\}/g;
class ValidationError extends Error {
  static formatError(message, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path)
      params = Object.assign({}, params, {
        path
      });
    if (typeof message === "string")
      return message.replace(strReg, (_, key) => printValue(params[key]));
    if (typeof message === "function")
      return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type) {
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.errors = void 0;
    this.params = void 0;
    this.inner = void 0;
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray$1(errorOrErrors).forEach((err) => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        this.inner = this.inner.concat(err.inner.length ? err.inner : err);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ValidationError);
  }
}
let mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
    return type !== "mixed" ? `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
  }
};
let string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
let number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
let date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
let boolean = {
  isValue: "${path} field must be ${value}"
};
let object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
let array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean
});
const isSchema = (obj) => obj && obj.__isYupSchema__;
class Condition {
  static fromOptions(refs, config2) {
    if (!config2.then && !config2.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is,
      then,
      otherwise
    } = config2;
    let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
    return new Condition(refs, (values, schema) => {
      var _branch;
      let branch = check(...values) ? then : otherwise;
      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values = this.refs.map((ref2) => (
      // TODO: ? operator here?
      ref2.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
    ));
    let schema = this.fn(values, base, options);
    if (schema === void 0 || // @ts-ignore this can be base
    schema === base) {
      return base;
    }
    if (!isSchema(schema))
      throw new TypeError("conditions must return a schema object");
    return schema.resolve(options);
  }
}
const prefixes = {
  context: "$",
  value: "."
};
class Reference {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string")
      throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && propertyExpr.getter(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter)
      result = this.getter(result || {});
    if (this.map)
      result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
}
Reference.prototype.__isYupRef = true;
const isAbsent = (value) => value == null;
function createValidation(config2) {
  function validate({
    value,
    path = "",
    options,
    originalValue,
    schema
  }, panic, next) {
    const {
      name,
      test,
      params,
      message,
      skipAbsent
    } = config2;
    let {
      parent,
      context,
      abortEarly = schema.spec.abortEarly
    } = options;
    function resolve2(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      const nextParams = Object.assign({
        value,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path,
        spec: schema.spec
      }, params, overrides.params);
      for (const key of Object.keys(nextParams))
        nextParams[key] = resolve2(nextParams[key]);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
      error.params = nextParams;
      return error;
    }
    const invalid = abortEarly ? panic : next;
    let ctx = {
      path,
      parent,
      type: name,
      from: options.from,
      createError,
      resolve: resolve2,
      options,
      originalValue,
      schema
    };
    const handleResult = (validOrError) => {
      if (ValidationError.isError(validOrError))
        invalid(validOrError);
      else if (!validOrError)
        invalid(createError());
      else
        next(null);
    };
    const handleError2 = (err) => {
      if (ValidationError.isError(err))
        invalid(err);
      else
        panic(err);
    };
    const shouldSkip = skipAbsent && isAbsent(value);
    if (!options.sync) {
      try {
        Promise.resolve(!shouldSkip ? test.call(ctx, value, ctx) : true).then(handleResult, handleError2);
      } catch (err) {
        handleError2(err);
      }
      return;
    }
    let result;
    try {
      var _result;
      result = !shouldSkip ? test.call(ctx, value, ctx) : true;
      if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
        throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
      }
    } catch (err) {
      handleError2(err);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config2;
  return validate;
}
function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path)
    return {
      parent,
      parentPath: path,
      schema
    };
  propertyExpr.forEach(path, (_part, isBracket, isArray2) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    let isTuple = schema.type === "tuple";
    let idx = isArray2 ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray2)
        throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }
    if (!isArray2) {
      if (!schema.fields || !schema.fields[part])
        throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
class ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve2) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve2(item));
    }
    return result;
  }
  clone() {
    return new ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.forEach((value) => next.add(value));
    removeItems.forEach((value) => next.delete(value));
    return next;
  }
}
function clone(src, seen = /* @__PURE__ */ new Map()) {
  if (isSchema(src) || !src || typeof src !== "object")
    return src;
  if (seen.has(src))
    return seen.get(src);
  let copy;
  if (src instanceof Date) {
    copy = new Date(src.getTime());
    seen.set(src, copy);
  } else if (src instanceof RegExp) {
    copy = new RegExp(src);
    seen.set(src, copy);
  } else if (Array.isArray(src)) {
    copy = new Array(src.length);
    seen.set(src, copy);
    for (let i = 0; i < src.length; i++)
      copy[i] = clone(src[i], seen);
  } else if (src instanceof Map) {
    copy = /* @__PURE__ */ new Map();
    seen.set(src, copy);
    for (const [k2, v2] of src.entries())
      copy.set(k2, clone(v2, seen));
  } else if (src instanceof Set) {
    copy = /* @__PURE__ */ new Set();
    seen.set(src, copy);
    for (const v2 of src)
      copy.add(clone(v2, seen));
  } else if (src instanceof Object) {
    copy = {};
    seen.set(src, copy);
    for (const [k2, v2] of Object.entries(src))
      copy[k2] = clone(v2, seen);
  } else {
    throw Error(`Unable to clone ${src}`);
  }
  return copy;
}
class Schema {
  constructor(options) {
    this.type = void 0;
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this.internalTests = {};
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this._typeCheck = void 0;
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? void 0 : options.spec);
    this.withMutation((s) => {
      s.nonNullable();
    });
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec)
        Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeCheck = this._typeCheck;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.internalTests = Object.assign({}, this.internalTests);
    next.exclusiveTests = Object.assign({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone(Object.assign({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0)
      return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  withMutation(fn) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this)
      return this;
    if (schema.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;
    combined.withMutation((next) => {
      schema.tests.forEach((fn) => {
        next.test(fn.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v2) {
    if (v2 == null) {
      if (this.spec.nullable && v2 === null)
        return true;
      if (this.spec.optional && v2 === void 0)
        return true;
      return false;
    }
    return this._typeCheck(v2);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive
    });
  }
  /**
   * Run the configured transform pipeline over an input value.
   */
  cast(value, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value
    }, options));
    let allowOptionality = options.assert === "ignore-optionality";
    let result = resolvedSchema._cast(value, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault(options);
    }
    return value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      path,
      originalValue = _value,
      strict = this.spec.strict
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test of Object.values(this.internalTests)) {
      if (test)
        initialTests.push(test);
    }
    this.runTests({
      path,
      value,
      originalValue,
      options,
      tests: initialTests
    }, panic, (initialErrors) => {
      if (initialErrors.length) {
        return next(initialErrors, value);
      }
      this.runTests({
        path,
        value,
        originalValue,
        options,
        tests: this.tests
      }, panic, next);
    });
  }
  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(runOptions, panic, next) {
    let fired = false;
    let {
      tests,
      value,
      originalValue,
      path,
      options
    } = runOptions;
    let panicOnce = (arg) => {
      if (fired)
        return;
      fired = true;
      panic(arg, value);
    };
    let nextOnce = (arg) => {
      if (fired)
        return;
      fired = true;
      next(arg, value);
    };
    let count = tests.length;
    let nestedErrors = [];
    if (!count)
      return nextOnce([]);
    let args = {
      value,
      originalValue,
      path,
      options,
      schema: this
    };
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      test(args, panicOnce, function finishTestRun(err) {
        if (err) {
          nestedErrors = nestedErrors.concat(err);
        }
        if (--count <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k2 = key != null ? key : index;
    if (k2 == null) {
      throw TypeError("Must include `key` or `index` for nested validations");
    }
    const isIndex = typeof k2 === "number";
    let value = parent[k2];
    const testOptions = Object.assign({}, options, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: true,
      parent,
      value,
      originalValue: originalParent[k2],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: void 0,
      // index: undefined,
      [isIndex ? "index" : "key"]: k2,
      path: isIndex || k2.includes(".") ? `${parentPath || ""}[${value ? k2 : `"${k2}"`}]` : (parentPath ? `${parentPath}.` : "") + key
    });
    return (_, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
  }
  validate(value, options) {
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    return new Promise((resolve2, reject) => schema._validate(value, options, (error, parsed) => {
      if (ValidationError.isError(error))
        error.value = parsed;
      reject(error);
    }, (errors, validated) => {
      if (errors.length)
        reject(new ValidationError(errors, validated));
      else
        resolve2(validated);
    }));
  }
  validateSync(value, options) {
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let result;
    schema._validate(value, Object.assign({}, options, {
      sync: true
    }), (error, parsed) => {
      if (ValidationError.isError(error))
        error.value = parsed;
      throw error;
    }, (errors, validated) => {
      if (errors.length)
        throw new ValidationError(errors, value);
      result = validated;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, (err) => {
      if (ValidationError.isError(err))
        return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err))
        return false;
      throw err;
    }
  }
  _getDefault(options) {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone(defaultValue);
  }
  getDefault(options) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def2) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def2
    });
    return next;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message) {
    const next = this.clone({
      nullable
    });
    next.internalTests.nullable = createValidation({
      message,
      name: "nullable",
      test(value) {
        return value === null ? this.schema.spec.nullable : true;
      }
    });
    return next;
  }
  optionality(optional, message) {
    const next = this.clone({
      optional
    });
    next.internalTests.optionality = createValidation({
      message,
      name: "optionality",
      test(value) {
        return value === void 0 ? this.schema.spec.optional : true;
      }
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message = mixed.defined) {
    return this.optionality(false, message);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message = mixed.notNull) {
    return this.nullability(false, message);
  }
  required(message = mixed.required) {
    return this.clone().withMutation((next) => next.nonNullable(message).defined(message));
  }
  notRequired() {
    return this.clone().withMutation((next) => next.nullable().optional());
  }
  transform(fn) {
    let next = this.clone();
    next.transforms.push(fn);
    return next;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0)
      opts.message = mixed.default;
    if (typeof opts.test !== "function")
      throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name)
        throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name)
      next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn) => {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive)
          return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test)
          return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys, options) {
    if (!Array.isArray(keys) && typeof keys !== "string") {
      options = keys;
      keys = ".";
    }
    let next = this.clone();
    let deps = toArray$1(keys).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling)
        next.deps.push(dep.key);
    });
    next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next;
  }
  typeError(message) {
    let next = this.clone();
    next.internalTests.typeError = createValidation({
      message,
      name: "typeError",
      skipAbsent: true,
      test(value) {
        if (!this.schema._typeCheck(value))
          return this.createError({
            params: {
              type: this.schema.type
            }
          });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next.internalTests.whiteList = createValidation({
      message,
      name: "oneOf",
      skipAbsent: true,
      test(value) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: Array.from(valids).join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next.internalTests.blacklist = createValidation({
      message,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value))
          return this.createError({
            params: {
              values: Array.from(invalids).join(", "),
              resolved
            }
          });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional,
      nullable
    } = next.spec;
    const description = {
      meta,
      label,
      optional,
      nullable,
      default: next.getDefault(options),
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map((fn) => ({
        name: fn.OPTIONS.name,
        params: fn.OPTIONS.params
      })).filter((n2, idx, list) => list.findIndex((c) => c.name === n2.name) === idx)
    };
    return description;
  }
}
Schema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"])
  Schema.prototype[`${method}At`] = function(path, value, options = {}) {
    const {
      parent,
      parentPath,
      schema
    } = getIn(this, path, value, options.context);
    return schema[method](parent && parent[parentPath], Object.assign({}, options, {
      parent,
      path
    }));
  };
for (const alias of ["equals", "is"])
  Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ["not", "nope"])
  Schema.prototype[alias] = Schema.prototype.notOneOf;
const returnsTrue = () => true;
function create$8(spec) {
  return new MixedSchema(spec);
}
class MixedSchema extends Schema {
  constructor(spec) {
    super(typeof spec === "function" ? {
      type: "mixed",
      check: spec
    } : Object.assign({
      type: "mixed",
      check: returnsTrue
    }, spec));
  }
}
create$8.prototype = MixedSchema.prototype;
function create$7() {
  return new BooleanSchema();
}
class BooleanSchema extends Schema {
  constructor() {
    super({
      type: "boolean",
      check(v2) {
        if (v2 instanceof Boolean)
          v2 = v2.valueOf();
        return typeof v2 === "boolean";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (ctx.spec.coerce && !ctx.isType(value)) {
          if (/^(true|1)$/i.test(String(value)))
            return true;
          if (/^(false|0)$/i.test(String(value)))
            return false;
        }
        return value;
      });
    });
  }
  isTrue(message = boolean.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value) {
        return isAbsent(value) || value === true;
      }
    });
  }
  isFalse(message = boolean.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value) {
        return isAbsent(value) || value === false;
      }
    });
  }
  default(def2) {
    return super.default(def2);
  }
  defined(msg) {
    return super.defined(msg);
  }
  optional() {
    return super.optional();
  }
  required(msg) {
    return super.required(msg);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(msg) {
    return super.nonNullable(msg);
  }
  strip(v2) {
    return super.strip(v2);
  }
}
create$7.prototype = BooleanSchema.prototype;
let rEmail = (
  // eslint-disable-next-line
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
);
let rUrl = (
  // eslint-disable-next-line
  /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
);
let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
let isTrimmed = (value) => isAbsent(value) || value === value.trim();
let objStringTag = {}.toString();
function create$6() {
  return new StringSchema();
}
class StringSchema extends Schema {
  constructor() {
    super({
      type: "string",
      check(value) {
        if (value instanceof String)
          value = value.valueOf();
        return typeof value === "string";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value))
          return value;
        if (Array.isArray(value))
          return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag)
          return value;
        return strValue;
      });
    });
  }
  required(message) {
    return super.required(message).withMutation((schema) => schema.test({
      message: message || mixed.required,
      name: "required",
      skipAbsent: true,
      test: (value) => !!value.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((schema) => {
      schema.tests = schema.tests.filter((t2) => t2.OPTIONS.name !== "required");
      return schema;
    });
  }
  length(length, message = string.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message = string.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message;
    let name;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message,
          name
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name || "matches",
      message: message || string.matches,
      params: {
        regex
      },
      skipAbsent: true,
      test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message,
      excludeEmptyString: true
    });
  }
  url(message = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message,
      excludeEmptyString: false
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message = string.lowercase) {
    return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message = string.uppercase) {
    return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toUpperCase()
    });
  }
}
create$6.prototype = StringSchema.prototype;
let isNaN$1 = (value) => value != +value;
function create$5() {
  return new NumberSchema();
}
class NumberSchema extends Schema {
  constructor() {
    super({
      type: "number",
      check(value) {
        if (value instanceof Number)
          value = value.valueOf();
        return typeof value === "number" && !isNaN$1(value);
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce)
          return value;
        let parsed = value;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "")
            return NaN;
          parsed = +parsed;
        }
        if (ctx.isType(parsed) || parsed === null)
          return parsed;
        return parseFloat(parsed);
      });
    });
  }
  min(min, message = number.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(min);
      }
    });
  }
  max(max, message = number.max) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(max);
      }
    });
  }
  lessThan(less, message = number.lessThan) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      skipAbsent: true,
      test(value) {
        return value < this.resolve(less);
      }
    });
  }
  moreThan(more, message = number.moreThan) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      skipAbsent: true,
      test(value) {
        return value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message = number.integer) {
    return this.test({
      name: "integer",
      message,
      skipAbsent: true,
      test: (val) => Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value) => !isAbsent(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
    if (method === "trunc")
      return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1)
      throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
  }
}
create$5.prototype = NumberSchema.prototype;
var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date2) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
  if (struct = isoReg.exec(date2)) {
    for (var i = 0, k2; k2 = numericKeys[i]; ++i)
      struct[k2] = +struct[k2] || 0;
    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1;
    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
    if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
      timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
    else {
      if (struct[8] !== "Z" && struct[9] !== void 0) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === "+")
          minutesOffset = 0 - minutesOffset;
      }
      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else
    timestamp = Date.parse ? Date.parse(date2) : NaN;
  return timestamp;
}
let invalidDate = /* @__PURE__ */ new Date("");
let isDate$1 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
class DateSchema extends Schema {
  constructor() {
    super({
      type: "date",
      check(v2) {
        return isDate$1(v2) && !isNaN(v2.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value) || value === null)
          return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref2, name) {
    let param;
    if (!Reference.isRef(ref2)) {
      let cast = this.cast(ref2);
      if (!this._typeCheck(cast))
        throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref2;
    }
    return param;
  }
  min(min, message = date.min) {
    let limit = this.prepareParam(min, "min");
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(limit);
      }
    });
  }
  max(max, message = date.max) {
    let limit = this.prepareParam(max, "max");
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(limit);
      }
    });
  }
}
DateSchema.INVALID_DATE = invalidDate;
DateSchema.prototype;
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
  function addNode(depPath, key) {
    let node = propertyExpr.split(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`))
      edges.push([key, node]);
  }
  for (const key of Object.keys(fields)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling)
      addNode(value.path, key);
    else if (isSchema(value) && "deps" in value)
      value.deps.forEach((path) => addNode(path, key));
  }
  return toposort$1.array(Array.from(nodes), edges).reverse();
}
function findIndex(arr, err) {
  let idx = Infinity;
  arr.some((key, ii2) => {
    var _err$path;
    if ((_err$path = err.path) != null && _err$path.includes(key)) {
      idx = ii2;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys) {
  return (a, b) => {
    return findIndex(keys, a) - findIndex(keys, b);
  };
}
const parseJson = (value, _, ctx) => {
  if (typeof value !== "string") {
    return value;
  }
  let parsed = value;
  try {
    parsed = JSON.parse(value);
  } catch (err) {
  }
  return ctx.isType(parsed) ? parsed : value;
};
function deepPartial(schema) {
  if ("fields" in schema) {
    const partial = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial);
  }
  if (schema.type === "array") {
    const nextArray = schema.optional();
    if (nextArray.innerType)
      nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === "tuple") {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ("optional" in schema) {
    return schema.optional();
  }
  return schema;
}
const deepHas = (obj, p2) => {
  const path = [...propertyExpr.normalizePath(p2)];
  if (path.length === 1)
    return path[0] in obj;
  let last = path.pop();
  let parent = propertyExpr.getter(propertyExpr.join(path), true)(obj);
  return !!(parent && last in parent);
};
let isObject$1 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
const defaultSort = sortByKeyOrder([]);
function create$3(spec) {
  return new ObjectSchema(spec);
}
class ObjectSchema extends Schema {
  constructor(spec) {
    super({
      type: "object",
      check(value) {
        return isObject$1(value) || typeof value === "function";
      }
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);
    if (value === void 0)
      return this.getDefault(options);
    if (!this._typeCheck(value))
      return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value).filter((v2) => !this._nodes.includes(v2)));
    let intermediateValue = {};
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = prop in value;
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      from = [],
      originalValue = _value,
      recursive = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from];
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value) => {
      if (!recursive || !isObject$1(value)) {
        next(objectErrors, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value,
        originalValue,
        options
      }, panic, (fieldErrors) => {
        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
      });
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = Object.assign({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === void 0 ? schemaOrRef : target;
    }
    return next.withMutation((s) => (
      // XXX: excludes here is wrong
      s.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
    ));
  }
  _getDefault(options) {
    if ("default" in this.spec) {
      return super._getDefault(options);
    }
    if (!this._nodes.length) {
      return void 0;
    }
    let dft = {};
    this._nodes.forEach((key) => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
    });
    return dft;
  }
  setFields(shape, excludedEdges) {
    let next = this.clone();
    next.fields = shape;
    next._nodes = sortFields(shape, excludedEdges);
    next._sortErrors = sortByKeyOrder(Object.keys(shape));
    if (excludedEdges)
      next._excludedEdges = excludedEdges;
    return next;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation((next) => {
      let edges = next._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0]))
          excludes = [excludes];
        edges = [...next._excludedEdges, ...excludes];
      }
      return next.setFields(Object.assign(next.fields, additions), edges);
    });
  }
  partial() {
    const partial = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial);
  }
  deepPartial() {
    const next = deepPartial(this);
    return next;
  }
  pick(keys) {
    const picked = {};
    for (const key of keys) {
      if (this.fields[key])
        picked[key] = this.fields[key];
    }
    return this.setFields(picked);
  }
  omit(keys) {
    const fields = Object.assign({}, this.fields);
    for (const key of keys) {
      delete fields[key];
    }
    return this.setFields(fields);
  }
  from(from, to, alias) {
    let fromGetter = propertyExpr.getter(from, true);
    return this.transform((obj) => {
      if (!obj)
        return obj;
      let newObj = obj;
      if (deepHas(obj, from)) {
        newObj = Object.assign({}, obj);
        if (!alias)
          delete newObj[from];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  noUnknown(noAllow = true, message = object.noUnknown) {
    if (typeof noAllow !== "boolean") {
      message = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message,
      test(value) {
        if (value == null)
          return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message = object.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn) {
    return this.transform((obj) => {
      if (!obj)
        return obj;
      const result = {};
      for (const key of Object.keys(obj))
        result[fn(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(tinyCase.camelCase);
  }
  snakeCase() {
    return this.transformKeys(tinyCase.snakeCase);
  }
  constantCase() {
    return this.transformKeys((key) => tinyCase.snakeCase(key).toUpperCase());
  }
  describe(options) {
    let base = super.describe(options);
    base.fields = {};
    for (const [key, value] of Object.entries(this.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value.describe(innerOptions);
    }
    return base;
  }
}
create$3.prototype = ObjectSchema.prototype;
function create$2(type) {
  return new ArraySchema(type);
}
class ArraySchema extends Schema {
  constructor(type) {
    super({
      type: "array",
      spec: {
        types: type
      },
      check(v2) {
        return Array.isArray(v2);
      }
    });
    this.innerType = void 0;
    this.innerType = type;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);
    if (!this._typeCheck(value) || !this.innerType) {
      return value;
    }
    let isChanged = false;
    const castArray = value.map((v2, idx) => {
      const castElement = this.innerType.cast(v2, Object.assign({}, _opts, {
        path: `${_opts.path || ""}[${idx}]`
      }));
      if (castElement !== v2) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    var _options$recursive;
    let innerType = this.innerType;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    options.originalValue != null ? options.originalValue : _value;
    super._validate(_value, options, panic, (arrayErrors, value) => {
      var _options$originalValu2;
      if (!recursive || !innerType || !this._typeCheck(value)) {
        next(arrayErrors, value);
        return;
      }
      let tests = new Array(value.length);
      for (let index = 0; index < value.length; index++) {
        var _options$originalValu;
        tests[index] = innerType.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value));
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  concat(schema) {
    let next = super.concat(schema);
    next.innerType = this.innerType;
    if (schema.innerType)
      next.innerType = next.innerType ? (
        // @ts-expect-error Lazy doesn't have concat and will break
        next.innerType.concat(schema.innerType)
      ) : schema.innerType;
    return next;
  }
  of(schema) {
    let next = this.clone();
    if (!isSchema(schema))
      throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
    next.innerType = schema;
    next.spec = Object.assign({}, next.spec, {
      types: schema
    });
    return next;
  }
  length(length, message = array.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message) {
    message = message || array.min;
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      // FIXME(ts): Array<typeof T>
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message) {
    message = message || array.max;
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      if (this._typeCheck(val))
        return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v2) => !!v2 : (v2, i, a) => !rejector(v2, i, a);
    return this.transform((values) => values != null ? values.filter(reject) : values);
  }
  describe(options) {
    let base = super.describe(options);
    if (this.innerType) {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[0]
        });
      }
      base.innerType = this.innerType.describe(innerOptions);
    }
    return base;
  }
}
create$2.prototype = ArraySchema.prototype;
const widgetSchema = create$3({
  apiKey: create$6().required().default(config.map.defaultKey),
  // Legacy - apikey
  root: create$6().default("cdek-map").trim(),
  // Legacy - link
  sender: create$7().default(false),
  // No Legacy variant
  canChoose: create$7().default(true),
  // Legacy - choose
  popup: create$7().default(false),
  // Legacy - popup
  servicePath: create$6().default("/service.php"),
  // Legacy - servicepath
  hideFilters: create$3({
    have_cashless: create$7().default(false),
    // No Legacy variant
    have_cash: create$7().default(false),
    // Legacy - hidecash
    is_dressing_room: create$7().default(false),
    // Legacy - hidedress
    type: create$7().default(false)
    // No Legacy variant
  }),
  // No Legacy variant
  forceFilters: create$3({
    have_cashless: create$7().nullable().default(null),
    // No Legacy variant
    have_cash: create$7().nullable().default(null),
    // No Legacy variant
    is_dressing_room: create$7().nullable().default(null),
    // No Legacy variant
    type: create$6().nullable().oneOf(Object.values(OfficeType)).default(null),
    // No Legacy variant
    allowed_cod: create$7().nullable().default(null)
    // No Legacy variant
  }),
  // No Legacy variant
  hideDeliveryOptions: create$3({
    // Legacy - hidedelt
    [DeliveryMode.OFFICE]: create$7().default(false),
    // No Legacy variant
    [DeliveryMode.DOOR]: create$7().default(false)
    // No Legacy variant
  }),
  // No Legacy variant
  debug: create$7().default(false),
  // Legacy - showLogs
  offices: create$2().nullable().default(null),
  officesRaw: create$2().nullable().default(null),
  tariff: create$3({
    tariff_code: create$5(),
    tariff_name: create$6(),
    tariff_description: create$6(),
    delivery_mode: create$5(),
    period_min: create$5(),
    period_max: create$5(),
    delivery_sum: create$5()
  }).nullable().default(null),
  goods: create$2().required().ensure().of(
    create$3({
      width: create$5().required(),
      // Legacy - goods.width
      length: create$5().required(),
      // Legacy - goods.length
      height: create$5().required(),
      // Legacy - goods.height
      weight: create$5().required()
      // Legacy - goods.weight
    })
  ),
  // Legacy - goods
  from: create$6().nullable().default(null),
  // Legacy - from
  defaultLocation: create$8(
    (input) => Array.isArray(input) || typeof input === "string"
  ).required(),
  // Legacy - defaultCity
  lang: create$6().oneOf(Object.values(Lang)).default(Lang.RUS),
  // Legacy - lang
  currency: create$6().oneOf(Object.keys(Currency)).default("RUB"),
  // Legacy - currency
  tariffs: create$3({
    door: create$2().default([233, 137, 139, 16, 18, 11, 1, 3, 61, 60, 59, 58, 57, 83]),
    // Legacy - service.php
    office: create$2().default([234, 136, 138, 15, 17, 10, 12, 5, 62, 63]),
    // Legacy - service.php
    pickup: create$2().default([361, 363, 366, 368, 376, 378])
  }),
  onReady: create$8((input) => typeof input === "function").default(() => {
  }),
  onCalculate: create$8((input) => typeof input === "function").default(() => {
  }),
  onChoose: create$8((input) => typeof input === "function").default(() => {
  }),
  selected: create$3({
    door: create$6().nullable().default(null),
    office: create$6().nullable().default(null)
  })
});
const style = "";
class AbstractApi {
  cancelRequest(controller, method = "") {
    const coreStorage = core();
    if (controller !== null) {
      if (coreStorage.debug) {
        console.debug("[CDEK] Cancelling previous request " + method);
      }
      controller.abort();
    }
  }
}
function bind3(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind3(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError$1(message, code2, config2, request2, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config2 && (this.config = config2);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error, code2, config2, request2, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error.message, code2, config2, request2, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index) {
          !(utils.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el2, key) {
      const result = !(utils.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: platform.isNode ? "http" : "xhr",
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils.freezeMethods(AxiosHeaders$1);
const AxiosHeaders$2 = AxiosHeaders$1;
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders$2.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform2(fn) {
    data = fn.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config2, request2) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config2, request2);
  this.name = "CanceledError";
}
utils.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove2(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders$2.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData)) {
      if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else {
        requestHeaders.setContentType("multipart/form-data;", false);
      }
    }
    let request2 = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$2.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config2, request2));
      request2 = null;
    };
    request2.onerror = function handleError2() {
      reject(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config2, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitionalDefaults;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config2,
        request2
      ));
      request2 = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError$1(null, config2, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError$1("Unsupported protocol " + protocol + ":", AxiosError$1.ERR_BAD_REQUEST, config2));
      return;
    }
    request2.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError$1(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError$1(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$2.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$2.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$2.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$2 ? thing.toJSON() : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const VERSION$1 = "1.5.0";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig$1(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$2.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig$1(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
};
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig$1(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$2 = Axios$1;
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config2, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
const CancelToken$2 = CancelToken$1;
function spread$1(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
const HttpStatusCode$2 = HttpStatusCode$1;
function createInstance(defaultConfig) {
  const context = new Axios$2(defaultConfig);
  const instance = bind3(Axios$2.prototype.request, context);
  utils.extend(instance, Axios$2.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$2;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$2;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$2;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$2;
axios.default = axios;
const axios$1 = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios$1;
class YandexApi extends AbstractApi {
  constructor(apiKey, lang) {
    super();
    __publicField(this, "geocodeSrc");
    __publicField(this, "geocodeStringAbort");
    __publicField(this, "geocodeCoordinatesAbort");
    this.geocodeStringAbort = this.geocodeCoordinatesAbort = null;
    this.geocodeSrc = tap(new URL(`https://geocode-maps.yandex.ru/${config.map.geocoderVersion}/`), (url) => {
      url.searchParams.set("apikey", apiKey);
      url.searchParams.set("lang", lang);
    }).toString();
  }
  cancelGeocodeStringRequest() {
    this.cancelRequest(this.geocodeStringAbort, "geocodeString");
  }
  cancelGeocodeCoordinatesRequest() {
    this.cancelRequest(this.geocodeCoordinatesAbort, "geocodeCoordinates");
  }
  async geocodeString(input) {
    const coreStorage = core();
    if (input === "") {
      return {
        found: 0,
        members: []
      };
    }
    this.cancelGeocodeStringRequest();
    this.geocodeStringAbort = new AbortController();
    return await axios$1.get(this.geocodeSrc, {
      params: {
        geocode: input,
        format: "json"
      },
      signal: this.geocodeStringAbort.signal
    }).then((result) => {
      if (coreStorage.debug) {
        console.debug("[CDEK] Geocode string response", result.data);
      }
      return this.formatGeocodeResponse(result.data.response);
    }).catch((e) => {
      if (axios$1.isCancel(e)) {
        if (coreStorage.debug) {
          console.debug("[CDEK] Geocode string request cancelled");
        }
        throw e;
      }
      console.error("[CDEK] Geocode String error", e);
      return this.formatGeocodeResponse({
        GeoObjectCollection: {
          metaDataProperty: {
            GeocoderResponseMetaData: {
              found: 0
            }
          },
          featureMember: []
        }
      });
    });
  }
  async geocodeCoordinates(coordinates) {
    const coreStorage = core();
    this.cancelGeocodeCoordinatesRequest();
    this.geocodeCoordinatesAbort = new AbortController();
    return await axios$1.get(this.geocodeSrc, {
      params: {
        geocode: `${coordinates[0]}, ${coordinates[1]}`,
        format: "json"
      },
      signal: this.geocodeCoordinatesAbort.signal
    }).then((result) => {
      if (coreStorage.debug) {
        console.debug("[CDEK] Geocode coordinates response", result.data);
      }
      return this.formatGeocodeResponse(result.data.response);
    }).catch((e) => {
      if (axios$1.isCancel(e)) {
        if (coreStorage.debug) {
          console.debug("[CDEK] Geocode coordinates request cancelled");
        }
        throw e;
      }
      return this.formatGeocodeResponse({
        GeoObjectCollection: {
          metaDataProperty: {
            GeocoderResponseMetaData: {
              found: 0
            }
          },
          featureMember: []
        }
      });
    });
  }
  formatGeocodeResponse(result) {
    return {
      found: parseInt(result.GeoObjectCollection.metaDataProperty.GeocoderResponseMetaData.found),
      members: result.GeoObjectCollection.featureMember.map((el2) => ({
        position: el2.GeoObject.Point.pos.split(" ").map((e) => parseFloat(e)),
        name: el2.GeoObject.name,
        kind: el2.GeoObject.metaDataProperty.GeocoderMetaData.kind,
        precision: el2.GeoObject.metaDataProperty.GeocoderMetaData.precision,
        formatted: el2.GeoObject.metaDataProperty.GeocoderMetaData.Address.formatted,
        components: el2.GeoObject.metaDataProperty.GeocoderMetaData.Address.Components.map((el22) => ({
          kind: el22.kind,
          name: el22.name
        }))
      }))
    };
  }
}
class CdekApi extends AbstractApi {
  constructor(servicePath) {
    super();
    __publicField(this, "getOfficesAbort");
    __publicField(this, "getPriceAbort");
    __publicField(this, "servicePath");
    this.getOfficesAbort = this.getPriceAbort = null;
    this.servicePath = servicePath;
  }
  cancelOfficeRequest() {
    this.cancelRequest(this.getOfficesAbort, "offices");
  }
  cancelPriceRequest() {
    this.cancelRequest(this.getPriceAbort, "prices");
  }
  async getPrice(targetLocation) {
    const coreStorage = core();
    if (coreStorage.params.tariff) {
      if (coreStorage.debug) {
        console.debug("[CDEK] We have fixed price", coreStorage.params.tariff);
      }
      return this.mapTariffsWithTypes([coreStorage.params.tariff]);
    } else if (targetLocation === void 0) {
      throw new Error("No location and no fixed tariff was passed to price calc");
    }
    if (coreStorage.debug) {
      console.debug("[CDEK] Loading prices from service");
    }
    this.cancelPriceRequest();
    this.getPriceAbort = new AbortController();
    return await axios$1.post(
      this.servicePath,
      {
        currency: Currency[coreStorage.params.currency],
        lang: coreStorage.params.lang,
        from_location: {
          address: coreStorage.params.from
        },
        to_location: targetLocation,
        action: "calculate",
        packages: coreStorage.params.goods
      },
      {
        signal: this.getPriceAbort.signal
      }
    ).then((result) => {
      if (coreStorage.debug) {
        console.debug("[CDEK] Got prices from service", result.data.tariff_codes || []);
      }
      return this.mapTariffsWithTypes(result.data.tariff_codes || []);
    }).catch((e) => {
      if (axios$1.isCancel(e)) {
        if (coreStorage.debug) {
          console.debug("[CDEK] Price request cancelled");
        }
        throw e;
      }
      console.error("[CDEK] Service error", e);
      return this.mapTariffsWithTypes([]);
    });
  }
  async getOffices() {
    const searchStorage = search();
    const mapStorage = map();
    const coreStorage = core();
    searchStorage.loading = true;
    if (coreStorage.params.offices !== null || coreStorage.params.officesRaw !== null) {
      if (coreStorage.debug) {
        console.debug("[CDEK] Using points from widget initializer");
      }
      return this.loadLocalOffices();
    }
    if (coreStorage.debug) {
      console.debug("[CDEK] Loading points from service");
    }
    const additionalParams = {};
    if (coreStorage.params.sender) {
      additionalParams.is_handout_only = false;
      additionalParams.is_reception = true;
    } else {
      additionalParams.is_handout = true;
    }
    this.cancelOfficeRequest();
    this.getOfficesAbort = new AbortController();
    return await axios$1.get(this.servicePath, {
      params: {
        ...searchStorage.filters,
        ...additionalParams,
        action: "offices"
      },
      signal: this.getOfficesAbort.signal
    }).then((result) => {
      const response = typeof result.data === "string" ? JSON.parse(result.data) : result.data;
      if (coreStorage.debug) {
        console.debug("[CDEK] Got points", response);
      }
      mapStorage.mapState = YandexMapState.POINTS_LOADED;
      return this.formatOffices(response);
    }).catch((e) => {
      if (axios$1.isCancel(e)) {
        if (coreStorage.debug) {
          console.debug("[CDEK] Offices request cancelled");
        }
        throw e;
      }
      console.error("[CDEK] Service error", e);
      mapStorage.mapLoadError = YandexMapErrorCode.SERVICE_ERROR;
      return [];
    }).finally(() => searchStorage.loading = false);
  }
  formatOffices(offices) {
    return offices.map((e) => ({
      city_code: e.location.city_code,
      city: e.location.city,
      type: e.type,
      country_code: e.location.country_code,
      have_cashless: e.have_cashless,
      have_cash: e.have_cash,
      allowed_cod: e.allowed_cod,
      is_dressing_room: e.is_dressing_room,
      code: e.code,
      name: e.name,
      address: e.location.address,
      work_time: e.work_time,
      location: [e.location.longitude, e.location.latitude]
    }));
  }
  mapTariffsWithTypes(tariffs) {
    const coreStorage = core();
    const priceData = {
      office: [],
      door: [],
      pickup: []
    };
    tariffs.map((tariff) => {
      switch (tariff.delivery_mode) {
        case CdekDeliveryType.DOOR_DOOR:
        case CdekDeliveryType.OFFICE_DOOR:
        case CdekDeliveryType.PICKUP_DOOR:
          if (coreStorage.params.tariffs.door.length > 0 && coreStorage.params.tariffs.door.indexOf(tariff.tariff_code) !== -1) {
            priceData.door.push(tariff);
          }
          break;
        case CdekDeliveryType.DOOR_OFFICE:
        case CdekDeliveryType.OFFICE_OFFICE:
        case CdekDeliveryType.PICKUP_OFFICE:
          if (coreStorage.params.tariffs.office.length > 0 && coreStorage.params.tariffs.office.indexOf(tariff.tariff_code) !== -1) {
            priceData.office.push(tariff);
            if (coreStorage.params.tariffs.pickup.length > 0 && coreStorage.params.tariffs.pickup.indexOf(tariff.tariff_code) !== -1) {
              priceData.pickup.push(tariff);
            }
          }
          break;
        case CdekDeliveryType.DOOR_PICKUP:
        case CdekDeliveryType.OFFICE_PICKUP:
        case CdekDeliveryType.PICKUP_PICKUP:
          if (coreStorage.params.tariffs.pickup.length > 0 && coreStorage.params.tariffs.pickup.indexOf(tariff.tariff_code) !== -1) {
            priceData.pickup.push(tariff);
          }
          break;
      }
    });
    return priceData;
  }
  loadLocalOffices() {
    const searchStorage = search();
    const mapStorage = map();
    const coreStorage = core();
    mapStorage.mapState = YandexMapState.POINTS_LOADED;
    const offices = coreStorage.params.officesRaw ? this.formatOffices(coreStorage.params.officesRaw || []) : coreStorage.params.offices || [];
    return offices.filter(
      (office) => (searchStorage.filters.allowed_cod === null || office.allowed_cod === searchStorage.filters.allowed_cod) && (searchStorage.filters.type === null || searchStorage.filters.type === OfficeType.ALL || office.type === searchStorage.filters.type) && (searchStorage.filters.have_cash === null || office.have_cash === searchStorage.filters.have_cash) && (searchStorage.filters.have_cashless === null || office.have_cashless === searchStorage.filters.have_cashless) && (searchStorage.filters.is_dressing_room === null || office.is_dressing_room === searchStorage.filters.is_dressing_room)
    );
  }
}
class Widget {
  constructor(input) {
    __publicField(this, "yandexMapSrc");
    __publicField(this, "params");
    __publicField(this, "yandexApi");
    __publicField(this, "cdekApi");
    __publicField(this, "app");
    __publicField(this, "div");
    __publicField(this, "customDiv");
    this.params = widgetSchema.validateSync(input);
    let yandexLang;
    switch (this.params.lang) {
      default:
      case Lang.RUS:
        yandexLang = "ru_RU";
        break;
      case Lang.ENG:
        yandexLang = "en_US";
        break;
    }
    if (this.params.hideDeliveryOptions[DeliveryMode.OFFICE] && this.params.hideDeliveryOptions[DeliveryMode.DOOR]) {
      throw new Error("Can`t hide door delivery and office delivery at one time");
    }
    this.yandexMapSrc = tap(new URL(`https://api-maps.yandex.ru/${config.map.apiVersion}/`), (url) => {
      url.searchParams.set("apikey", this.params.apiKey);
      url.searchParams.set("lang", yandexLang);
    }).toString();
    this.yandexApi = new YandexApi(this.params.apiKey, yandexLang);
    this.cdekApi = new CdekApi(this.params.servicePath);
    const el2 = window.document.getElementById(this.params.root);
    if (el2 === null) {
      this.div = window.document.createElement("div");
      this.div.className = this.params.root;
      if (!this.params.popup) {
        this.div.style.width = "800px";
        this.div.style.height = "600px";
      }
      window.document.body.appendChild(this.div);
      this.customDiv = true;
    } else {
      this.div = el2;
      this.customDiv = false;
    }
    this.app = createApp(this.params.popup ? popup : app);
    this.app.use(pinia).use(i18n(this.params.lang)).mount(this.div);
    this.init().then();
  }
  async updateOffices(offices) {
    const coreStore = core();
    const mapStore = map();
    if (coreStore.debug) {
      console.debug("[CDEK] Force updating offices");
    }
    coreStore.$patch({
      params: { ...coreStore.params, offices }
    });
    mapStore.offices = await this.cdekApi.getOffices();
  }
  async updateTariff(tariff) {
    const coreStore = core();
    if (coreStore.debug) {
      console.debug("[CDEK] Force updating prices");
    }
    coreStore.$patch({
      params: { ...coreStore.params, tariff }
    });
    coreStore.tariffs = await this.cdekApi.getPrice();
  }
  clearSelection() {
    const coreStore = core();
    const mapStore = map();
    if (coreStore.debug) {
      console.debug("[CDEK] Clearing selected point");
    }
    coreStore.selected = false;
    coreStore.selectedTariff = null;
    mapStore.exactOffice = null;
    mapStore.pointInfo = null;
    mapStore.exactPoint = null;
  }
  destroy() {
    const coreStore = core();
    if (this.app === null) {
      throw new Error("CDEK widget is not mounted");
    }
    this.app.unmount();
    if (this.customDiv) {
      if (coreStore.debug) {
        console.debug("[CDEK] Widget used self-created div, removing it");
      }
      this.div.remove();
    }
    if (coreStore.debug) {
      console.debug("[CDEK] Widget destroyed, goodbye");
    }
  }
  open() {
    const coreStore = core();
    if (!coreStore.params.popup) {
      throw new Error("CDEK widget is not in popup");
    }
    coreStore.$patch({ globalPopup: true });
  }
  close() {
    const coreStore = core();
    if (!coreStore.params.popup) {
      throw new Error("CDEK widget is not in popup");
    }
    coreStore.$patch({ globalPopup: false });
  }
  addParcel(parcel) {
    const coreStorage = core();
    const goods = coreStorage.params.goods;
    if (Array.isArray(parcel)) {
      for (const el2 of parcel) {
        goods.push(el2);
      }
    } else {
      goods.push(parcel);
    }
    coreStorage.$patch({
      params: { ...coreStorage.params, goods }
    });
  }
  getParcels() {
    return toRaw(core().params.goods);
  }
  resetParcels() {
    const coreStorage = core();
    coreStorage.$patch({ params: { ...coreStorage.params, goods: [] } });
  }
  async init() {
    const coreStorage = core();
    const mapStorage = map();
    const searchStorage = search();
    coreStorage.$patch({
      params: this.params,
      mode: this.params.hideDeliveryOptions[DeliveryMode.OFFICE] ? DeliveryMode.DOOR : DeliveryMode.OFFICE
    });
    searchStorage.$patch({
      hideFilters: this.params.hideFilters,
      filters: this.params.forceFilters
    });
    mapStorage.plugMapScript(this.yandexMapSrc).finally(coreStorage.unlockUi);
    if (typeof this.params.defaultLocation === "string") {
      const geoData = await this.yandexApi.geocodeString(this.params.defaultLocation);
      if (geoData.found > 0) {
        mapStorage.location.center = geoData.members[0].position;
      }
    } else {
      mapStorage.location.center = this.params.defaultLocation;
    }
    coreStorage.lockUi();
    this.cdekApi.getOffices().then((offices) => mapStorage.offices = offices).then(() => {
      if (coreStorage.params.selected.office === null)
        return;
      const exactOffice = mapStorage.offices.filter(
        (office) => office.code === coreStorage.params.selected.office
      );
      if (exactOffice.length > 0) {
        if (coreStorage.debug) {
          console.debug("[CDEK] Selected predefined office", toRaw(exactOffice[0]));
        }
        mapStorage.$patch({ exactOffice: exactOffice[0] });
        coreStorage.$patch({ selected: true });
        coreStorage.togglePopup(Popup.INFO);
      }
    }).finally(coreStorage.unlockUi);
    const debouncedUpdate = debounce(async (input) => {
      try {
        mapStorage.offices = await this.cdekApi.getOffices();
        searchStorage.searchResults = (await this.yandexApi.geocodeString(input)).members;
        searchStorage.loading = false;
      } catch (e) {
        if (!isCancel(e))
          throw e;
      }
    }, 1e3);
    searchStorage.$subscribe(async (mutation, state) => {
      if (mutation.storeId !== "search" || mutation.type !== "patch object") {
        return;
      }
      searchStorage.loading = true;
      this.cdekApi.cancelOfficeRequest();
      this.yandexApi.cancelGeocodeStringRequest();
      await debouncedUpdate(state.value);
    });
    const debouncedSearch = debounce(async (coordinates) => {
      try {
        const result = await this.yandexApi.geocodeCoordinates(coordinates);
        if (result.found > 0) {
          mapStorage.$patch({
            pointInfo: result.members[0]
          });
        }
        searchStorage.loading = false;
      } catch (e) {
        if (!isCancel(e))
          throw e;
      }
    }, 2e3);
    mapStorage.$subscribe(async (mutation, state) => {
      if (mutation.storeId !== "map" || mutation.type !== "direct" || state.exactPoint === null || state.pointInfo !== null && state.pointInfo.position[0] === state.exactPoint[0] && state.pointInfo.position[1] === state.exactPoint[1]) {
        return;
      }
      searchStorage.loading = true;
      this.yandexApi.cancelGeocodeCoordinatesRequest();
      await debouncedSearch(state.exactPoint);
    });
    const debouncedPrice = debounce(async () => {
      var _a, _b, _c;
      const address = {
        address: (_a = mapStorage.pointInfo) == null ? void 0 : _a.formatted,
        code: (_b = mapStorage.exactOffice) == null ? void 0 : _b.city_code
      };
      try {
        const priceData = await this.cdekApi.getPrice(address);
        if (coreStorage.debug) {
          console.debug("[CDEK] Calculated prices", priceData, address);
        }
        coreStorage.tariffs = priceData;
        (_c = this.params.onCalculate) == null ? void 0 : _c.bind(this, priceData, address)();
      } catch (e) {
        if (!isCancel(e))
          throw e;
      }
    });
    mapStorage.$subscribe(async (mutation) => {
      if (mutation.storeId !== "map" || mutation.type !== "patch object" || coreStorage.params.from === null) {
        return;
      }
      if (coreStorage.debug) {
        console.debug("[CDEK] Catch map selection update, going price update");
      }
      this.cdekApi.cancelPriceRequest();
      await debouncedPrice();
    });
    coreStorage.$subscribe(async (mutation, state) => {
      if (mutation.storeId !== "core" || mutation.type !== "patch object" || state.params.goods.length < 1 || coreStorage.params.from === null) {
        return;
      }
      this.cdekApi.cancelPriceRequest();
      await debouncedPrice();
    });
    coreStorage.$subscribe(async (mutation, state) => {
      var _a;
      if (mutation.storeId !== "core" || mutation.type !== "patch function" || state.selectedTariff === null && !state.selected) {
        return;
      }
      if (coreStorage.debug) {
        console.debug(
          "[CDEK] Select button clicked",
          toRaw(state.selectedTariff),
          state.mode,
          state.mode === DeliveryMode.OFFICE ? toRaw(mapStorage.exactOffice) : toRaw(mapStorage.pointInfo)
        );
      }
      (_a = this.params.onChoose) == null ? void 0 : _a.bind(
        this,
        state.mode,
        toRaw(state.selectedTariff),
        state.mode === DeliveryMode.OFFICE ? toRaw(mapStorage.exactOffice) : toRaw(mapStorage.pointInfo)
      )();
    });
    coreStorage.$onAction(
      ({
        name,
        // name of the action
        store: store2,
        after
      }) => {
        if (name !== "unlockUi")
          return;
        after(() => {
          var _a;
          if (store2.uiLoadLocksCounter > 0)
            return;
          if (store2.debug) {
            console.debug("[CDEK] Widget has been loaded");
          }
          (_a = this.params.onReady) == null ? void 0 : _a.bind(this)();
        });
      }
    );
  }
}
export {
  Widget as default
};
